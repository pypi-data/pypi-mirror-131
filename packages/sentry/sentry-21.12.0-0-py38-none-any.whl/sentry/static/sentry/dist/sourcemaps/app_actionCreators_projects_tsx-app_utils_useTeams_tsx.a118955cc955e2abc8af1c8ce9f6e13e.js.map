{"version":3,"file":"chunks/app_actionCreators_projects_tsx-app_utils_useTeams_tsx.xxxxxxxxxxxxxxxxxxxx.js","mappings":"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","sources":["webpack:///./app/actionCreators/projects.tsx","webpack:///./app/actionCreators/teams.tsx","webpack:///./app/stores/projectsStatsStore.tsx","webpack:///./app/utils/isActiveSuperuser.tsx","webpack:///./app/utils/useTeams.tsx"],"sourcesContent":["import {Query} from 'history';\nimport chunk from 'lodash/chunk';\nimport debounce from 'lodash/debounce';\n\nimport {\n  addErrorMessage,\n  addLoadingMessage,\n  addSuccessMessage,\n} from 'sentry/actionCreators/indicator';\nimport ProjectActions from 'sentry/actions/projectActions';\nimport {Client} from 'sentry/api';\nimport {PlatformKey} from 'sentry/data/platformCategories';\nimport {t, tct} from 'sentry/locale';\nimport ProjectsStatsStore from 'sentry/stores/projectsStatsStore';\nimport {Project, Team} from 'sentry/types';\n\ntype UpdateParams = {\n  orgId: string;\n  projectId: string;\n  data?: {[key: string]: any};\n  query?: Query;\n};\n\nexport function update(api: Client, params: UpdateParams) {\n  ProjectActions.update(params.projectId, params.data);\n\n  const endpoint = `/projects/${params.orgId}/${params.projectId}/`;\n  return api\n    .requestPromise(endpoint, {\n      method: 'PUT',\n      data: params.data,\n    })\n    .then(\n      data => {\n        ProjectActions.updateSuccess(data);\n        return data;\n      },\n      err => {\n        ProjectActions.updateError(err, params.projectId);\n        throw err;\n      }\n    );\n}\n\ntype StatsParams = Pick<UpdateParams, 'orgId' | 'data' | 'query'>;\n\nexport function loadStats(api: Client, params: StatsParams) {\n  ProjectActions.loadStats(params.orgId, params.data);\n\n  const endpoint = `/organizations/${params.orgId}/stats/`;\n  api.request(endpoint, {\n    query: params.query,\n    success: data => {\n      ProjectActions.loadStatsSuccess(data);\n    },\n    error: data => {\n      ProjectActions.loadStatsError(data);\n    },\n  });\n}\n\n// This is going to queue up a list of project ids we need to fetch stats for\n// Will be cleared when debounced function fires\nconst _projectStatsToFetch: Set<string> = new Set();\n\n// Max projects to query at a time, otherwise if we fetch too many in the same request\n// it can timeout\nconst MAX_PROJECTS_TO_FETCH = 10;\n\nconst _queryForStats = (\n  api: Client,\n  projects: string[],\n  orgId: string,\n  additionalQuery: Query | undefined\n) => {\n  const idQueryParams = projects.map(project => `id:${project}`).join(' ');\n  const endpoint = `/organizations/${orgId}/projects/`;\n\n  const query: Query = {\n    statsPeriod: '24h',\n    query: idQueryParams,\n    ...additionalQuery,\n  };\n\n  return api.requestPromise(endpoint, {\n    query,\n  });\n};\n\nexport const _debouncedLoadStats = debounce(\n  (api: Client, projectSet: Set<string>, params: UpdateParams) => {\n    const storedProjects: {[key: string]: Project} = ProjectsStatsStore.getAll();\n    const existingProjectStats = Object.values(storedProjects).map(({id}) => id);\n    const projects = Array.from(projectSet).filter(\n      project => !existingProjectStats.includes(project)\n    );\n\n    if (!projects.length) {\n      _projectStatsToFetch.clear();\n      return;\n    }\n\n    // Split projects into more manageable chunks to query, otherwise we can\n    // potentially face server timeouts\n    const queries = chunk(projects, MAX_PROJECTS_TO_FETCH).map(chunkedProjects =>\n      _queryForStats(api, chunkedProjects, params.orgId, params.query)\n    );\n\n    Promise.all(queries)\n      .then(results => {\n        ProjectActions.loadStatsForProjectSuccess(\n          results.reduce((acc, result) => acc.concat(result), [])\n        );\n      })\n      .catch(() => {\n        addErrorMessage(t('Unable to fetch all project stats'));\n      });\n\n    // Reset projects list\n    _projectStatsToFetch.clear();\n  },\n  50\n);\n\nexport function loadStatsForProject(api: Client, project: string, params: UpdateParams) {\n  // Queue up a list of projects that we need stats for\n  // and call a debounced function to fetch stats for list of projects\n  _projectStatsToFetch.add(project);\n  _debouncedLoadStats(api, _projectStatsToFetch, params);\n}\n\nexport function setActiveProject(project: Project | null) {\n  ProjectActions.setActive(project);\n}\n\nexport function removeProject(api: Client, orgId: string, project: Project) {\n  const endpoint = `/projects/${orgId}/${project.slug}/`;\n\n  ProjectActions.removeProject(project);\n  return api\n    .requestPromise(endpoint, {\n      method: 'DELETE',\n    })\n    .then(\n      () => {\n        ProjectActions.removeProjectSuccess(project);\n        addSuccessMessage(\n          tct('[project] was successfully removed', {project: project.slug})\n        );\n      },\n      err => {\n        ProjectActions.removeProjectError(project);\n        addErrorMessage(tct('Error removing [project]', {project: project.slug}));\n        throw err;\n      }\n    );\n}\n\nexport function transferProject(\n  api: Client,\n  orgId: string,\n  project: Project,\n  email: string\n) {\n  const endpoint = `/projects/${orgId}/${project.slug}/transfer/`;\n\n  return api\n    .requestPromise(endpoint, {\n      method: 'POST',\n      data: {\n        email,\n      },\n    })\n    .then(\n      () => {\n        addSuccessMessage(\n          tct('A request was sent to move [project] to a different organization', {\n            project: project.slug,\n          })\n        );\n      },\n      err => {\n        let message = '';\n        // Handle errors with known failures\n        if (err.status >= 400 && err.status < 500 && err.responseJSON) {\n          message = err.responseJSON?.detail;\n        }\n\n        if (message) {\n          addErrorMessage(\n            tct('Error transferring [project]. [message]', {\n              project: project.slug,\n              message,\n            })\n          );\n        } else {\n          addErrorMessage(\n            tct('Error transferring [project]', {\n              project: project.slug,\n            })\n          );\n        }\n\n        throw err;\n      }\n    );\n}\n\n/**\n * Associate a team with a project\n */\n\n/**\n *  Adds a team to a project\n *\n * @param api API Client\n * @param orgSlug Organization Slug\n * @param projectSlug Project Slug\n * @param team Team data object\n */\nexport function addTeamToProject(\n  api: Client,\n  orgSlug: string,\n  projectSlug: string,\n  team: Team\n) {\n  const endpoint = `/projects/${orgSlug}/${projectSlug}/teams/${team.slug}/`;\n\n  addLoadingMessage();\n  ProjectActions.addTeam(team);\n\n  return api\n    .requestPromise(endpoint, {\n      method: 'POST',\n    })\n    .then(\n      project => {\n        addSuccessMessage(\n          tct('[team] has been added to the [project] project', {\n            team: `#${team.slug}`,\n            project: projectSlug,\n          })\n        );\n        ProjectActions.addTeamSuccess(team, projectSlug);\n        ProjectActions.updateSuccess(project);\n      },\n      err => {\n        addErrorMessage(\n          tct('Unable to add [team] to the [project] project', {\n            team: `#${team.slug}`,\n            project: projectSlug,\n          })\n        );\n        ProjectActions.addTeamError();\n        throw err;\n      }\n    );\n}\n\n/**\n * Removes a team from a project\n *\n * @param api API Client\n * @param orgSlug Organization Slug\n * @param projectSlug Project Slug\n * @param teamSlug Team Slug\n */\nexport function removeTeamFromProject(\n  api: Client,\n  orgSlug: string,\n  projectSlug: string,\n  teamSlug: string\n) {\n  const endpoint = `/projects/${orgSlug}/${projectSlug}/teams/${teamSlug}/`;\n\n  addLoadingMessage();\n  ProjectActions.removeTeam(teamSlug);\n\n  return api\n    .requestPromise(endpoint, {\n      method: 'DELETE',\n    })\n    .then(\n      project => {\n        addSuccessMessage(\n          tct('[team] has been removed from the [project] project', {\n            team: `#${teamSlug}`,\n            project: projectSlug,\n          })\n        );\n        ProjectActions.removeTeamSuccess(teamSlug, projectSlug);\n        ProjectActions.updateSuccess(project);\n      },\n      err => {\n        addErrorMessage(\n          tct('Unable to remove [team] from the [project] project', {\n            team: `#${teamSlug}`,\n            project: projectSlug,\n          })\n        );\n        ProjectActions.removeTeamError(err);\n        throw err;\n      }\n    );\n}\n\n/**\n * Change a project's slug\n *\n * @param prev Previous slug\n * @param next New slug\n */\nexport function changeProjectSlug(prev: string, next: string) {\n  ProjectActions.changeSlug(prev, next);\n}\n\n/**\n * Send a sample event\n *\n * @param api API Client\n * @param orgSlug Organization Slug\n * @param projectSlug Project Slug\n */\nexport function sendSampleEvent(api: Client, orgSlug: string, projectSlug: string) {\n  const endpoint = `/projects/${orgSlug}/${projectSlug}/create-sample/`;\n\n  return api.requestPromise(endpoint, {\n    method: 'POST',\n  });\n}\n\n/**\n * Creates a project\n *\n * @param api API Client\n * @param orgSlug Organization Slug\n * @param team The team slug to assign the project to\n * @param name Name of the project\n * @param platform The platform key of the project\n * @param options Additional options such as creating default alert rules\n */\nexport function createProject(\n  api: Client,\n  orgSlug: string,\n  team: string,\n  name: string,\n  platform: string,\n  options: {defaultRules?: boolean} = {}\n) {\n  return api.requestPromise(`/teams/${orgSlug}/${team}/projects/`, {\n    method: 'POST',\n    data: {name, platform, default_rules: options.defaultRules},\n  });\n}\n\n/**\n * Load platform documentation specific to the project. The DSN and various\n * other project specific secrets will be included in the documentation.\n *\n * @param api API Client\n * @param orgSlug Organization Slug\n * @param projectSlug Project Slug\n * @param platform Project platform.\n */\nexport function loadDocs(\n  api: Client,\n  orgSlug: string,\n  projectSlug: string,\n  platform: PlatformKey\n) {\n  return api.requestPromise(`/projects/${orgSlug}/${projectSlug}/docs/${platform}/`);\n}\n\n/**\n * Load the counts of my projects and all projects for the current user\n *\n * @param api API Client\n * @param orgSlug Organization Slug\n */\nexport function fetchProjectsCount(api: Client, orgSlug: string) {\n  return api.requestPromise(`/organizations/${orgSlug}/projects-count/`);\n}\n\n/**\n * Check if there are any releases in the last 90 days.\n * Used for checking if project is using releases.\n *\n * @param api API Client\n * @param orgSlug Organization Slug\n * @param projectId Project Id\n */\nexport async function fetchAnyReleaseExistence(\n  api: Client,\n  orgSlug: string,\n  projectId: number | string\n) {\n  const data = await api.requestPromise(`/organizations/${orgSlug}/releases/stats/`, {\n    method: 'GET',\n    query: {\n      statsPeriod: '90d',\n      project: projectId,\n      per_page: 1,\n    },\n  });\n\n  return data.length > 0;\n}\n","import {addErrorMessage, addSuccessMessage} from 'sentry/actionCreators/indicator';\nimport TeamActions from 'sentry/actions/teamActions';\nimport {Client} from 'sentry/api';\nimport {tct} from 'sentry/locale';\nimport {Team} from 'sentry/types';\nimport {callIfFunction} from 'sentry/utils/callIfFunction';\nimport {uniqueId} from 'sentry/utils/guid';\n\ntype CallbackOptions = {\n  success?: Function;\n  error?: Function;\n};\n\nconst doCallback = (\n  params: CallbackOptions = {},\n  name: keyof CallbackOptions,\n  ...args: any[]\n) => {\n  callIfFunction(params[name], ...args);\n};\n\n/**\n * Note these are both slugs\n */\ntype OrgSlug = {orgId: string};\ntype OrgAndTeamSlug = OrgSlug & {teamId: string};\n\ntype TeamData = {data: Team};\n\n/**\n * This is the actual internal id, not username or email\n */\ntype MemberId = {memberId: string};\n\n// Fetch teams for org\nexport function fetchTeams(api: Client, params: OrgSlug, options: CallbackOptions) {\n  TeamActions.fetchAll(params.orgId);\n  return api.request(`/teams/${params.orgId}/`, {\n    success: data => {\n      TeamActions.fetchAllSuccess(params.orgId, data);\n      doCallback(options, 'success', data);\n    },\n    error: error => {\n      TeamActions.fetchAllError(params.orgId, error);\n      doCallback(options, 'error', error);\n    },\n  });\n}\n\n// Fetch user teams for current org and place them in the team store\nexport async function fetchUserTeams(api: Client, params: OrgSlug) {\n  const teams = await api.requestPromise(`/organizations/${params.orgId}/user-teams/`);\n  TeamActions.loadUserTeams(teams);\n}\n\nexport function fetchTeamDetails(\n  api: Client,\n  params: OrgAndTeamSlug,\n  options?: CallbackOptions\n) {\n  TeamActions.fetchDetails(params.teamId);\n  return api.request(`/teams/${params.orgId}/${params.teamId}/`, {\n    success: data => {\n      TeamActions.fetchDetailsSuccess(params.teamId, data);\n      doCallback(options, 'success', data);\n    },\n    error: error => {\n      TeamActions.fetchDetailsError(params.teamId, error);\n      doCallback(options, 'error', error);\n    },\n  });\n}\n\nexport function updateTeamSuccess(teamId: OrgAndTeamSlug['teamId'], data: Team) {\n  TeamActions.updateSuccess(teamId, data);\n}\n\nexport function updateTeam(\n  api: Client,\n  params: OrgAndTeamSlug & TeamData,\n  options: CallbackOptions\n) {\n  const endpoint = `/teams/${params.orgId}/${params.teamId}/`;\n  TeamActions.update(params.teamId, params.data);\n\n  return api.request(endpoint, {\n    method: 'PUT',\n    data: params.data,\n    success: data => {\n      updateTeamSuccess(params.teamId, data);\n      doCallback(options, 'success', data);\n    },\n    error: error => {\n      TeamActions.updateError(params.teamId, error);\n      doCallback(options, 'error', error);\n    },\n  });\n}\n\nexport function joinTeam(\n  api: Client,\n  params: OrgAndTeamSlug & Partial<MemberId>,\n  options: CallbackOptions\n) {\n  const endpoint = `/organizations/${params.orgId}/members/${\n    params.memberId ?? 'me'\n  }/teams/${params.teamId}/`;\n  const id = uniqueId();\n\n  TeamActions.update(id, params.teamId);\n\n  return api.request(endpoint, {\n    method: 'POST',\n    success: data => {\n      TeamActions.updateSuccess(params.teamId, data);\n      doCallback(options, 'success', data);\n    },\n    error: error => {\n      TeamActions.updateError(id, params.teamId, error);\n      doCallback(options, 'error', error);\n    },\n  });\n}\n\nexport function leaveTeam(\n  api: Client,\n  params: OrgAndTeamSlug & Partial<MemberId>,\n  options: CallbackOptions\n) {\n  const endpoint = `/organizations/${params.orgId}/members/${\n    params.memberId || 'me'\n  }/teams/${params.teamId}/`;\n  const id = uniqueId();\n\n  TeamActions.update(id, params.teamId);\n\n  return api.request(endpoint, {\n    method: 'DELETE',\n    success: data => {\n      TeamActions.updateSuccess(params.teamId, data);\n      doCallback(options, 'success', data);\n    },\n    error: error => {\n      TeamActions.updateError(id, params.teamId, error);\n      doCallback(options, 'error', error);\n    },\n  });\n}\n\nexport function createTeam(api: Client, team: Pick<Team, 'slug'>, params: OrgSlug) {\n  TeamActions.createTeam(team);\n\n  return api\n    .requestPromise(`/organizations/${params.orgId}/teams/`, {\n      method: 'POST',\n      data: team,\n    })\n    .then(\n      data => {\n        TeamActions.createTeamSuccess(data);\n        addSuccessMessage(\n          tct('[team] has been added to the [organization] organization', {\n            team: `#${data.slug}`,\n            organization: params.orgId,\n          })\n        );\n        return data;\n      },\n      err => {\n        TeamActions.createTeamError(team.slug, err);\n        addErrorMessage(\n          tct('Unable to create [team] in the [organization] organization', {\n            team: `#${team.slug}`,\n            organization: params.orgId,\n          })\n        );\n        throw err;\n      }\n    );\n}\n\nexport function removeTeam(api: Client, params: OrgAndTeamSlug) {\n  TeamActions.removeTeam(params.teamId);\n\n  return api\n    .requestPromise(`/teams/${params.orgId}/${params.teamId}/`, {\n      method: 'DELETE',\n    })\n    .then(\n      data => {\n        TeamActions.removeTeamSuccess(params.teamId, data);\n        addSuccessMessage(\n          tct('[team] has been removed from the [organization] organization', {\n            team: `#${params.teamId}`,\n            organization: params.orgId,\n          })\n        );\n        return data;\n      },\n      err => {\n        TeamActions.removeTeamError(params.teamId, err);\n        addErrorMessage(\n          tct('Unable to remove [team] from the [organization] organization', {\n            team: `#${params.teamId}`,\n            organization: params.orgId,\n          })\n        );\n        throw err;\n      }\n    );\n}\n","import Reflux from 'reflux';\n\nimport ProjectActions from 'sentry/actions/projectActions';\nimport {Project} from 'sentry/types';\n\ntype ProjectsStatsStoreInterface = {\n  itemsBySlug: Record<string, Project>;\n\n  getInitialState(): ProjectsStatsStoreInterface['itemsBySlug'];\n  reset(): void;\n  getBySlug(slug: string): Project;\n  getAll(): ProjectsStatsStoreInterface['itemsBySlug'];\n};\n\n/**\n * This is a store specifically used by the dashboard, so that we can\n * clear the store when the Dashboard unmounts\n * (as to not disrupt ProjectsStore which a lot more components use)\n */\nconst storeConfig: Reflux.StoreDefinition & ProjectsStatsStoreInterface = {\n  itemsBySlug: {},\n\n  init() {\n    this.reset();\n    this.listenTo(ProjectActions.loadStatsForProjectSuccess, this.onStatsLoadSuccess);\n    this.listenTo(ProjectActions.update, this.onUpdate);\n    this.listenTo(ProjectActions.updateError, this.onUpdateError);\n  },\n\n  getInitialState() {\n    return this.itemsBySlug;\n  },\n\n  reset() {\n    this.itemsBySlug = {};\n    this.updatingItems = new Map();\n  },\n\n  onStatsLoadSuccess(projects: Project[]) {\n    projects.forEach(project => {\n      this.itemsBySlug[project.slug] = project;\n    });\n    this.trigger(this.itemsBySlug);\n  },\n\n  /**\n   * Optimistic updates\n   * @param projectSlug Project slug\n   * @param data Project data\n   */\n  onUpdate(projectSlug: string, data: Project) {\n    const project = this.getBySlug(projectSlug);\n    this.updatingItems.set(projectSlug, project);\n    if (!project) {\n      return;\n    }\n\n    const newProject: Project = {\n      ...project,\n      ...data,\n    };\n\n    this.itemsBySlug = {\n      ...this.itemsBySlug,\n      [project.slug]: newProject,\n    };\n    this.trigger(this.itemsBySlug);\n  },\n\n  onUpdateSuccess(data: Project) {\n    // Remove project from updating map\n    this.updatingItems.delete(data.slug);\n  },\n\n  /**\n   * Revert project data when there was an error updating project details\n   * @param err Error object\n   * @param data Previous project data\n   */\n  onUpdateError(_err: Error, projectSlug: string) {\n    const project = this.updatingItems.get(projectSlug);\n    if (!project) {\n      return;\n    }\n\n    this.updatingItems.delete(projectSlug);\n    // Restore old project\n    this.itemsBySlug = {\n      ...this.itemsBySlug,\n      [project.slug]: {...project},\n    };\n    this.trigger(this.itemsBySlug);\n  },\n\n  getAll() {\n    return this.itemsBySlug;\n  },\n\n  getBySlug(slug) {\n    return this.itemsBySlug[slug];\n  },\n};\n\nconst ProjectsStatsStore = Reflux.createStore(storeConfig) as Reflux.Store &\n  ProjectsStatsStoreInterface;\n\nexport default ProjectsStatsStore;\n","import Cookies from 'js-cookie';\n\nimport ConfigStore from 'sentry/stores/configStore';\n\nconst SUPERUSER_COOKIE_NAME = 'su';\n\n/**\n * Checking for just isSuperuser on a config object may not be enough as backend often checks for *active* superuser.\n * We therefore check both isSuperuser flag AND superuser session cookie.\n */\nexport function isActiveSuperuser() {\n  const {isSuperuser} = ConfigStore.get('user') || {};\n\n  if (isSuperuser) {\n    /**\n     * Superuser cookie cannot be checked for existence as it is HttpOnly.\n     * As a workaround, we try to change it to something else and if that fails we can assume that it's being present.\n     * There may be an edgecase where it's present and expired but for current usage it's not a big deal.\n     */\n    Cookies.set(SUPERUSER_COOKIE_NAME, 'test');\n\n    if (Cookies.get(SUPERUSER_COOKIE_NAME) === undefined) {\n      return true;\n    }\n  }\n\n  return false;\n}\n","import {useEffect, useRef, useState} from 'react';\nimport uniqBy from 'lodash/uniqBy';\n\nimport {fetchUserTeams} from 'sentry/actionCreators/teams';\nimport TeamActions from 'sentry/actions/teamActions';\nimport {Client} from 'sentry/api';\nimport OrganizationStore from 'sentry/stores/organizationStore';\nimport TeamStore from 'sentry/stores/teamStore';\nimport {useLegacyStore} from 'sentry/stores/useLegacyStore';\nimport {Team} from 'sentry/types';\nimport {isActiveSuperuser} from 'sentry/utils/isActiveSuperuser';\nimport parseLinkHeader from 'sentry/utils/parseLinkHeader';\nimport RequestError from 'sentry/utils/requestError/requestError';\nimport useApi from 'sentry/utils/useApi';\n\ntype State = {\n  /**\n   * Reflects whether or not the initial fetch for the requested teams was\n   * fulfilled\n   */\n  initiallyLoaded: boolean;\n  /**\n   * This is state for when fetching data from API\n   */\n  fetching: boolean;\n  /**\n   * The error that occurred if fetching failed\n   */\n  fetchError: null | RequestError;\n  /**\n   * Indicates that Team results (from API) are paginated and there are more\n   * Teams that are not in the initial response.\n   */\n  hasMore: null | boolean;\n  /**\n   * The last query we searched. Used to validate the cursor\n   */\n  lastSearch: null | string;\n  /**\n   * Pagination\n   */\n  nextCursor?: null | string;\n};\n\nexport type Result = {\n  /**\n   * The loaded teams list\n   */\n  teams: Team[];\n  /**\n   * This is an action provided to consumers for them to update the current\n   * teams result set using a simple search query.\n   *\n   * Will always add new options into the store.\n   */\n  onSearch: (searchTerm: string) => Promise<void>;\n  /**\n   * This is an action provided to consumers for them to request more teams\n   * to be loaded. Additional teams will be fetched and loaded into the store.\n   */\n  loadMore: (searchTerm?: string) => Promise<void>;\n} & Pick<State, 'fetching' | 'hasMore' | 'fetchError' | 'initiallyLoaded'>;\n\ntype Options = {\n  /**\n   * Number of teams to return when not using `props.slugs`\n   */\n  limit?: number;\n  /**\n   * When provided, fetches specified teams by slug if necessary and only provides those teams.\n   */\n  slugs?: string[];\n  /**\n   * When provided, fetches specified teams by id if necessary and only provides those teams.\n   */\n  ids?: string[];\n  /**\n   * When true, fetches user's teams if necessary and only provides user's\n   * teams (isMember = true).\n   */\n  provideUserTeams?: boolean;\n};\n\ntype FetchTeamOptions = {\n  slugs?: string[];\n  ids?: string[];\n  limit?: Options['limit'];\n  cursor?: State['nextCursor'];\n  search?: State['lastSearch'];\n  lastSearch?: State['lastSearch'];\n};\n\n/**\n * Helper function to actually load teams\n */\nasync function fetchTeams(\n  api: Client,\n  orgId: string,\n  {slugs, ids, search, limit, lastSearch, cursor}: FetchTeamOptions = {}\n) {\n  const query: {\n    query?: string;\n    cursor?: typeof cursor;\n    per_page?: number;\n  } = {};\n\n  if (slugs !== undefined && slugs.length > 0) {\n    query.query = slugs.map(slug => `slug:${slug}`).join(' ');\n  }\n\n  if (ids !== undefined && ids.length > 0) {\n    query.query = ids.map(id => `id:${id}`).join(' ');\n  }\n\n  if (search) {\n    query.query = `${query.query ?? ''} ${search}`.trim();\n  }\n\n  const isSameSearch = lastSearch === search || (!lastSearch && !search);\n\n  if (isSameSearch && cursor) {\n    query.cursor = cursor;\n  }\n\n  if (limit !== undefined) {\n    query.per_page = limit;\n  }\n\n  let hasMore: null | boolean = false;\n  let nextCursor: null | string = null;\n  const [data, , resp] = await api.requestPromise(`/organizations/${orgId}/teams/`, {\n    includeAllArgs: true,\n    query,\n  });\n\n  const pageLinks = resp?.getResponseHeader('Link');\n  if (pageLinks) {\n    const paginationObject = parseLinkHeader(pageLinks);\n    hasMore = paginationObject?.next?.results;\n    nextCursor = paginationObject?.next?.cursor;\n  }\n\n  return {results: data, hasMore, nextCursor};\n}\n\n// TODO: Paging for items which have already exist in the store is not\n// correctly implemented.\n\n/**\n * Provides teams from the TeamStore\n *\n * This hook also provides a way to select specific slugs to ensure they are\n * loaded, as well as search (type-ahead) for more slugs that may not be in the\n * TeamsStore.\n *\n * NOTE: It is NOT guaranteed that all teams for an organization will be\n * loaded, so you should use this hook with the intention of providing specific\n * slugs, or loading more through search.\n *\n */\nfunction useTeams({limit, slugs, ids, provideUserTeams}: Options = {}) {\n  const api = useApi();\n  const {organization} = useLegacyStore(OrganizationStore);\n  const store = useLegacyStore(TeamStore);\n\n  const orgId = organization?.slug;\n\n  const storeSlugs = new Set(store.teams.map(t => t.slug));\n  const slugsToLoad = slugs?.filter(slug => !storeSlugs.has(slug)) ?? [];\n  const storeIds = new Set(store.teams.map(t => t.id));\n  const idsToLoad = ids?.filter(id => !storeIds.has(id)) ?? [];\n  const shouldLoadSlugs = slugsToLoad.length > 0;\n  const shouldLoadIds = idsToLoad.length > 0;\n  const shouldLoadTeams = provideUserTeams && !store.loadedUserTeams;\n\n  // If we don't need to make a request either for slugs or user teams, set\n  // initiallyLoaded to true\n  const initiallyLoaded = !shouldLoadSlugs && !shouldLoadTeams && !shouldLoadIds;\n\n  const [state, setState] = useState<State>({\n    initiallyLoaded,\n    fetching: false,\n    hasMore: store.hasMore,\n    lastSearch: null,\n    nextCursor: store.cursor,\n    fetchError: null,\n  });\n\n  const slugOrIdRef = useRef<Set<string> | null>(null);\n\n  // Only initialize slugOrIdRef.current once and modify it when we receive new\n  // slugs or ids determined through set equality\n  if (slugs !== undefined || ids !== undefined) {\n    const slugsOrIds = (slugs || ids) ?? [];\n    if (slugOrIdRef.current === null) {\n      slugOrIdRef.current = new Set(slugsOrIds);\n    }\n\n    if (\n      slugsOrIds.length !== slugOrIdRef.current.size ||\n      slugsOrIds.some(slugOrId => !slugOrIdRef.current?.has(slugOrId))\n    ) {\n      slugOrIdRef.current = new Set(slugsOrIds);\n    }\n  }\n\n  async function loadUserTeams() {\n    if (orgId === undefined) {\n      return;\n    }\n\n    setState({...state, fetching: true});\n    try {\n      await fetchUserTeams(api, {orgId});\n\n      setState({...state, fetching: false, initiallyLoaded: true});\n    } catch (err) {\n      console.error(err); // eslint-disable-line no-console\n\n      setState({...state, fetching: false, initiallyLoaded: true, fetchError: err});\n    }\n  }\n\n  async function loadTeamsBySlugOrId() {\n    if (orgId === undefined) {\n      return;\n    }\n\n    setState({...state, fetching: true});\n    try {\n      const {results, hasMore, nextCursor} = await fetchTeams(api, orgId, {\n        slugs: slugsToLoad,\n        ids: idsToLoad,\n        limit,\n      });\n\n      const fetchedTeams = uniqBy([...store.teams, ...results], ({slug}) => slug);\n      TeamActions.loadTeams(fetchedTeams);\n\n      setState({\n        ...state,\n        hasMore,\n        fetching: false,\n        initiallyLoaded: true,\n        nextCursor,\n      });\n    } catch (err) {\n      console.error(err); // eslint-disable-line no-console\n\n      setState({...state, fetching: false, initiallyLoaded: true, fetchError: err});\n    }\n  }\n\n  async function handleSearch(search: string) {\n    if (search === '') {\n      // Reset pagination state to match store if doing an empty search\n      if (state.hasMore !== store.hasMore || state.nextCursor !== store.cursor) {\n        setState({\n          ...state,\n          lastSearch: search,\n          hasMore: store.hasMore,\n          nextCursor: store.cursor,\n        });\n      }\n\n      return;\n    }\n    handleFetchAdditionalTeams(search);\n  }\n\n  async function handleFetchAdditionalTeams(search?: string) {\n    const {lastSearch} = state;\n    // Use the store cursor if there is no search keyword provided\n    const cursor = search ? state.nextCursor : store.cursor;\n\n    if (orgId === undefined) {\n      // eslint-disable-next-line no-console\n      console.error('Cannot fetch teams without an organization in context');\n      return;\n    }\n\n    setState({...state, fetching: true});\n\n    try {\n      api.clear();\n      const {results, hasMore, nextCursor} = await fetchTeams(api, orgId, {\n        search,\n        limit,\n        lastSearch,\n        cursor,\n      });\n\n      const fetchedTeams = uniqBy([...store.teams, ...results], ({slug}) => slug);\n\n      if (search) {\n        // Only update the store if we have more items\n        if (fetchedTeams.length > store.teams.length) {\n          TeamActions.loadTeams(fetchedTeams);\n        }\n      } else {\n        // If we fetched a page of teams without a search query, add cursor data to the store\n        TeamActions.loadTeams(fetchedTeams, hasMore, nextCursor);\n      }\n\n      setState({\n        ...state,\n        hasMore: hasMore && store.hasMore,\n        fetching: false,\n        lastSearch: search ?? null,\n        nextCursor,\n      });\n    } catch (err) {\n      console.error(err); // eslint-disable-line no-console\n\n      setState({...state, fetching: false, fetchError: err});\n    }\n  }\n\n  useEffect(() => {\n    // Load specified team slugs\n    if (shouldLoadSlugs || shouldLoadIds) {\n      loadTeamsBySlugOrId();\n      return;\n    }\n\n    // Load user teams\n    if (shouldLoadTeams) {\n      loadUserTeams();\n    }\n  }, [slugOrIdRef.current, provideUserTeams]);\n\n  const isSuperuser = isActiveSuperuser();\n\n  const filteredTeams = slugs\n    ? store.teams.filter(t => slugs.includes(t.slug))\n    : ids\n    ? store.teams.filter(t => ids.includes(t.id))\n    : provideUserTeams && !isSuperuser\n    ? store.teams.filter(t => t.isMember)\n    : store.teams;\n\n  const result: Result = {\n    teams: filteredTeams,\n    fetching: state.fetching || store.loading,\n    initiallyLoaded: state.initiallyLoaded,\n    fetchError: state.fetchError,\n    hasMore: state.hasMore,\n    onSearch: handleSearch,\n    loadMore: handleFetchAdditionalTeams,\n  };\n\n  return result;\n}\n\nexport default useTeams;\n"],"names":["update","api","params","ProjectActions","projectId","data","endpoint","orgId","requestPromise","method","then","err","loadStats","request","query","success","error","_projectStatsToFetch","Set","_debouncedLoadStats","debounce","projectSet","storedProjects","ProjectsStatsStore","existingProjectStats","Object","values","map","id","projects","Array","from","filter","project","includes","length","clear","queries","chunk","chunkedProjects","additionalQuery","idQueryParams","join","statsPeriod","_queryForStats","Promise","all","results","reduce","acc","result","concat","catch","addErrorMessage","t","loadStatsForProject","add","setActiveProject","removeProject","slug","addSuccessMessage","tct","transferProject","email","message","status","responseJSON","detail","addTeamToProject","orgSlug","projectSlug","team","addLoadingMessage","removeTeamFromProject","teamSlug","changeProjectSlug","prev","next","createProject","name","platform","options","default_rules","defaultRules","loadDocs","fetchProjectsCount","async","fetchAnyReleaseExistence","per_page","doCallback","args","callIfFunction","fetchUserTeams","teams","TeamActions","fetchTeamDetails","teamId","updateTeamSuccess","updateTeam","joinTeam","memberId","uniqueId","leaveTeam","createTeam","organization","removeTeam","storeConfig","itemsBySlug","init","this","reset","listenTo","onStatsLoadSuccess","onUpdate","onUpdateError","getInitialState","updatingItems","Map","forEach","trigger","getBySlug","set","newProject","onUpdateSuccess","delete","_err","get","getAll","Reflux","isActiveSuperuser","isSuperuser","ConfigStore","Cookies","undefined","fetchTeams","slugs","ids","search","limit","lastSearch","cursor","trim","hasMore","nextCursor","resp","includeAllArgs","pageLinks","getResponseHeader","paginationObject","parseLinkHeader","provideUserTeams","useApi","useLegacyStore","OrganizationStore","store","TeamStore","storeSlugs","slugsToLoad","has","storeIds","idsToLoad","shouldLoadSlugs","shouldLoadIds","shouldLoadTeams","loadedUserTeams","initiallyLoaded","state","setState","useState","fetching","fetchError","slugOrIdRef","useRef","slugsOrIds","current","size","some","slugOrId","handleFetchAdditionalTeams","fetchedTeams","uniqBy","console","useEffect","loadTeamsBySlugOrId","loadUserTeams","isMember","loading","onSearch","loadMore"],"sourceRoot":""}