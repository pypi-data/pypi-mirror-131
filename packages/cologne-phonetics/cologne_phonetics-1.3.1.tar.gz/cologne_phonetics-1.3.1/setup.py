# -*- coding: utf-8 -*-
from setuptools import setup

modules = \
['cologne_phonetics']
setup_kwargs = {
    'name': 'cologne-phonetics',
    'version': '1.3.1',
    'description': 'Python implementation of the cologne-phonetics algorithm',
    'long_description': '.. _release: https://raw.githubusercontent.com/provinzkraut/cologne_phonetics/1.2.2/cologne_phonetics.py\n.. _`try out`: https://phonetics.provinzkraut.de\n.. _`API`: https://phonetics.provinzkraut.de/api_doc\n.. _`PyPi`: https://pypi.org/project/cologne-phonetics/\n\n\n=================\nCologne-phonetics\n=================\n\n.. image:: https://travis-ci.org/provinzkraut/cologne_phonetics.svg?branch=master\n    :target: https://travis-ci.org/provinzkraut/cologne_phonetics\n    :alt: cologne_phonetics build\n    \n.. image:: https://coveralls.io/repos/github/provinzkraut/cologne_phonetics/badge.svg?branch=master\n    :target: https://coveralls.io/github/provinzkraut/cologne_phonetics?branch=master\n    :alt: cologne_phonetics coverage\n    \n.. image:: https://img.shields.io/pypi/pyversions/cologne-phonetics.svg   \n    :alt: PyPI version\n    \n\nContents\n========\n\n- `Cologne-phonetics`_\n\n  - `Introduction`_\n  - `Examples`_\n- `Installation`_\n- `Usage`_\n\n  - `Module contents`_\n\n    - `encode`_\n    - `compare`_\n  - `Examples`_\n  - `Command line interface`_\n- `Special characters`_\n\n  - `Word breaks and hyphens`_\n  - `Umlaut and special character replacement`_\n\n- `Changelog`_\n\n  - `1.2.0`_\n  - `1.2.1`_\n  - `1.2.2`_\n  - `1.2.3`_\n  - `1.2.4`_\n  - `1.3.0`_\n  - `1.3.1`_\n\n\n\nIntroduction\n============\n\nCologne-phonetics is a phonetic algorithm similar to Soundex, wich encodes words\ninto a phonetic code, making it possible to compare how they *sound* rather than how they\'re *written*.\nIt was developed by Hans Postel and contrary to Soundex, it\'s designed specific\nfor the german language.\n\nIt involves three steps:\n\n- Generate a code by representing every letter from left to right with a digit, according to a conversion table\n- Remove double digits\n- Remove every occurrence of \'0\', except as a leading digit\n\nThe module itself is quite simple and consists only of the `encode`_ and `compare`_  functions\nand a simple command line interface.\n\n\nExamples\n========\n\n.. code-block:: bash\n\n  $ cologne_phonetics.py "peter pédter"\n  127, 127\n  $ cologne_phonetics.py "umwelt umhwält"\n  06352, 06352\n  $ cologne_phonetics.py "urlaub uhrlaup"\n  0751, 0751\n\nAs you can see, similar sounding names produce the same result, with respect to the *correct* pronunciation.\n\n.. code-block:: bash\n\n  $ cologne_phonetics.py "peter peta"\n  127, 12\n\nThis does not give the same result for each word because they may *look* similar,\nbut (when pronounced correctly) don\'t really *sound* alike.\n\n\n============\nInstallation\n============\n\ncologne_phonetics runs with Python 3.4+ or PyPy 3.5.\nIt is available on `PyPi`_ and can be installed it via pip:\n\n.. code-block:: bash\n\n  pip install cologne_phonetics\n\nAlternatively you can download the latest release_ directly.\n\n\n=====\nUsage\n=====\n\nModule contents\n===============\n\n.. _encode:\n\nencode(data, *concat=False*)\n  Return a list of result tuples.\n\n  Each tuple consists of the string that was encoded and its result.\n\n  If the input string is altered in any way before encoding, the tuple will\n  contain the altered version.\n\n  .. code-block:: python\n\n    >>> cologne_phonetics.encode("bäteS")\n    >>> [(\'baetes\', \'128\')]\n\n  If ``concat=True`` is passed, words connected with hyphens will be treated as\n  a single words.\n\n  Most of the time, the list will be ``len(result_list) == 1``. Only if the input string\n  contains a space character or a hyphen it is splitted into substrings and each\n  substring will be encoded seperately.\n\n.. _compare:\n\ncompare(\\*data, *concat=False*)\n  Parameter\n    \\*data. Either at last 2 positional arguments or an iterable\n  Returns\n    `True` if all encoded strings are equal, else `False`\n  Raises\n    `ValueError`.\n    If only one value is submitted or the submitted Iterable is of lenght 1.\n\n\nCommand line interface\n======================\n\n.. code-block:: bash\n\n  $ cologne_phonetics.py hello\n  05\n  $ cologne_phonetics.py hello world\n  05, 3752\n\n\nOptional arguments\n~~~~~~~~~~~~~~~~~~~~\n\n-h, --help\n  show this help message and exit\n-c, --concat\n  treat words connected by hyphens as seperate words\n-v, --verbose\n  show detailed information\n-p, --pretty\n  format output nicely\n\n\n\n===================\nSpecial characters\n===================\n\nSpecial characters are all characters that are not ascii-characters between A and Z.\nMost special characters are simply ignored, but even within the set of special characters,\nthere are some that are even *more* special.\n\n\nWord breaks and hyphens\n========================\n\nBy default, words connected by hyphens, e.g. ``meier-lüdenscheid`` are seperated.\nSo ``meier-lüdenscheid`` would become ``\'67\', \'52682\'``. If you\nwant it to be treated as a single word, you can pass a ``concat=True``\nto the encode functions.\n\nWhile at first this doesn\'t seem to make a difference in the result, other than it being split\ninto a list of strings, in some cases it can make a difference.\n\n.. code-block:: python\n\n  >>> cologne_phonetics.encode("weiss-chemie")\n  >>> [(\'weiss\', \'38\'), (\'chemie\', \'46\')]\n  >>> cologne_phonetics.encode("weiss-chemie", concat=True)\n  >>> [(\'weiss-chemie\', \'386\')]\n\nAs you can see, a ``4`` got lost here.\nIn case you *really* want to compare the concatenated words you may use this option,\nbut in general there\'s not much use to it.\n\n\nUmlaut and special character replacement\n=========================================\n\nUmlaute and some other special characters are converted to their non-special equivalent.\n\n======  ==========\nUmlaut  conversion\n======  ==========\nü       ue\nö       oe\nä       ae\nß       s\né       e\nè       e\ná       a\nà       a\n======  ==========\n\n\n=========\nChangelog\n=========\n\n1.2.0\n=====\n\n- Removed `encode_many()`\n- `encode()` now allways returns a list of result tuples\n- Added `--verbose` and `--pretty` options to CLI\n- New function: `compare()`\n\n1.2.1\n=====\n\n- Fixed an error that would lead to case sensitive comparison in `compare`_\n\n1.2.2\n=====\n\n- Another error in `compare`_ was found (and fixed); Compare didn\'t actually compare output. It compared input. This was due to bad tests and introduced in 1.2.0, with the change that made `encode`_ always return a tuple as a result\n\n1.2.3\n=====\n\n- PyPy 3.5 is now officially supported\n- A bug was fixed that would lead `encode`_ to sometimes an preprocessed rather than the altered string in the result tuple\n\n\n1.2.4\n=====\n\n- Drop support for Python 3.4 and 3.5\n- Add tests for Python 3.8 and 3.9\n- Remove deprecated ``Iterable`` import. See #1\n\n\n1.3.0\n=====\n\n- Add more robust replacement of diacritic using ``unicodedata`` (provided by `Tobias Bengfort <https://github.com/xi>`_ )\n- Add type hints\n- Fix issue where ``concat`` parameter of `compare`_ wasn\'t passed to `encode`_\n\n\n1.3.1\n=====\n\n- Run tests against Python 3.10\n- Add missing Readme to pyproject.toml\n- Drop Python 3.6 support',
    'author': 'Janek Nouvertné',
    'author_email': 'None',
    'maintainer': 'None',
    'maintainer_email': 'None',
    'url': 'None',
    'py_modules': modules,
    'python_requires': '>=3.7',
}


setup(**setup_kwargs)
