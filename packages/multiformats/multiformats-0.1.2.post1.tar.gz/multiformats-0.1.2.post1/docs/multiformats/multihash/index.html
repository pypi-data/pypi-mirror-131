<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>multiformats.multihash API documentation</title>
<meta name="description" content="Implementation of the [multihash spec](https://github.com/multiformats/multihash) â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}.hljs-meta{user-select:none;-moz-user-select:none;-webkit-user-select:none;-ms-user-select:none;pointer-events:none}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>multiformats.multihash</code></h1>
</header>
<section id="section-intro">
<p>Implementation of the <a href="https://github.com/multiformats/multihash">multihash spec</a>.</p>
<p>Core functionality is provided by the <code><a title="multiformats.multihash.digest" href="#multiformats.multihash.digest">digest()</a></code>, <code><a title="multiformats.multihash.wrap" href="#multiformats.multihash.wrap">wrap()</a></code>, <code><a title="multiformats.multihash.unwrap" href="#multiformats.multihash.unwrap">unwrap()</a></code> functions,
or the correspondingly-named methods of the <code><a title="multiformats.multihash.Multihash" href="#multiformats.multihash.Multihash">Multihash</a></code> class.
The <code><a title="multiformats.multihash.digest" href="#multiformats.multihash.digest">digest()</a></code> function and <code><a title="multiformats.multihash.Multihash.digest" href="#multiformats.multihash.Multihash.digest">Multihash.digest()</a></code> method can be used to create a multihash digest directly from data:</p>
<pre><code class="language-py">&gt;&gt;&gt; data = b&quot;Hello world!&quot;
&gt;&gt;&gt; digest = multihash.digest(data, &quot;sha2-256&quot;)
&gt;&gt;&gt; digest.hex()
'1220c0535e4be2b79ffd93291305436bf889314e4a3faec05ecffcbb7df31ad9e51a'
</code></pre>
<pre><code class="language-py">&gt;&gt;&gt; sha2_256 = multihash.get(&quot;sha2-256&quot;)
&gt;&gt;&gt; digest = sha2_256.digest(data)
&gt;&gt;&gt; digest.hex()
'1220c0535e4be2b79ffd93291305436bf889314e4a3faec05ecffcbb7df31ad9e51a'
</code></pre>
<p>By default, the full digest produced by the hash function is used.
Optionally, a smaller digest size can be specified to produce truncated hashes:</p>
<pre><code class="language-py">&gt;&gt;&gt; digest = multihash.digest(data, &quot;sha2-256&quot;, size=20)
#        optional truncated hash size, in bytes ^^^^^^^
&gt;&gt;&gt; multihash_digest.hex()
'1214c0535e4be2b79ffd93291305436bf889314e4a3f' # 20-bytes truncated hash
</code></pre>
<p>The <code><a title="multiformats.multihash.unwrap" href="#multiformats.multihash.unwrap">unwrap()</a></code> function can be used to extract the raw digest from a multihash digest:</p>
<pre><code class="language-py">&gt;&gt;&gt; digest.hex()
'1214c0535e4be2b79ffd93291305436bf889314e4a3f'
&gt;&gt;&gt; raw_digest = multihash.unwrap(digest)
&gt;&gt;&gt; raw_digest.hex()
    'c0535e4be2b79ffd93291305436bf889314e4a3f'
</code></pre>
<p>The <code><a title="multiformats.multihash.Multihash.unwrap" href="#multiformats.multihash.Multihash.unwrap">Multihash.unwrap()</a></code> method performs the same functionality, but additionally checks
that the multihash digest is valid for the multihash:</p>
<pre><code class="language-py">&gt;&gt;&gt; raw_digest = sha2_256.unwrap(digest)
&gt;&gt;&gt; raw_digest.hex()
    'c0535e4be2b79ffd93291305436bf889314e4a3f'
</code></pre>
<pre><code class="language-py">&gt;&gt;&gt; sha1 = multihash.get(&quot;sha1&quot;)
&gt;&gt;&gt; (sha2_256.code, sha1.code)
(18, 17)
&gt;&gt;&gt; sha1.unwrap(digest)
err.ValueError: Decoded code 18 differs from multihash code 17.
</code></pre>
<p>The <code><a title="multiformats.multihash.wrap" href="#multiformats.multihash.wrap">wrap()</a></code> function and <code><a title="multiformats.multihash.Multihash.wrap" href="#multiformats.multihash.Multihash.wrap">Multihash.wrap()</a></code> method can be used to wrap a raw digest into a multihash digest:</p>
<pre><code class="language-py">&gt;&gt;&gt; raw_digest.hex()
    'c0535e4be2b79ffd93291305436bf889314e4a3f'
&gt;&gt;&gt; multihash.wrap(raw_digest, &quot;sha2-256&quot;).hex()
'1214c0535e4be2b79ffd93291305436bf889314e4a3f'
</code></pre>
<pre><code class="language-py">&gt;&gt;&gt; sha2_256.wrap(raw_digest).hex()
'1214c0535e4be2b79ffd93291305436bf889314e4a3f'
</code></pre>
<p>Note the both multihash code and digest length are wrapped as varints
(see the <code><a title="multiformats.varint" href="../varint.html">multiformats.varint</a></code> module) and can span multiple bytes:</p>
<pre><code class="language-py">&gt;&gt;&gt; skein1024_1024 = multihash.get(&quot;skein1024-1024&quot;)
&gt;&gt;&gt; skein1024_1024.codec
Multicodec(name='skein1024-1024', tag='multihash', code='0xb3e0',
           status='draft', description='')
&gt;&gt;&gt; skein1024_1024.digest(data).hex()
'e0e702800192e08f5143...' # 3+2+128 = 133 bytes in total
#^^^^^^     3-bytes varint for hash function code 0xb3e0
#      ^^^^ 2-bytes varint for hash digest length 128
&gt;&gt;&gt; from multiformats import varint
&gt;&gt;&gt; hex(varint.decode(bytes.fromhex(&quot;e0e702&quot;)))
'0xb3e0'
&gt;&gt;&gt; varint.decode(bytes.fromhex(&quot;8001&quot;))
128
</code></pre>
<p>Also note that data and digests are all <code>bytes</code> objects, represented here as hex strings for clarity:</p>
<pre><code class="language-py">&gt;&gt;&gt; raw_digest
        b'\xc0S^K\xe2\xb7\x9f\xfd\x93)\x13\x05Ck\xf8\x891NJ?'
&gt;&gt;&gt; digest
b'\x12\x14\xc0S^K\xe2\xb7\x9f\xfd\x93)\x13\x05Ck\xf8\x891NJ?'
# ^^^^^      0x12 -&gt; multihash multicodec &quot;sha2-256&quot;
#      ^^^^^ 0x14 -&gt; truncated hash length of 20 bytes
</code></pre>
<p>The multihash specified by a given multihash digest is accessible using the <code><a title="multiformats.multihash.from_digest" href="#multiformats.multihash.from_digest">from_digest()</a></code> function:</p>
<pre><code class="language-py">&gt;&gt;&gt; multihash.from_digest(digest)
Multihash(codec='sha2-256')
&gt;&gt;&gt; multihash.from_digest(digest).codec
Multicodec(name='sha2-256', tag='multihash', code='0x12',
           status='permanent', description='')
</code></pre>
<p>Additional multihash management functionality is provided by the <code><a title="multiformats.multihash.exists" href="#multiformats.multihash.exists">exists()</a></code> and <code><a title="multiformats.multihash.get" href="#multiformats.multihash.get">get()</a></code> functions,
which can be used to check whether a multihash multicodec with given name or code is known,
and if so to get the corresponding object:</p>
<pre><code class="language-py">&gt;&gt;&gt; multihash.exists(&quot;sha1&quot;)
True
&gt;&gt;&gt; multihash.get(&quot;sha1&quot;)
Multihash(codec='sha1')
&gt;&gt;&gt; multihash.exists(code=0x11)
True
&gt;&gt;&gt; multihash.get(code=0x11)
Multihash(codec='sha1')
</code></pre>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
    Implementation of the [multihash spec](https://github.com/multiformats/multihash).

    Core functionality is provided by the `digest`, `wrap`, `unwrap` functions,
    or the correspondingly-named methods of the `Multihash` class.
    The `digest` function and `Multihash.digest` method can be used to create a multihash digest directly from data:

    ```py
    &gt;&gt;&gt; data = b&#34;Hello world!&#34;
    &gt;&gt;&gt; digest = multihash.digest(data, &#34;sha2-256&#34;)
    &gt;&gt;&gt; digest.hex()
    &#39;1220c0535e4be2b79ffd93291305436bf889314e4a3faec05ecffcbb7df31ad9e51a&#39;
    ```

    ```py
    &gt;&gt;&gt; sha2_256 = multihash.get(&#34;sha2-256&#34;)
    &gt;&gt;&gt; digest = sha2_256.digest(data)
    &gt;&gt;&gt; digest.hex()
    &#39;1220c0535e4be2b79ffd93291305436bf889314e4a3faec05ecffcbb7df31ad9e51a&#39;
    ```

    By default, the full digest produced by the hash function is used.
    Optionally, a smaller digest size can be specified to produce truncated hashes:

    ```py
    &gt;&gt;&gt; digest = multihash.digest(data, &#34;sha2-256&#34;, size=20)
    #        optional truncated hash size, in bytes ^^^^^^^
    &gt;&gt;&gt; multihash_digest.hex()
    &#39;1214c0535e4be2b79ffd93291305436bf889314e4a3f&#39; # 20-bytes truncated hash
    ```

    The `unwrap` function can be used to extract the raw digest from a multihash digest:

    ```py
    &gt;&gt;&gt; digest.hex()
    &#39;1214c0535e4be2b79ffd93291305436bf889314e4a3f&#39;
    &gt;&gt;&gt; raw_digest = multihash.unwrap(digest)
    &gt;&gt;&gt; raw_digest.hex()
        &#39;c0535e4be2b79ffd93291305436bf889314e4a3f&#39;
    ```

    The `Multihash.unwrap` method performs the same functionality, but additionally checks
    that the multihash digest is valid for the multihash:

    ```py
    &gt;&gt;&gt; raw_digest = sha2_256.unwrap(digest)
    &gt;&gt;&gt; raw_digest.hex()
        &#39;c0535e4be2b79ffd93291305436bf889314e4a3f&#39;
    ```

    ```py
    &gt;&gt;&gt; sha1 = multihash.get(&#34;sha1&#34;)
    &gt;&gt;&gt; (sha2_256.code, sha1.code)
    (18, 17)
    &gt;&gt;&gt; sha1.unwrap(digest)
    err.ValueError: Decoded code 18 differs from multihash code 17.
    ```

    The `wrap` function and `Multihash.wrap` method can be used to wrap a raw digest into a multihash digest:

    ```py
    &gt;&gt;&gt; raw_digest.hex()
        &#39;c0535e4be2b79ffd93291305436bf889314e4a3f&#39;
    &gt;&gt;&gt; multihash.wrap(raw_digest, &#34;sha2-256&#34;).hex()
    &#39;1214c0535e4be2b79ffd93291305436bf889314e4a3f&#39;
    ```

    ```py
    &gt;&gt;&gt; sha2_256.wrap(raw_digest).hex()
    &#39;1214c0535e4be2b79ffd93291305436bf889314e4a3f&#39;
    ```

    Note the both multihash code and digest length are wrapped as varints
    (see the `multiformats.varint` module) and can span multiple bytes:

    ```py
    &gt;&gt;&gt; skein1024_1024 = multihash.get(&#34;skein1024-1024&#34;)
    &gt;&gt;&gt; skein1024_1024.codec
    Multicodec(name=&#39;skein1024-1024&#39;, tag=&#39;multihash&#39;, code=&#39;0xb3e0&#39;,
               status=&#39;draft&#39;, description=&#39;&#39;)
    &gt;&gt;&gt; skein1024_1024.digest(data).hex()
    &#39;e0e702800192e08f5143...&#39; # 3+2+128 = 133 bytes in total
    #^^^^^^     3-bytes varint for hash function code 0xb3e0
    #      ^^^^ 2-bytes varint for hash digest length 128
    &gt;&gt;&gt; from multiformats import varint
    &gt;&gt;&gt; hex(varint.decode(bytes.fromhex(&#34;e0e702&#34;)))
    &#39;0xb3e0&#39;
    &gt;&gt;&gt; varint.decode(bytes.fromhex(&#34;8001&#34;))
    128
    ```

    Also note that data and digests are all `bytes` objects, represented here as hex strings for clarity:

    ```py
    &gt;&gt;&gt; raw_digest
            b&#39;\\xc0S^K\\xe2\\xb7\\x9f\\xfd\\x93)\\x13\\x05Ck\\xf8\\x891NJ?&#39;
    &gt;&gt;&gt; digest
    b&#39;\\x12\\x14\\xc0S^K\\xe2\\xb7\\x9f\\xfd\\x93)\\x13\\x05Ck\\xf8\\x891NJ?&#39;
    # ^^^^^      0x12 -&gt; multihash multicodec &#34;sha2-256&#34;
    #      ^^^^^ 0x14 -&gt; truncated hash length of 20 bytes
    ```

    The multihash specified by a given multihash digest is accessible using the `from_digest` function:

    ```py
    &gt;&gt;&gt; multihash.from_digest(digest)
    Multihash(codec=&#39;sha2-256&#39;)
    &gt;&gt;&gt; multihash.from_digest(digest).codec
    Multicodec(name=&#39;sha2-256&#39;, tag=&#39;multihash&#39;, code=&#39;0x12&#39;,
               status=&#39;permanent&#39;, description=&#39;&#39;)
    ```

    Additional multihash management functionality is provided by the `exists` and `get` functions,
    which can be used to check whether a multihash multicodec with given name or code is known,
    and if so to get the corresponding object:

    ```py
    &gt;&gt;&gt; multihash.exists(&#34;sha1&#34;)
    True
    &gt;&gt;&gt; multihash.get(&#34;sha1&#34;)
    Multihash(codec=&#39;sha1&#39;)
    &gt;&gt;&gt; multihash.exists(code=0x11)
    True
    &gt;&gt;&gt; multihash.get(code=0x11)
    Multihash(codec=&#39;sha1&#39;)
    ```

&#34;&#34;&#34;

from io import BytesIO, BufferedIOBase
from typing import AbstractSet, Any, cast, ClassVar, Dict, Iterator, Mapping, Optional, overload, Union, Sequence, Tuple, Type, TypeVar
from weakref import WeakValueDictionary
import sys
from typing_extensions import Literal
from typing_validation import validate

from multiformats import multicodec, varint
from multiformats.multicodec import Multicodec, _hexcode
from multiformats.varint import BytesLike

from . import raw, err
from .raw import Hashfun, MultihashImpl

class Multihash:
    &#34;&#34;&#34;
        Container class for a multibase encoding.

        Example usage:

        ```py
        &gt;&gt;&gt; sha2_256 = multihash.get(&#34;sha2-256&#34;)
        &gt;&gt;&gt; sha2_256
        Multihash(codec=&#39;sha2-256&#39;)
        ```
    &#34;&#34;&#34;

    # WeakValueDictionary[str, Multihash]
    _cache: ClassVar[WeakValueDictionary] = WeakValueDictionary() # type: ignore

    _codec: Multicodec
    _implementation: MultihashImpl

    __slots__ = (&#34;__weakref__&#34;, &#34;_codec&#34;, &#34;_implementation&#34;)

    def __new__(cls, *, codec: Union[str, int, Multicodec]) -&gt; &#34;Multihash&#34;:
        # check that the codec exists:
        if isinstance(codec, str):
            codec = multicodec.get(codec)
        elif isinstance(codec, int):
            codec = multicodec.get(code=codec)
        else:
            validate(codec, Multicodec)
            existing_codec = multicodec.get(codec.name)
            if existing_codec != codec:
                raise err.ValueError(f&#34;Multicodec named {repr(codec.name)} exists, but is not the one given.&#34;)
            codec = existing_codec
        # check that the codec is a multihash multicodec:
        if codec.tag != &#34;multihash&#34;:
            raise err.ValueError(f&#34;Multicodec named {repr(codec.name)} exists, but is not a multihash.&#34;)
        implementation: MultihashImpl = raw.get(codec.name)
        _cache = Multihash._cache
        if codec.name in _cache:
            # if a multihash instance with this name is already registered
            instance: Multihash = _cache[codec.name]
            if instance.codec == codec and instance._implementation == implementation:
                # nothing changed, can use the existing instance
                return instance
            # otherwise remove the existing instance
            del _cache[codec.name]
        # create a fresh instance, register it and return it
        instance = super().__new__(cls)
        instance._codec = codec
        instance._implementation = implementation
        _cache[codec.name] = instance
        return instance

    @property
    def name(self) -&gt; str:
        &#34;&#34;&#34;
            Multihash multicodec name.

            Example usage:

            ```py
            &gt;&gt;&gt; sha2_256.name
            &#39;sha2-256&#39;
            ```
        &#34;&#34;&#34;
        return self.codec.name

    @property
    def code(self) -&gt; int:
        &#34;&#34;&#34;
            Multihash multicodec code.

            Example usage:

            ```py
            &gt;&gt;&gt; sha2_256.code
            18
            # 18 = 0x12
            ```
        &#34;&#34;&#34;
        return self.codec.code

    @property
    def codec(self) -&gt; Multicodec:
        &#34;&#34;&#34;
            The multicodec for this multihash.

            Example usage:

            ```py
            &gt;&gt;&gt; sha2_256.codec
            Multicodec(name=&#39;sha2-256&#39;, tag=&#39;multihash&#39;, code=&#39;0x12&#39;,
                       status=&#39;permanent&#39;, description=&#39;&#39;)
            ```
        &#34;&#34;&#34;
        return self._codec

    @property
    def max_digest_size(self) -&gt; Optional[int]:
        &#34;&#34;&#34;
            The maximum size (in bytes) for raw digests of this multihash,
            or `None` if there is no maximum size.
            Used to sense-check the wrapped/unwrapped raw digests.

            Example usage:

            ```py
            &gt;&gt;&gt; sha2_256.max_digest_size
            32
            # 32 bytes = 256 bits
            ```
        &#34;&#34;&#34;
        _, max_digest_size = self.implementation
        return max_digest_size

    @property
    def implementation(self) -&gt;MultihashImpl:
        &#34;&#34;&#34;
            Returns the implementation of a multihash multicodec, as a pair:

            ```py
            hash_function, max_digest_size = multihash.implementation(&#34;sha2-256&#34;)
            ```

            Above, `codec` is the `multiformats.multicodec.Multicodec` object carrying information about the
            multihash multicodec, `hash_function` is the function `bytes-&gt;bytes` computing the raw hashes,
            and `max_digest_size` is the max size of the digests produced by `hash_function` (or `None` if
            there is no max size, such as in the case of the &#39;identity&#39; multihash multicodec).

            Example usage:

            ```py
            &gt;&gt;&gt; sha2_256.implementation
            (&lt;function _hashlib_sha.&lt;locals&gt;.hashfun at 0x0000029396E22280&gt;, 32)
            ```
        &#34;&#34;&#34;
        return self._implementation
        # hash_function, max_digest_size = raw.get(self.name)
        # return hash_function, max_digest_size

    def wrap(self, raw_digest: BytesLike) -&gt; bytes:
        &#34;&#34;&#34;
            Wraps a raw digest into a multihash digest:

            ```
            &lt;raw digest&gt; -&gt; &lt;code&gt;&lt;size&gt;&lt;raw digest&gt;
            ```

            Example usage:

            ```py
            &gt;&gt;&gt; sha2_256 = multihash.get(&#34;sha2-256&#34;)
            &gt;&gt;&gt; raw_digest = bytes.fromhex(
            ... &#34;c0535e4be2b79ffd93291305436bf889314e4a3f&#34;)
            &gt;&gt;&gt; sha2_256.wrap(raw_digest).hex()
            &#34;1214c0535e4be2b79ffd93291305436bf889314e4a3f&#34;
            ```

            See `wrap` for more information.
        &#34;&#34;&#34;
        validate(raw_digest, BytesLike)
        _, max_digest_size = self.implementation
        size = len(raw_digest)
        if max_digest_size is not None and size &gt; max_digest_size:
            raise err.ValueError(f&#34;Digest size {max_digest_size} is listed for {self.name}, &#34;
                             f&#34;but a digest of larger size {size} was given to be wrapped.&#34;)
        return self.codec.wrap(varint.encode(size)+raw_digest)

    def digest(self, data: BytesLike, *, size: Optional[int] = None) -&gt; bytes:
        &#34;&#34;&#34;
            Computes the raw digest of the given data and wraps it into a multihash digest.
            The optional keyword argument `size` can be used to truncate the
            raw digest to be of the given size (or less) before encoding.

            Example usage:

            ```py
            &gt;&gt;&gt; sha2_256 = multihash.get(&#34;sha2-256&#34;)
            &gt;&gt;&gt; data = b&#34;Hello world!&#34;
            &gt;&gt;&gt; data.hex()
            &#34;48656c6c6f20776f726c6421&#34;
            &gt;&gt;&gt; sha2_256.digest(data).hex() # full 32-bytes hash
            &#39;1220c0535e4be2b79ffd93291305436bf889314e4a3faec05ecffcbb7df31ad9e51a&#39;
            &gt;&gt;&gt; sha2_256.digest(data, size=20).hex() # truncated hash
            &#39;1214c0535e4be2b79ffd93291305436bf889314e4a3f&#39;
            ```

            See `digest` for more information.
        &#34;&#34;&#34;
        hf, _ = self.implementation
        raw_digest = hf(data)
        if size is not None:
            raw_digest = raw_digest[:size] # truncate digest
        size = len(raw_digest)
        return self.codec.wrap(varint.encode(size)+raw_digest)

    def unwrap(self, digest: Union[BytesLike, BufferedIOBase]) -&gt; bytes:
        &#34;&#34;&#34;
            Unwraps a multihash digest into a hash digest:

            ```
            &lt;code&gt;&lt;size&gt;&lt;raw digest&gt; -&gt; &lt;raw digest&gt;
            ```

            If `digest` is one of bytes, bytearray or memoryview, the method also checks
            that the actual hash digest size matches the size listed by the multihash digest.

            Example usage:

            ```py
            &gt;&gt;&gt; sha2_256 = multihash.get(&#34;sha2-256&#34;)
            &gt;&gt;&gt; digest = bytes.fromhex(
            ... &#34;1214c0535e4be2b79ffd93291305436bf889314e4a3f&#34;)
            &gt;&gt;&gt; sha2_256.unwrap(digest).hex()
            &#39;c0535e4be2b79ffd93291305436bf889314e4a3f&#39;
            ```

        &#34;&#34;&#34;
        code, raw_digest = unwrap_raw(digest)
        if code != self.code:
            raise err.ValueError(f&#34;Decoded code {code} differs from multihash code {self.code}.&#34;)
        _validate_raw_digest_size(self.name, raw_digest, self.max_digest_size)
        return raw_digest

    def __str__(self) -&gt; str:
        return f&#34;multihash.get({repr(self.name)})&#34;

    def __repr__(self) -&gt; str:
        return f&#34;Multihash(codec={repr(self.name)})&#34;

    @property
    def _as_tuple(self) -&gt; Tuple[Type[&#34;Multihash&#34;], Multicodec]:
        return (Multihash, self.codec)

    def __hash__(self) -&gt; int:
        return hash(self._as_tuple)

    def __eq__(self, other: Any) -&gt; bool:
        if self is other:
            return True
        if not isinstance(other, Multihash):
            return NotImplemented
        return self._as_tuple == other._as_tuple


def get(name: Optional[str] = None, *, code: Optional[int] = None) -&gt; Multihash:
    &#34;&#34;&#34;
        Gets the multihash multicodec with given name or code.
        Raises `err.KeyError` if the multihash does not exist or is not implemented.
        Exactly one of `name` and `code` must be specified.

        Example usage:

        ```py
        &gt;&gt;&gt; multihash.get(&#34;sha1&#34;)
        Multihash(codec=&#39;sha1&#39;)
        &gt;&gt;&gt; multihash.get(code=0x11)
        Multihash(codec=&#39;sha1&#39;)
        ```

    &#34;&#34;&#34;
    if name is not None and code is not None:
        raise err.ValueError(&#34;Must specify at most one between &#39;name&#39; and &#39;code&#39;.&#34;)
    if name is not None:
        return Multihash(codec=name)
    if code is not None:
        return Multihash(codec=code)
    raise err.ValueError(&#34;Must specify at least one between &#39;name&#39; and &#39;code&#39;.&#34;)


def exists(name: Optional[str] = None, *, code: Optional[int] = None) -&gt; bool:
    &#34;&#34;&#34;
        Checks whether a multihash multicodec with the given name or code exists.
        Exactly one of `name` and `code` must be specified.
        This function returns `False` if a multicodec by given name or code exists,
        but is not tagged &#39;multihash&#39;.

        Example usage:

        ```py
        &gt;&gt;&gt; multihash.exists(&#34;sha1&#34;)
        True
        &gt;&gt;&gt; multihash.exists(code=0x11)
        True
        &gt;&gt;&gt; from multiformats import multicodec
        &gt;&gt;&gt; multicodec.get(&#34;cidv1&#34;)
        Multicodec(name=&#39;cidv1&#39;, tag=&#39;cid&#39;, code=&#39;0x01&#39;,
                   status=&#39;permanent&#39;, description=&#39;CIDv1&#39;)
        &gt;&gt;&gt; multihash.exists(&#34;cidv1&#34;)
        False
        ```

    &#34;&#34;&#34;
    if not multicodec.exists(name, code=code):
        return False
    multihash = multicodec.get(name, code=code)
    return multihash.tag == &#34;multihash&#34;


def is_implemented(name: Optional[str] = None, *, code: Optional[int] = None) -&gt; bool:
    &#34;&#34;&#34;
        Checks whether a multihash with the given name or code exists and is implemented.
        Exactly one of `name` and `code` must be specified.

        Example usage:

        ```py
        &gt;&gt;&gt; multihash.is_implemented(&#34;sha1&#34;)
        True
        &gt;&gt;&gt; multihash.is_implemented(code=0x11)
        True
        ```
    &#34;&#34;&#34;
    if not exists(name, code=code):
        return False
    multihash = multicodec.get(name, code=code)
    return raw.exists(multihash.name)


def from_digest(multihash_digest: BytesLike) -&gt; Multihash:
    &#34;&#34;&#34;
        Returns the multihash multicodec for the given digest,
        according to the code specified by its prefix.
        Raises `err.KeyError` if no multihash exists with that code.

        Example usage:

        ```py
        &gt;&gt;&gt; multihash_digest = bytes.fromhex(&#34;140a9a7a8207a57d03e9c524&#34;)
        &gt;&gt;&gt; multihash.from_digest(multihash_digest)
        Multihash(codec=&#39;sha3-512&#39;)
        ```

    &#34;&#34;&#34;
    code, _, _ = multicodec.unwrap_raw(multihash_digest)
    return get(code=code)


def wrap(raw_digest: BytesLike, multihash: Union[str, int, Multihash]) -&gt; bytes:
    &#34;&#34;&#34;
        Wraps a raw digest into a multihash digest using the given multihash:

        ```
        &lt;raw digest&gt; -&gt; &lt;code&gt;&lt;size&gt;&lt;raw digest&gt;
        ```

        If the multihash is passed by name or code, the `get` function is used to retrieve it.

        Example usage:

        ```py
        &gt;&gt;&gt; multihash.get(&#34;sha2-256&#34;).codec
        Multicodec(name=&#39;sha2-256&#39;, tag=&#39;multihash&#39;, code=&#39;0x12&#39;,
                   status=&#39;permanent&#39;, description=&#39;&#39;)
        &gt;&gt;&gt; raw_digest = bytes.fromhex(&#34;c0535e4be2b79ffd93291305436bf889314e4a3f&#34;)
        &gt;&gt;&gt; len(raw_digest)
        20
        &gt;&gt;&gt; multihash.wrap(raw_digest, &#34;sha2-256&#34;).hex()
        &#34;1214c0535e4be2b79ffd93291305436bf889314e4a3f&#34;
        #^^   code 0x12 for multihash multicodec &#34;sha2-256&#34;
        #  ^^ truncated hash length 0x14 = 20 bytes
        ```

        Note that all digests are `bytes` objects, represented here as hex strings for clarity:

        ```py
        &gt;&gt;&gt; hash_digest
        b&#39;\\xc0S^K\\xe2\\xb7\\x9f\\xfd\\x93)\\x13\\x05Ck\\xf8\\x891NJ?&#39;
        &gt;&gt;&gt; multihash.wrap(raw_digest, &#34;sha2-256&#34;)
        b&#39;\\x12\\x14\\xc0S^K\\xe2\\xb7\\x9f\\xfd\\x93)\\x13\\x05Ck\\xf8\\x891NJ?&#39;
        # ^^^^     0x12 -&gt; multihash multicodec &#34;sha2-256&#34;
        #     ^^^^ 0x14 -&gt; truncated hash length of 20 bytes
        ```

    &#34;&#34;&#34;
    if not isinstance(multihash, Multihash):
        multihash = Multihash(codec=multihash)
    return multihash.wrap(raw_digest)


def digest(data: BytesLike, multihash: Union[str, int, Multihash], *, size: Optional[int] = None) -&gt; bytes:
    &#34;&#34;&#34;
        Computes the raw digest of the given data and wraps it into a multihash digest.
        The optional keyword argument `size` can be used to truncate the
        raw digest to be of the given size (or less) before encoding.

        Example usage:

        ```py
        &gt;&gt;&gt; data = b&#34;Hello world!&#34;
        &gt;&gt;&gt; data.hex()
        &#34;48656c6c6f20776f726c6421&#34;
        &gt;&gt;&gt; multihash.digest(data, &#34;sha2-256&#34;).hex() # full 32-bytes hash
        &#39;1220c0535e4be2b79ffd93291305436bf889314e4a3faec05ecffcbb7df31ad9e51a&#39;
        &gt;&gt;&gt; multihash.digest(data, &#34;sha2-256&#34;, size=20).hex()
        #         optional truncated hash size ^^^^^^^
        &#39;1214c0535e4be2b79ffd93291305436bf889314e4a3f&#39;
        #^^   code 0x12 for multihash multicodec &#34;sha2-256&#34;
        #  ^^ truncated hash length 0x14 = 20 bytes
        ```

        Note both multihash code and digest length are wrapped as varints
        (see the `multiformats.varint` module) and can span multiple bytes:

        ```py
        &gt;&gt;&gt; multihash.get(&#34;skein1024-1024&#34;)
        Multicodec(name=&#39;skein1024-1024&#39;, tag=&#39;multihash&#39;, code=&#39;0xb3e0&#39;,
                   status=&#39;draft&#39;, description=&#39;&#39;)
        &gt;&gt;&gt; multihash.digest(data, &#34;skein1024-1024&#34;).hex()
        &#39;e0e702800192e08f5143 ... 3+2+128 = 133 bytes in total
        #^^^^^^     3-bytes varint for hash function code 0xb3e0
        #      ^^^^ 2-bytes varint for hash digest length 128
        &gt;&gt;&gt; from multiformats import varint
        &gt;&gt;&gt; hex(varint.decode(bytes.fromhex(&#34;e0e702&#34;)))
        &#39;0xb3e0&#39;
        &gt;&gt;&gt; varint.decode(bytes.fromhex(&#34;8001&#34;))
        128
        ```

    &#34;&#34;&#34;
    if not isinstance(multihash, Multihash):
        multihash = Multihash(codec=multihash)
    return multihash.digest(data, size=size)


def _validate_raw_digest_size(name: str, raw_digest: bytes, max_digest_size: Optional[int]) -&gt; None:
    if max_digest_size is not None and len(raw_digest) &gt; max_digest_size:
        raise err.ValueError(f&#34;Multihash {name} has max digest size {max_digest_size}, &#34;
                         f&#34;but a digest of larger size {len(raw_digest)} was unwrapped instead.&#34;)


def unwrap(digest: Union[BytesLike, BufferedIOBase],
           multihash: Union[None, str, int, Multihash]=None) -&gt; bytes:
    &#34;&#34;&#34;
        Unwraps a multihash digest into a raw digest:

        ```
        &lt;code&gt;&lt;size&gt;&lt;raw digest&gt; -&gt; &lt;raw digest&gt;
        ```

        If `digest` is one of `bytes`, `bytearray` or `memoryview`, the method also checks
        that the actual raw digest size matches the size listed in the multihash digest.
        If `digest` is a stream (an instance of `BufferedIOBase`, specifically), then the
        number of bytes consumed to produce the raw digest matches the size lised in the multihash digest,
        and no further bytes are consumed from the stream.

        If `multihash` is not `None`, the function additionally enforces that the code from the
        multihash digest matches the code of the multihash (calls `Multihash.unwrap` under the hood to do so).
        Regardless, the function checks that the multihash with code specified by the multihash digest exists
        and is implemented.

        Example usage:

        ```py
        &gt;&gt;&gt; digest = bytes.fromhex(
        ... &#34;1214c0535e4be2b79ffd93291305436bf889314e4a3f&#34;)
        &gt;&gt;&gt; multihash.unwrap(digest, &#34;sha2-256&#34;).hex()
        &#39;c0535e4be2b79ffd93291305436bf889314e4a3f&#39;
        ```
    &#34;&#34;&#34;
    if multihash is not None:
        if not isinstance(multihash, Multihash):
            multihash = Multihash(codec=multihash)
        return multihash.unwrap(digest)
    code, raw_digest = unwrap_raw(digest)
    multihash = Multihash(codec=code)
    _validate_raw_digest_size(multihash.name, raw_digest, multihash.max_digest_size)
    return raw_digest


_BufferedIOT = TypeVar(&#34;_BufferedIOT&#34;, bound=BufferedIOBase)

@overload
def unwrap_raw(multihash_digest: BufferedIOBase) -&gt; Tuple[int, bytes]:
    ...

@overload
def unwrap_raw(multihash_digest: BytesLike) -&gt; Tuple[int, memoryview]:
    ...

def unwrap_raw(multihash_digest: Union[BytesLike, BufferedIOBase]) -&gt; Tuple[int, Union[bytes, memoryview]]:
    &#34;&#34;&#34;
        Unwraps a multihash digest into a code and raw digest pair:

        ```
        &lt;code&gt;&lt;size&gt;&lt;hash digest&gt; -&gt; (&lt;code&gt;, &lt;hash digest&gt;)
        ```

        The function checks that the multihash codec with code specified by the multihash digest exists,
        but does not check whether it is implemented or not.

        Example usage:

        ```py
        &gt;&gt;&gt; multihash_digest = bytes.fromhex(
        ... &#34;1214c0535e4be2b79ffd93291305436bf889314e4a3f&#34;)
        &gt;&gt;&gt; code, digest = multihash.unwrap_raw(multihash_digest, &#34;sha2-256&#34;)
        &gt;&gt;&gt; code
        18 # the code 0x12 of &#39;sha2-256&#39;
        &gt;&gt;&gt; digest.hex()
        &#39;c0535e4be2b79ffd93291305436bf889314e4a3f&#39;
        ```

    &#34;&#34;&#34;
    # switch between memoryview mode and stream mode
    if isinstance(multihash_digest, BufferedIOBase):
        stream_mode = True
        validate(multihash_digest, BufferedIOBase)
        stream: Union[memoryview, BufferedIOBase] = multihash_digest
    else:
        stream_mode = False
        stream = memoryview(multihash_digest)
    # extract multihash code
    multihash_code, n, stream = multicodec.unwrap_raw(multihash_digest)
    if not exists(code=multihash_code):
        n_bytes_read = f&#34; ({n} bytes read)&#34; if stream_mode else &#34;&#34;
        raise err.KeyError(f&#34;Multicodec {_hexcode(multihash_code)} is not a multihash{n_bytes_read}.&#34;)
    # extract hash digest size
    digest_size, _, stream = varint.decode_raw(stream)
    # extract hash digest
    if stream_mode:
        # use only the number of bytes specified by the multihash
        hash_digest = cast(BufferedIOBase, stream).read(digest_size)
    else:
        # use all remaining bytes
        hash_digest = cast(memoryview, stream)
    # check that the hash digest size is valid
    if digest_size != len(hash_digest):
        raise err.ValueError(f&#34;Multihash digest lists size {digest_size}, but the hash digest has size {len(hash_digest)} instead.&#34;)
    return multihash_code, hash_digest</code></pre>
</details>
</section>
<section>
<h2 class="section-title" id="header-submodules">Sub-modules</h2>
<dl>
<dt><code class="name"><a title="multiformats.multihash.err" href="err.html">multiformats.multihash.err</a></code></dt>
<dd>
<div class="desc"><p>Errors for the <code><a title="multiformats.multihash" href="#multiformats.multihash">multiformats.multihash</a></code> module.</p></div>
</dd>
<dt><code class="name"><a title="multiformats.multihash.raw" href="raw.html">multiformats.multihash.raw</a></code></dt>
<dd>
<div class="desc"><p>Implementation of raw hash functions used by multihash multicodecs â€¦</p></div>
</dd>
</dl>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="multiformats.multihash.digest"><code class="name flex">
<span>def <span class="ident">digest</span></span>(<span>data:Â Union[bytes,Â bytearray,Â memoryview], multihash:Â Union[str,Â int,Â <a title="multiformats.multihash.Multihash" href="#multiformats.multihash.Multihash">Multihash</a>], *, size:Â Optional[None]Â =Â None) â€‘>Â bytes</span>
</code></dt>
<dd>
<div class="desc"><p>Computes the raw digest of the given data and wraps it into a multihash digest.
The optional keyword argument <code>size</code> can be used to truncate the
raw digest to be of the given size (or less) before encoding.</p>
<p>Example usage:</p>
<pre><code class="language-py">&gt;&gt;&gt; data = b&quot;Hello world!&quot;
&gt;&gt;&gt; data.hex()
&quot;48656c6c6f20776f726c6421&quot;
&gt;&gt;&gt; multihash.digest(data, &quot;sha2-256&quot;).hex() # full 32-bytes hash
'1220c0535e4be2b79ffd93291305436bf889314e4a3faec05ecffcbb7df31ad9e51a'
&gt;&gt;&gt; multihash.digest(data, &quot;sha2-256&quot;, size=20).hex()
#         optional truncated hash size ^^^^^^^
'1214c0535e4be2b79ffd93291305436bf889314e4a3f'
#^^   code 0x12 for multihash multicodec &quot;sha2-256&quot;
#  ^^ truncated hash length 0x14 = 20 bytes
</code></pre>
<p>Note both multihash code and digest length are wrapped as varints
(see the <code><a title="multiformats.varint" href="../varint.html">multiformats.varint</a></code> module) and can span multiple bytes:</p>
<pre><code class="language-py">&gt;&gt;&gt; multihash.get(&quot;skein1024-1024&quot;)
Multicodec(name='skein1024-1024', tag='multihash', code='0xb3e0',
           status='draft', description='')
&gt;&gt;&gt; multihash.digest(data, &quot;skein1024-1024&quot;).hex()
'e0e702800192e08f5143 ... 3+2+128 = 133 bytes in total
#^^^^^^     3-bytes varint for hash function code 0xb3e0
#      ^^^^ 2-bytes varint for hash digest length 128
&gt;&gt;&gt; from multiformats import varint
&gt;&gt;&gt; hex(varint.decode(bytes.fromhex(&quot;e0e702&quot;)))
'0xb3e0'
&gt;&gt;&gt; varint.decode(bytes.fromhex(&quot;8001&quot;))
128
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def digest(data: BytesLike, multihash: Union[str, int, Multihash], *, size: Optional[int] = None) -&gt; bytes:
    &#34;&#34;&#34;
        Computes the raw digest of the given data and wraps it into a multihash digest.
        The optional keyword argument `size` can be used to truncate the
        raw digest to be of the given size (or less) before encoding.

        Example usage:

        ```py
        &gt;&gt;&gt; data = b&#34;Hello world!&#34;
        &gt;&gt;&gt; data.hex()
        &#34;48656c6c6f20776f726c6421&#34;
        &gt;&gt;&gt; multihash.digest(data, &#34;sha2-256&#34;).hex() # full 32-bytes hash
        &#39;1220c0535e4be2b79ffd93291305436bf889314e4a3faec05ecffcbb7df31ad9e51a&#39;
        &gt;&gt;&gt; multihash.digest(data, &#34;sha2-256&#34;, size=20).hex()
        #         optional truncated hash size ^^^^^^^
        &#39;1214c0535e4be2b79ffd93291305436bf889314e4a3f&#39;
        #^^   code 0x12 for multihash multicodec &#34;sha2-256&#34;
        #  ^^ truncated hash length 0x14 = 20 bytes
        ```

        Note both multihash code and digest length are wrapped as varints
        (see the `multiformats.varint` module) and can span multiple bytes:

        ```py
        &gt;&gt;&gt; multihash.get(&#34;skein1024-1024&#34;)
        Multicodec(name=&#39;skein1024-1024&#39;, tag=&#39;multihash&#39;, code=&#39;0xb3e0&#39;,
                   status=&#39;draft&#39;, description=&#39;&#39;)
        &gt;&gt;&gt; multihash.digest(data, &#34;skein1024-1024&#34;).hex()
        &#39;e0e702800192e08f5143 ... 3+2+128 = 133 bytes in total
        #^^^^^^     3-bytes varint for hash function code 0xb3e0
        #      ^^^^ 2-bytes varint for hash digest length 128
        &gt;&gt;&gt; from multiformats import varint
        &gt;&gt;&gt; hex(varint.decode(bytes.fromhex(&#34;e0e702&#34;)))
        &#39;0xb3e0&#39;
        &gt;&gt;&gt; varint.decode(bytes.fromhex(&#34;8001&#34;))
        128
        ```

    &#34;&#34;&#34;
    if not isinstance(multihash, Multihash):
        multihash = Multihash(codec=multihash)
    return multihash.digest(data, size=size)</code></pre>
</details>
</dd>
<dt id="multiformats.multihash.exists"><code class="name flex">
<span>def <span class="ident">exists</span></span>(<span>name:Â Optional[str]Â =Â None, *, code:Â Optional[None]Â =Â None) â€‘>Â bool</span>
</code></dt>
<dd>
<div class="desc"><p>Checks whether a multihash multicodec with the given name or code exists.
Exactly one of <code>name</code> and <code>code</code> must be specified.
This function returns <code>False</code> if a multicodec by given name or code exists,
but is not tagged 'multihash'.</p>
<p>Example usage:</p>
<pre><code class="language-py">&gt;&gt;&gt; multihash.exists(&quot;sha1&quot;)
True
&gt;&gt;&gt; multihash.exists(code=0x11)
True
&gt;&gt;&gt; from multiformats import multicodec
&gt;&gt;&gt; multicodec.get(&quot;cidv1&quot;)
Multicodec(name='cidv1', tag='cid', code='0x01',
           status='permanent', description='CIDv1')
&gt;&gt;&gt; multihash.exists(&quot;cidv1&quot;)
False
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def exists(name: Optional[str] = None, *, code: Optional[int] = None) -&gt; bool:
    &#34;&#34;&#34;
        Checks whether a multihash multicodec with the given name or code exists.
        Exactly one of `name` and `code` must be specified.
        This function returns `False` if a multicodec by given name or code exists,
        but is not tagged &#39;multihash&#39;.

        Example usage:

        ```py
        &gt;&gt;&gt; multihash.exists(&#34;sha1&#34;)
        True
        &gt;&gt;&gt; multihash.exists(code=0x11)
        True
        &gt;&gt;&gt; from multiformats import multicodec
        &gt;&gt;&gt; multicodec.get(&#34;cidv1&#34;)
        Multicodec(name=&#39;cidv1&#39;, tag=&#39;cid&#39;, code=&#39;0x01&#39;,
                   status=&#39;permanent&#39;, description=&#39;CIDv1&#39;)
        &gt;&gt;&gt; multihash.exists(&#34;cidv1&#34;)
        False
        ```

    &#34;&#34;&#34;
    if not multicodec.exists(name, code=code):
        return False
    multihash = multicodec.get(name, code=code)
    return multihash.tag == &#34;multihash&#34;</code></pre>
</details>
</dd>
<dt id="multiformats.multihash.from_digest"><code class="name flex">
<span>def <span class="ident">from_digest</span></span>(<span>multihash_digest:Â Union[bytes,Â bytearray,Â memoryview]) â€‘>Â <a title="multiformats.multihash.Multihash" href="#multiformats.multihash.Multihash">Multihash</a></span>
</code></dt>
<dd>
<div class="desc"><p>Returns the multihash multicodec for the given digest,
according to the code specified by its prefix.
Raises <code><a title="multiformats.multihash.err.KeyError" href="err.html#multiformats.multihash.err.KeyError">KeyError</a></code> if no multihash exists with that code.</p>
<p>Example usage:</p>
<pre><code class="language-py">&gt;&gt;&gt; multihash_digest = bytes.fromhex(&quot;140a9a7a8207a57d03e9c524&quot;)
&gt;&gt;&gt; multihash.from_digest(multihash_digest)
Multihash(codec='sha3-512')
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def from_digest(multihash_digest: BytesLike) -&gt; Multihash:
    &#34;&#34;&#34;
        Returns the multihash multicodec for the given digest,
        according to the code specified by its prefix.
        Raises `err.KeyError` if no multihash exists with that code.

        Example usage:

        ```py
        &gt;&gt;&gt; multihash_digest = bytes.fromhex(&#34;140a9a7a8207a57d03e9c524&#34;)
        &gt;&gt;&gt; multihash.from_digest(multihash_digest)
        Multihash(codec=&#39;sha3-512&#39;)
        ```

    &#34;&#34;&#34;
    code, _, _ = multicodec.unwrap_raw(multihash_digest)
    return get(code=code)</code></pre>
</details>
</dd>
<dt id="multiformats.multihash.get"><code class="name flex">
<span>def <span class="ident">get</span></span>(<span>name:Â Optional[str]Â =Â None, *, code:Â Optional[None]Â =Â None) â€‘>Â <a title="multiformats.multihash.Multihash" href="#multiformats.multihash.Multihash">Multihash</a></span>
</code></dt>
<dd>
<div class="desc"><p>Gets the multihash multicodec with given name or code.
Raises <code><a title="multiformats.multihash.err.KeyError" href="err.html#multiformats.multihash.err.KeyError">KeyError</a></code> if the multihash does not exist or is not implemented.
Exactly one of <code>name</code> and <code>code</code> must be specified.</p>
<p>Example usage:</p>
<pre><code class="language-py">&gt;&gt;&gt; multihash.get(&quot;sha1&quot;)
Multihash(codec='sha1')
&gt;&gt;&gt; multihash.get(code=0x11)
Multihash(codec='sha1')
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get(name: Optional[str] = None, *, code: Optional[int] = None) -&gt; Multihash:
    &#34;&#34;&#34;
        Gets the multihash multicodec with given name or code.
        Raises `err.KeyError` if the multihash does not exist or is not implemented.
        Exactly one of `name` and `code` must be specified.

        Example usage:

        ```py
        &gt;&gt;&gt; multihash.get(&#34;sha1&#34;)
        Multihash(codec=&#39;sha1&#39;)
        &gt;&gt;&gt; multihash.get(code=0x11)
        Multihash(codec=&#39;sha1&#39;)
        ```

    &#34;&#34;&#34;
    if name is not None and code is not None:
        raise err.ValueError(&#34;Must specify at most one between &#39;name&#39; and &#39;code&#39;.&#34;)
    if name is not None:
        return Multihash(codec=name)
    if code is not None:
        return Multihash(codec=code)
    raise err.ValueError(&#34;Must specify at least one between &#39;name&#39; and &#39;code&#39;.&#34;)</code></pre>
</details>
</dd>
<dt id="multiformats.multihash.is_implemented"><code class="name flex">
<span>def <span class="ident">is_implemented</span></span>(<span>name:Â Optional[str]Â =Â None, *, code:Â Optional[None]Â =Â None) â€‘>Â bool</span>
</code></dt>
<dd>
<div class="desc"><p>Checks whether a multihash with the given name or code exists and is implemented.
Exactly one of <code>name</code> and <code>code</code> must be specified.</p>
<p>Example usage:</p>
<pre><code class="language-py">&gt;&gt;&gt; multihash.is_implemented(&quot;sha1&quot;)
True
&gt;&gt;&gt; multihash.is_implemented(code=0x11)
True
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_implemented(name: Optional[str] = None, *, code: Optional[int] = None) -&gt; bool:
    &#34;&#34;&#34;
        Checks whether a multihash with the given name or code exists and is implemented.
        Exactly one of `name` and `code` must be specified.

        Example usage:

        ```py
        &gt;&gt;&gt; multihash.is_implemented(&#34;sha1&#34;)
        True
        &gt;&gt;&gt; multihash.is_implemented(code=0x11)
        True
        ```
    &#34;&#34;&#34;
    if not exists(name, code=code):
        return False
    multihash = multicodec.get(name, code=code)
    return raw.exists(multihash.name)</code></pre>
</details>
</dd>
<dt id="multiformats.multihash.unwrap"><code class="name flex">
<span>def <span class="ident">unwrap</span></span>(<span>digest:Â Union[bytes,Â bytearray,Â memoryview,Â io.BufferedIOBase], multihash:Â Union[ForwardRef(None),Â str,Â int,Â <a title="multiformats.multihash.Multihash" href="#multiformats.multihash.Multihash">Multihash</a>]Â =Â None) â€‘>Â bytes</span>
</code></dt>
<dd>
<div class="desc"><p>Unwraps a multihash digest into a raw digest:</p>
<pre><code>&lt;code&gt;&lt;size&gt;&lt;raw digest&gt; -&gt; &lt;raw digest&gt;
</code></pre>
<p>If <code><a title="multiformats.multihash.digest" href="#multiformats.multihash.digest">digest()</a></code> is one of <code>bytes</code>, <code>bytearray</code> or <code>memoryview</code>, the method also checks
that the actual raw digest size matches the size listed in the multihash digest.
If <code><a title="multiformats.multihash.digest" href="#multiformats.multihash.digest">digest()</a></code> is a stream (an instance of <code>BufferedIOBase</code>, specifically), then the
number of bytes consumed to produce the raw digest matches the size lised in the multihash digest,
and no further bytes are consumed from the stream.</p>
<p>If <code>multihash</code> is not <code>None</code>, the function additionally enforces that the code from the
multihash digest matches the code of the multihash (calls <code><a title="multiformats.multihash.Multihash.unwrap" href="#multiformats.multihash.Multihash.unwrap">Multihash.unwrap()</a></code> under the hood to do so).
Regardless, the function checks that the multihash with code specified by the multihash digest exists
and is implemented.</p>
<p>Example usage:</p>
<pre><code class="language-py">&gt;&gt;&gt; digest = bytes.fromhex(
... &quot;1214c0535e4be2b79ffd93291305436bf889314e4a3f&quot;)
&gt;&gt;&gt; multihash.unwrap(digest, &quot;sha2-256&quot;).hex()
'c0535e4be2b79ffd93291305436bf889314e4a3f'
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def unwrap(digest: Union[BytesLike, BufferedIOBase],
           multihash: Union[None, str, int, Multihash]=None) -&gt; bytes:
    &#34;&#34;&#34;
        Unwraps a multihash digest into a raw digest:

        ```
        &lt;code&gt;&lt;size&gt;&lt;raw digest&gt; -&gt; &lt;raw digest&gt;
        ```

        If `digest` is one of `bytes`, `bytearray` or `memoryview`, the method also checks
        that the actual raw digest size matches the size listed in the multihash digest.
        If `digest` is a stream (an instance of `BufferedIOBase`, specifically), then the
        number of bytes consumed to produce the raw digest matches the size lised in the multihash digest,
        and no further bytes are consumed from the stream.

        If `multihash` is not `None`, the function additionally enforces that the code from the
        multihash digest matches the code of the multihash (calls `Multihash.unwrap` under the hood to do so).
        Regardless, the function checks that the multihash with code specified by the multihash digest exists
        and is implemented.

        Example usage:

        ```py
        &gt;&gt;&gt; digest = bytes.fromhex(
        ... &#34;1214c0535e4be2b79ffd93291305436bf889314e4a3f&#34;)
        &gt;&gt;&gt; multihash.unwrap(digest, &#34;sha2-256&#34;).hex()
        &#39;c0535e4be2b79ffd93291305436bf889314e4a3f&#39;
        ```
    &#34;&#34;&#34;
    if multihash is not None:
        if not isinstance(multihash, Multihash):
            multihash = Multihash(codec=multihash)
        return multihash.unwrap(digest)
    code, raw_digest = unwrap_raw(digest)
    multihash = Multihash(codec=code)
    _validate_raw_digest_size(multihash.name, raw_digest, multihash.max_digest_size)
    return raw_digest</code></pre>
</details>
</dd>
<dt id="multiformats.multihash.unwrap_raw"><code class="name flex">
<span>def <span class="ident">unwrap_raw</span></span>(<span>multihash_digest:Â Union[bytes,Â bytearray,Â memoryview,Â io.BufferedIOBase]) â€‘>Â Tuple[int,Â Union[bytes,Â memoryview]]</span>
</code></dt>
<dd>
<div class="desc"><p>Unwraps a multihash digest into a code and raw digest pair:</p>
<pre><code>&lt;code&gt;&lt;size&gt;&lt;hash digest&gt; -&gt; (&lt;code&gt;, &lt;hash digest&gt;)
</code></pre>
<p>The function checks that the multihash codec with code specified by the multihash digest exists,
but does not check whether it is implemented or not.</p>
<p>Example usage:</p>
<pre><code class="language-py">&gt;&gt;&gt; multihash_digest = bytes.fromhex(
... &quot;1214c0535e4be2b79ffd93291305436bf889314e4a3f&quot;)
&gt;&gt;&gt; code, digest = multihash.unwrap_raw(multihash_digest, &quot;sha2-256&quot;)
&gt;&gt;&gt; code
18 # the code 0x12 of 'sha2-256'
&gt;&gt;&gt; digest.hex()
'c0535e4be2b79ffd93291305436bf889314e4a3f'
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def unwrap_raw(multihash_digest: Union[BytesLike, BufferedIOBase]) -&gt; Tuple[int, Union[bytes, memoryview]]:
    &#34;&#34;&#34;
        Unwraps a multihash digest into a code and raw digest pair:

        ```
        &lt;code&gt;&lt;size&gt;&lt;hash digest&gt; -&gt; (&lt;code&gt;, &lt;hash digest&gt;)
        ```

        The function checks that the multihash codec with code specified by the multihash digest exists,
        but does not check whether it is implemented or not.

        Example usage:

        ```py
        &gt;&gt;&gt; multihash_digest = bytes.fromhex(
        ... &#34;1214c0535e4be2b79ffd93291305436bf889314e4a3f&#34;)
        &gt;&gt;&gt; code, digest = multihash.unwrap_raw(multihash_digest, &#34;sha2-256&#34;)
        &gt;&gt;&gt; code
        18 # the code 0x12 of &#39;sha2-256&#39;
        &gt;&gt;&gt; digest.hex()
        &#39;c0535e4be2b79ffd93291305436bf889314e4a3f&#39;
        ```

    &#34;&#34;&#34;
    # switch between memoryview mode and stream mode
    if isinstance(multihash_digest, BufferedIOBase):
        stream_mode = True
        validate(multihash_digest, BufferedIOBase)
        stream: Union[memoryview, BufferedIOBase] = multihash_digest
    else:
        stream_mode = False
        stream = memoryview(multihash_digest)
    # extract multihash code
    multihash_code, n, stream = multicodec.unwrap_raw(multihash_digest)
    if not exists(code=multihash_code):
        n_bytes_read = f&#34; ({n} bytes read)&#34; if stream_mode else &#34;&#34;
        raise err.KeyError(f&#34;Multicodec {_hexcode(multihash_code)} is not a multihash{n_bytes_read}.&#34;)
    # extract hash digest size
    digest_size, _, stream = varint.decode_raw(stream)
    # extract hash digest
    if stream_mode:
        # use only the number of bytes specified by the multihash
        hash_digest = cast(BufferedIOBase, stream).read(digest_size)
    else:
        # use all remaining bytes
        hash_digest = cast(memoryview, stream)
    # check that the hash digest size is valid
    if digest_size != len(hash_digest):
        raise err.ValueError(f&#34;Multihash digest lists size {digest_size}, but the hash digest has size {len(hash_digest)} instead.&#34;)
    return multihash_code, hash_digest</code></pre>
</details>
</dd>
<dt id="multiformats.multihash.wrap"><code class="name flex">
<span>def <span class="ident">wrap</span></span>(<span>raw_digest:Â Union[bytes,Â bytearray,Â memoryview], multihash:Â Union[str,Â int,Â <a title="multiformats.multihash.Multihash" href="#multiformats.multihash.Multihash">Multihash</a>]) â€‘>Â bytes</span>
</code></dt>
<dd>
<div class="desc"><p>Wraps a raw digest into a multihash digest using the given multihash:</p>
<pre><code>&lt;raw digest&gt; -&gt; &lt;code&gt;&lt;size&gt;&lt;raw digest&gt;
</code></pre>
<p>If the multihash is passed by name or code, the <code><a title="multiformats.multihash.get" href="#multiformats.multihash.get">get()</a></code> function is used to retrieve it.</p>
<p>Example usage:</p>
<pre><code class="language-py">&gt;&gt;&gt; multihash.get(&quot;sha2-256&quot;).codec
Multicodec(name='sha2-256', tag='multihash', code='0x12',
           status='permanent', description='')
&gt;&gt;&gt; raw_digest = bytes.fromhex(&quot;c0535e4be2b79ffd93291305436bf889314e4a3f&quot;)
&gt;&gt;&gt; len(raw_digest)
20
&gt;&gt;&gt; multihash.wrap(raw_digest, &quot;sha2-256&quot;).hex()
&quot;1214c0535e4be2b79ffd93291305436bf889314e4a3f&quot;
#^^   code 0x12 for multihash multicodec &quot;sha2-256&quot;
#  ^^ truncated hash length 0x14 = 20 bytes
</code></pre>
<p>Note that all digests are <code>bytes</code> objects, represented here as hex strings for clarity:</p>
<pre><code class="language-py">&gt;&gt;&gt; hash_digest
b'\xc0S^K\xe2\xb7\x9f\xfd\x93)\x13\x05Ck\xf8\x891NJ?'
&gt;&gt;&gt; multihash.wrap(raw_digest, &quot;sha2-256&quot;)
b'\x12\x14\xc0S^K\xe2\xb7\x9f\xfd\x93)\x13\x05Ck\xf8\x891NJ?'
# ^^^^     0x12 -&gt; multihash multicodec &quot;sha2-256&quot;
#     ^^^^ 0x14 -&gt; truncated hash length of 20 bytes
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def wrap(raw_digest: BytesLike, multihash: Union[str, int, Multihash]) -&gt; bytes:
    &#34;&#34;&#34;
        Wraps a raw digest into a multihash digest using the given multihash:

        ```
        &lt;raw digest&gt; -&gt; &lt;code&gt;&lt;size&gt;&lt;raw digest&gt;
        ```

        If the multihash is passed by name or code, the `get` function is used to retrieve it.

        Example usage:

        ```py
        &gt;&gt;&gt; multihash.get(&#34;sha2-256&#34;).codec
        Multicodec(name=&#39;sha2-256&#39;, tag=&#39;multihash&#39;, code=&#39;0x12&#39;,
                   status=&#39;permanent&#39;, description=&#39;&#39;)
        &gt;&gt;&gt; raw_digest = bytes.fromhex(&#34;c0535e4be2b79ffd93291305436bf889314e4a3f&#34;)
        &gt;&gt;&gt; len(raw_digest)
        20
        &gt;&gt;&gt; multihash.wrap(raw_digest, &#34;sha2-256&#34;).hex()
        &#34;1214c0535e4be2b79ffd93291305436bf889314e4a3f&#34;
        #^^   code 0x12 for multihash multicodec &#34;sha2-256&#34;
        #  ^^ truncated hash length 0x14 = 20 bytes
        ```

        Note that all digests are `bytes` objects, represented here as hex strings for clarity:

        ```py
        &gt;&gt;&gt; hash_digest
        b&#39;\\xc0S^K\\xe2\\xb7\\x9f\\xfd\\x93)\\x13\\x05Ck\\xf8\\x891NJ?&#39;
        &gt;&gt;&gt; multihash.wrap(raw_digest, &#34;sha2-256&#34;)
        b&#39;\\x12\\x14\\xc0S^K\\xe2\\xb7\\x9f\\xfd\\x93)\\x13\\x05Ck\\xf8\\x891NJ?&#39;
        # ^^^^     0x12 -&gt; multihash multicodec &#34;sha2-256&#34;
        #     ^^^^ 0x14 -&gt; truncated hash length of 20 bytes
        ```

    &#34;&#34;&#34;
    if not isinstance(multihash, Multihash):
        multihash = Multihash(codec=multihash)
    return multihash.wrap(raw_digest)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="multiformats.multihash.Multihash"><code class="flex name class">
<span>class <span class="ident">Multihash</span></span>
<span>(</span><span>*, codec:Â Union[str,Â int,Â <a title="multiformats.multicodec.Multicodec" href="../multicodec/index.html#multiformats.multicodec.Multicodec">Multicodec</a>])</span>
</code></dt>
<dd>
<div class="desc"><p>Container class for a multibase encoding.</p>
<p>Example usage:</p>
<pre><code class="language-py">&gt;&gt;&gt; sha2_256 = multihash.get(&quot;sha2-256&quot;)
&gt;&gt;&gt; sha2_256
Multihash(codec='sha2-256')
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Multihash:
    &#34;&#34;&#34;
        Container class for a multibase encoding.

        Example usage:

        ```py
        &gt;&gt;&gt; sha2_256 = multihash.get(&#34;sha2-256&#34;)
        &gt;&gt;&gt; sha2_256
        Multihash(codec=&#39;sha2-256&#39;)
        ```
    &#34;&#34;&#34;

    # WeakValueDictionary[str, Multihash]
    _cache: ClassVar[WeakValueDictionary] = WeakValueDictionary() # type: ignore

    _codec: Multicodec
    _implementation: MultihashImpl

    __slots__ = (&#34;__weakref__&#34;, &#34;_codec&#34;, &#34;_implementation&#34;)

    def __new__(cls, *, codec: Union[str, int, Multicodec]) -&gt; &#34;Multihash&#34;:
        # check that the codec exists:
        if isinstance(codec, str):
            codec = multicodec.get(codec)
        elif isinstance(codec, int):
            codec = multicodec.get(code=codec)
        else:
            validate(codec, Multicodec)
            existing_codec = multicodec.get(codec.name)
            if existing_codec != codec:
                raise err.ValueError(f&#34;Multicodec named {repr(codec.name)} exists, but is not the one given.&#34;)
            codec = existing_codec
        # check that the codec is a multihash multicodec:
        if codec.tag != &#34;multihash&#34;:
            raise err.ValueError(f&#34;Multicodec named {repr(codec.name)} exists, but is not a multihash.&#34;)
        implementation: MultihashImpl = raw.get(codec.name)
        _cache = Multihash._cache
        if codec.name in _cache:
            # if a multihash instance with this name is already registered
            instance: Multihash = _cache[codec.name]
            if instance.codec == codec and instance._implementation == implementation:
                # nothing changed, can use the existing instance
                return instance
            # otherwise remove the existing instance
            del _cache[codec.name]
        # create a fresh instance, register it and return it
        instance = super().__new__(cls)
        instance._codec = codec
        instance._implementation = implementation
        _cache[codec.name] = instance
        return instance

    @property
    def name(self) -&gt; str:
        &#34;&#34;&#34;
            Multihash multicodec name.

            Example usage:

            ```py
            &gt;&gt;&gt; sha2_256.name
            &#39;sha2-256&#39;
            ```
        &#34;&#34;&#34;
        return self.codec.name

    @property
    def code(self) -&gt; int:
        &#34;&#34;&#34;
            Multihash multicodec code.

            Example usage:

            ```py
            &gt;&gt;&gt; sha2_256.code
            18
            # 18 = 0x12
            ```
        &#34;&#34;&#34;
        return self.codec.code

    @property
    def codec(self) -&gt; Multicodec:
        &#34;&#34;&#34;
            The multicodec for this multihash.

            Example usage:

            ```py
            &gt;&gt;&gt; sha2_256.codec
            Multicodec(name=&#39;sha2-256&#39;, tag=&#39;multihash&#39;, code=&#39;0x12&#39;,
                       status=&#39;permanent&#39;, description=&#39;&#39;)
            ```
        &#34;&#34;&#34;
        return self._codec

    @property
    def max_digest_size(self) -&gt; Optional[int]:
        &#34;&#34;&#34;
            The maximum size (in bytes) for raw digests of this multihash,
            or `None` if there is no maximum size.
            Used to sense-check the wrapped/unwrapped raw digests.

            Example usage:

            ```py
            &gt;&gt;&gt; sha2_256.max_digest_size
            32
            # 32 bytes = 256 bits
            ```
        &#34;&#34;&#34;
        _, max_digest_size = self.implementation
        return max_digest_size

    @property
    def implementation(self) -&gt;MultihashImpl:
        &#34;&#34;&#34;
            Returns the implementation of a multihash multicodec, as a pair:

            ```py
            hash_function, max_digest_size = multihash.implementation(&#34;sha2-256&#34;)
            ```

            Above, `codec` is the `multiformats.multicodec.Multicodec` object carrying information about the
            multihash multicodec, `hash_function` is the function `bytes-&gt;bytes` computing the raw hashes,
            and `max_digest_size` is the max size of the digests produced by `hash_function` (or `None` if
            there is no max size, such as in the case of the &#39;identity&#39; multihash multicodec).

            Example usage:

            ```py
            &gt;&gt;&gt; sha2_256.implementation
            (&lt;function _hashlib_sha.&lt;locals&gt;.hashfun at 0x0000029396E22280&gt;, 32)
            ```
        &#34;&#34;&#34;
        return self._implementation
        # hash_function, max_digest_size = raw.get(self.name)
        # return hash_function, max_digest_size

    def wrap(self, raw_digest: BytesLike) -&gt; bytes:
        &#34;&#34;&#34;
            Wraps a raw digest into a multihash digest:

            ```
            &lt;raw digest&gt; -&gt; &lt;code&gt;&lt;size&gt;&lt;raw digest&gt;
            ```

            Example usage:

            ```py
            &gt;&gt;&gt; sha2_256 = multihash.get(&#34;sha2-256&#34;)
            &gt;&gt;&gt; raw_digest = bytes.fromhex(
            ... &#34;c0535e4be2b79ffd93291305436bf889314e4a3f&#34;)
            &gt;&gt;&gt; sha2_256.wrap(raw_digest).hex()
            &#34;1214c0535e4be2b79ffd93291305436bf889314e4a3f&#34;
            ```

            See `wrap` for more information.
        &#34;&#34;&#34;
        validate(raw_digest, BytesLike)
        _, max_digest_size = self.implementation
        size = len(raw_digest)
        if max_digest_size is not None and size &gt; max_digest_size:
            raise err.ValueError(f&#34;Digest size {max_digest_size} is listed for {self.name}, &#34;
                             f&#34;but a digest of larger size {size} was given to be wrapped.&#34;)
        return self.codec.wrap(varint.encode(size)+raw_digest)

    def digest(self, data: BytesLike, *, size: Optional[int] = None) -&gt; bytes:
        &#34;&#34;&#34;
            Computes the raw digest of the given data and wraps it into a multihash digest.
            The optional keyword argument `size` can be used to truncate the
            raw digest to be of the given size (or less) before encoding.

            Example usage:

            ```py
            &gt;&gt;&gt; sha2_256 = multihash.get(&#34;sha2-256&#34;)
            &gt;&gt;&gt; data = b&#34;Hello world!&#34;
            &gt;&gt;&gt; data.hex()
            &#34;48656c6c6f20776f726c6421&#34;
            &gt;&gt;&gt; sha2_256.digest(data).hex() # full 32-bytes hash
            &#39;1220c0535e4be2b79ffd93291305436bf889314e4a3faec05ecffcbb7df31ad9e51a&#39;
            &gt;&gt;&gt; sha2_256.digest(data, size=20).hex() # truncated hash
            &#39;1214c0535e4be2b79ffd93291305436bf889314e4a3f&#39;
            ```

            See `digest` for more information.
        &#34;&#34;&#34;
        hf, _ = self.implementation
        raw_digest = hf(data)
        if size is not None:
            raw_digest = raw_digest[:size] # truncate digest
        size = len(raw_digest)
        return self.codec.wrap(varint.encode(size)+raw_digest)

    def unwrap(self, digest: Union[BytesLike, BufferedIOBase]) -&gt; bytes:
        &#34;&#34;&#34;
            Unwraps a multihash digest into a hash digest:

            ```
            &lt;code&gt;&lt;size&gt;&lt;raw digest&gt; -&gt; &lt;raw digest&gt;
            ```

            If `digest` is one of bytes, bytearray or memoryview, the method also checks
            that the actual hash digest size matches the size listed by the multihash digest.

            Example usage:

            ```py
            &gt;&gt;&gt; sha2_256 = multihash.get(&#34;sha2-256&#34;)
            &gt;&gt;&gt; digest = bytes.fromhex(
            ... &#34;1214c0535e4be2b79ffd93291305436bf889314e4a3f&#34;)
            &gt;&gt;&gt; sha2_256.unwrap(digest).hex()
            &#39;c0535e4be2b79ffd93291305436bf889314e4a3f&#39;
            ```

        &#34;&#34;&#34;
        code, raw_digest = unwrap_raw(digest)
        if code != self.code:
            raise err.ValueError(f&#34;Decoded code {code} differs from multihash code {self.code}.&#34;)
        _validate_raw_digest_size(self.name, raw_digest, self.max_digest_size)
        return raw_digest

    def __str__(self) -&gt; str:
        return f&#34;multihash.get({repr(self.name)})&#34;

    def __repr__(self) -&gt; str:
        return f&#34;Multihash(codec={repr(self.name)})&#34;

    @property
    def _as_tuple(self) -&gt; Tuple[Type[&#34;Multihash&#34;], Multicodec]:
        return (Multihash, self.codec)

    def __hash__(self) -&gt; int:
        return hash(self._as_tuple)

    def __eq__(self, other: Any) -&gt; bool:
        if self is other:
            return True
        if not isinstance(other, Multihash):
            return NotImplemented
        return self._as_tuple == other._as_tuple</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="multiformats.multihash.Multihash.code"><code class="name">var <span class="ident">code</span> :Â int</code></dt>
<dd>
<div class="desc"><p>Multihash multicodec code.</p>
<p>Example usage:</p>
<pre><code class="language-py">&gt;&gt;&gt; sha2_256.code
18
# 18 = 0x12
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def code(self) -&gt; int:
    &#34;&#34;&#34;
        Multihash multicodec code.

        Example usage:

        ```py
        &gt;&gt;&gt; sha2_256.code
        18
        # 18 = 0x12
        ```
    &#34;&#34;&#34;
    return self.codec.code</code></pre>
</details>
</dd>
<dt id="multiformats.multihash.Multihash.codec"><code class="name">var <span class="ident">codec</span> :Â <a title="multiformats.multicodec.Multicodec" href="../multicodec/index.html#multiformats.multicodec.Multicodec">Multicodec</a></code></dt>
<dd>
<div class="desc"><p>The multicodec for this multihash.</p>
<p>Example usage:</p>
<pre><code class="language-py">&gt;&gt;&gt; sha2_256.codec
Multicodec(name='sha2-256', tag='multihash', code='0x12',
           status='permanent', description='')
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def codec(self) -&gt; Multicodec:
    &#34;&#34;&#34;
        The multicodec for this multihash.

        Example usage:

        ```py
        &gt;&gt;&gt; sha2_256.codec
        Multicodec(name=&#39;sha2-256&#39;, tag=&#39;multihash&#39;, code=&#39;0x12&#39;,
                   status=&#39;permanent&#39;, description=&#39;&#39;)
        ```
    &#34;&#34;&#34;
    return self._codec</code></pre>
</details>
</dd>
<dt id="multiformats.multihash.Multihash.implementation"><code class="name">var <span class="ident">implementation</span> :Â Tuple[Callable[[Union[bytes,Â bytearray,Â memoryview]],Â bytes],Â Optional[int]]</code></dt>
<dd>
<div class="desc"><p>Returns the implementation of a multihash multicodec, as a pair:</p>
<pre><code class="language-py">hash_function, max_digest_size = multihash.implementation(&quot;sha2-256&quot;)
</code></pre>
<p>Above, <code>codec</code> is the <code><a title="multiformats.multicodec.Multicodec" href="../multicodec/index.html#multiformats.multicodec.Multicodec">Multicodec</a></code> object carrying information about the
multihash multicodec, <code>hash_function</code> is the function <code>bytes-&gt;bytes</code> computing the raw hashes,
and <code>max_digest_size</code> is the max size of the digests produced by <code>hash_function</code> (or <code>None</code> if
there is no max size, such as in the case of the 'identity' multihash multicodec).</p>
<p>Example usage:</p>
<pre><code class="language-py">&gt;&gt;&gt; sha2_256.implementation
(&lt;function _hashlib_sha.&lt;locals&gt;.hashfun at 0x0000029396E22280&gt;, 32)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def implementation(self) -&gt;MultihashImpl:
    &#34;&#34;&#34;
        Returns the implementation of a multihash multicodec, as a pair:

        ```py
        hash_function, max_digest_size = multihash.implementation(&#34;sha2-256&#34;)
        ```

        Above, `codec` is the `multiformats.multicodec.Multicodec` object carrying information about the
        multihash multicodec, `hash_function` is the function `bytes-&gt;bytes` computing the raw hashes,
        and `max_digest_size` is the max size of the digests produced by `hash_function` (or `None` if
        there is no max size, such as in the case of the &#39;identity&#39; multihash multicodec).

        Example usage:

        ```py
        &gt;&gt;&gt; sha2_256.implementation
        (&lt;function _hashlib_sha.&lt;locals&gt;.hashfun at 0x0000029396E22280&gt;, 32)
        ```
    &#34;&#34;&#34;
    return self._implementation
    # hash_function, max_digest_size = raw.get(self.name)
    # return hash_function, max_digest_size</code></pre>
</details>
</dd>
<dt id="multiformats.multihash.Multihash.max_digest_size"><code class="name">var <span class="ident">max_digest_size</span> :Â Optional[None]</code></dt>
<dd>
<div class="desc"><p>The maximum size (in bytes) for raw digests of this multihash,
or <code>None</code> if there is no maximum size.
Used to sense-check the wrapped/unwrapped raw digests.</p>
<p>Example usage:</p>
<pre><code class="language-py">&gt;&gt;&gt; sha2_256.max_digest_size
32
# 32 bytes = 256 bits
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def max_digest_size(self) -&gt; Optional[int]:
    &#34;&#34;&#34;
        The maximum size (in bytes) for raw digests of this multihash,
        or `None` if there is no maximum size.
        Used to sense-check the wrapped/unwrapped raw digests.

        Example usage:

        ```py
        &gt;&gt;&gt; sha2_256.max_digest_size
        32
        # 32 bytes = 256 bits
        ```
    &#34;&#34;&#34;
    _, max_digest_size = self.implementation
    return max_digest_size</code></pre>
</details>
</dd>
<dt id="multiformats.multihash.Multihash.name"><code class="name">var <span class="ident">name</span> :Â str</code></dt>
<dd>
<div class="desc"><p>Multihash multicodec name.</p>
<p>Example usage:</p>
<pre><code class="language-py">&gt;&gt;&gt; sha2_256.name
'sha2-256'
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def name(self) -&gt; str:
    &#34;&#34;&#34;
        Multihash multicodec name.

        Example usage:

        ```py
        &gt;&gt;&gt; sha2_256.name
        &#39;sha2-256&#39;
        ```
    &#34;&#34;&#34;
    return self.codec.name</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="multiformats.multihash.Multihash.digest"><code class="name flex">
<span>def <span class="ident">digest</span></span>(<span>self, data:Â Union[bytes,Â bytearray,Â memoryview], *, size:Â Optional[None]Â =Â None) â€‘>Â bytes</span>
</code></dt>
<dd>
<div class="desc"><p>Computes the raw digest of the given data and wraps it into a multihash digest.
The optional keyword argument <code>size</code> can be used to truncate the
raw digest to be of the given size (or less) before encoding.</p>
<p>Example usage:</p>
<pre><code class="language-py">&gt;&gt;&gt; sha2_256 = multihash.get(&quot;sha2-256&quot;)
&gt;&gt;&gt; data = b&quot;Hello world!&quot;
&gt;&gt;&gt; data.hex()
&quot;48656c6c6f20776f726c6421&quot;
&gt;&gt;&gt; sha2_256.digest(data).hex() # full 32-bytes hash
'1220c0535e4be2b79ffd93291305436bf889314e4a3faec05ecffcbb7df31ad9e51a'
&gt;&gt;&gt; sha2_256.digest(data, size=20).hex() # truncated hash
'1214c0535e4be2b79ffd93291305436bf889314e4a3f'
</code></pre>
<p>See <code><a title="multiformats.multihash.digest" href="#multiformats.multihash.digest">digest()</a></code> for more information.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def digest(self, data: BytesLike, *, size: Optional[int] = None) -&gt; bytes:
    &#34;&#34;&#34;
        Computes the raw digest of the given data and wraps it into a multihash digest.
        The optional keyword argument `size` can be used to truncate the
        raw digest to be of the given size (or less) before encoding.

        Example usage:

        ```py
        &gt;&gt;&gt; sha2_256 = multihash.get(&#34;sha2-256&#34;)
        &gt;&gt;&gt; data = b&#34;Hello world!&#34;
        &gt;&gt;&gt; data.hex()
        &#34;48656c6c6f20776f726c6421&#34;
        &gt;&gt;&gt; sha2_256.digest(data).hex() # full 32-bytes hash
        &#39;1220c0535e4be2b79ffd93291305436bf889314e4a3faec05ecffcbb7df31ad9e51a&#39;
        &gt;&gt;&gt; sha2_256.digest(data, size=20).hex() # truncated hash
        &#39;1214c0535e4be2b79ffd93291305436bf889314e4a3f&#39;
        ```

        See `digest` for more information.
    &#34;&#34;&#34;
    hf, _ = self.implementation
    raw_digest = hf(data)
    if size is not None:
        raw_digest = raw_digest[:size] # truncate digest
    size = len(raw_digest)
    return self.codec.wrap(varint.encode(size)+raw_digest)</code></pre>
</details>
</dd>
<dt id="multiformats.multihash.Multihash.unwrap"><code class="name flex">
<span>def <span class="ident">unwrap</span></span>(<span>self, digest:Â Union[bytes,Â bytearray,Â memoryview,Â io.BufferedIOBase]) â€‘>Â bytes</span>
</code></dt>
<dd>
<div class="desc"><p>Unwraps a multihash digest into a hash digest:</p>
<pre><code>&lt;code&gt;&lt;size&gt;&lt;raw digest&gt; -&gt; &lt;raw digest&gt;
</code></pre>
<p>If <code><a title="multiformats.multihash.digest" href="#multiformats.multihash.digest">digest()</a></code> is one of bytes, bytearray or memoryview, the method also checks
that the actual hash digest size matches the size listed by the multihash digest.</p>
<p>Example usage:</p>
<pre><code class="language-py">&gt;&gt;&gt; sha2_256 = multihash.get(&quot;sha2-256&quot;)
&gt;&gt;&gt; digest = bytes.fromhex(
... &quot;1214c0535e4be2b79ffd93291305436bf889314e4a3f&quot;)
&gt;&gt;&gt; sha2_256.unwrap(digest).hex()
'c0535e4be2b79ffd93291305436bf889314e4a3f'
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def unwrap(self, digest: Union[BytesLike, BufferedIOBase]) -&gt; bytes:
    &#34;&#34;&#34;
        Unwraps a multihash digest into a hash digest:

        ```
        &lt;code&gt;&lt;size&gt;&lt;raw digest&gt; -&gt; &lt;raw digest&gt;
        ```

        If `digest` is one of bytes, bytearray or memoryview, the method also checks
        that the actual hash digest size matches the size listed by the multihash digest.

        Example usage:

        ```py
        &gt;&gt;&gt; sha2_256 = multihash.get(&#34;sha2-256&#34;)
        &gt;&gt;&gt; digest = bytes.fromhex(
        ... &#34;1214c0535e4be2b79ffd93291305436bf889314e4a3f&#34;)
        &gt;&gt;&gt; sha2_256.unwrap(digest).hex()
        &#39;c0535e4be2b79ffd93291305436bf889314e4a3f&#39;
        ```

    &#34;&#34;&#34;
    code, raw_digest = unwrap_raw(digest)
    if code != self.code:
        raise err.ValueError(f&#34;Decoded code {code} differs from multihash code {self.code}.&#34;)
    _validate_raw_digest_size(self.name, raw_digest, self.max_digest_size)
    return raw_digest</code></pre>
</details>
</dd>
<dt id="multiformats.multihash.Multihash.wrap"><code class="name flex">
<span>def <span class="ident">wrap</span></span>(<span>self, raw_digest:Â Union[bytes,Â bytearray,Â memoryview]) â€‘>Â bytes</span>
</code></dt>
<dd>
<div class="desc"><p>Wraps a raw digest into a multihash digest:</p>
<pre><code>&lt;raw digest&gt; -&gt; &lt;code&gt;&lt;size&gt;&lt;raw digest&gt;
</code></pre>
<p>Example usage:</p>
<pre><code class="language-py">&gt;&gt;&gt; sha2_256 = multihash.get(&quot;sha2-256&quot;)
&gt;&gt;&gt; raw_digest = bytes.fromhex(
... &quot;c0535e4be2b79ffd93291305436bf889314e4a3f&quot;)
&gt;&gt;&gt; sha2_256.wrap(raw_digest).hex()
&quot;1214c0535e4be2b79ffd93291305436bf889314e4a3f&quot;
</code></pre>
<p>See <code><a title="multiformats.multihash.wrap" href="#multiformats.multihash.wrap">wrap()</a></code> for more information.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def wrap(self, raw_digest: BytesLike) -&gt; bytes:
    &#34;&#34;&#34;
        Wraps a raw digest into a multihash digest:

        ```
        &lt;raw digest&gt; -&gt; &lt;code&gt;&lt;size&gt;&lt;raw digest&gt;
        ```

        Example usage:

        ```py
        &gt;&gt;&gt; sha2_256 = multihash.get(&#34;sha2-256&#34;)
        &gt;&gt;&gt; raw_digest = bytes.fromhex(
        ... &#34;c0535e4be2b79ffd93291305436bf889314e4a3f&#34;)
        &gt;&gt;&gt; sha2_256.wrap(raw_digest).hex()
        &#34;1214c0535e4be2b79ffd93291305436bf889314e4a3f&#34;
        ```

        See `wrap` for more information.
    &#34;&#34;&#34;
    validate(raw_digest, BytesLike)
    _, max_digest_size = self.implementation
    size = len(raw_digest)
    if max_digest_size is not None and size &gt; max_digest_size:
        raise err.ValueError(f&#34;Digest size {max_digest_size} is listed for {self.name}, &#34;
                         f&#34;but a digest of larger size {size} was given to be wrapped.&#34;)
    return self.codec.wrap(varint.encode(size)+raw_digest)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="multiformats" href="../index.html">multiformats</a></code></li>
</ul>
</li>
<li><h3><a href="#header-submodules">Sub-modules</a></h3>
<ul>
<li><code><a title="multiformats.multihash.err" href="err.html">multiformats.multihash.err</a></code></li>
<li><code><a title="multiformats.multihash.raw" href="raw.html">multiformats.multihash.raw</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="two-column">
<li><code><a title="multiformats.multihash.digest" href="#multiformats.multihash.digest">digest</a></code></li>
<li><code><a title="multiformats.multihash.exists" href="#multiformats.multihash.exists">exists</a></code></li>
<li><code><a title="multiformats.multihash.from_digest" href="#multiformats.multihash.from_digest">from_digest</a></code></li>
<li><code><a title="multiformats.multihash.get" href="#multiformats.multihash.get">get</a></code></li>
<li><code><a title="multiformats.multihash.is_implemented" href="#multiformats.multihash.is_implemented">is_implemented</a></code></li>
<li><code><a title="multiformats.multihash.unwrap" href="#multiformats.multihash.unwrap">unwrap</a></code></li>
<li><code><a title="multiformats.multihash.unwrap_raw" href="#multiformats.multihash.unwrap_raw">unwrap_raw</a></code></li>
<li><code><a title="multiformats.multihash.wrap" href="#multiformats.multihash.wrap">wrap</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="multiformats.multihash.Multihash" href="#multiformats.multihash.Multihash">Multihash</a></code></h4>
<ul class="two-column">
<li><code><a title="multiformats.multihash.Multihash.code" href="#multiformats.multihash.Multihash.code">code</a></code></li>
<li><code><a title="multiformats.multihash.Multihash.codec" href="#multiformats.multihash.Multihash.codec">codec</a></code></li>
<li><code><a title="multiformats.multihash.Multihash.digest" href="#multiformats.multihash.Multihash.digest">digest</a></code></li>
<li><code><a title="multiformats.multihash.Multihash.implementation" href="#multiformats.multihash.Multihash.implementation">implementation</a></code></li>
<li><code><a title="multiformats.multihash.Multihash.max_digest_size" href="#multiformats.multihash.Multihash.max_digest_size">max_digest_size</a></code></li>
<li><code><a title="multiformats.multihash.Multihash.name" href="#multiformats.multihash.Multihash.name">name</a></code></li>
<li><code><a title="multiformats.multihash.Multihash.unwrap" href="#multiformats.multihash.Multihash.unwrap">unwrap</a></code></li>
<li><code><a title="multiformats.multihash.Multihash.wrap" href="#multiformats.multihash.Multihash.wrap">wrap</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>