<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>multiformats.multiaddr API documentation</title>
<meta name="description" content="Implementation of the [multiaddr spec](https://github.com/multiformats/multiaddr) â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}.hljs-meta{user-select:none;-moz-user-select:none;-webkit-user-select:none;-ms-user-select:none;pointer-events:none}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>multiformats.multiaddr</code></h1>
</header>
<section id="section-intro">
<p>Implementation of the <a href="https://github.com/multiformats/multiaddr">multiaddr spec</a>.</p>
<p>Core functionality is provided by the <code><a title="multiformats.multiaddr.Proto" href="#multiformats.multiaddr.Proto">Proto</a></code> class:</p>
<pre><code class="language-py">&gt;&gt;&gt; from multiformats import Proto
&gt;&gt;&gt; ip4 = Proto(&quot;ip4&quot;)
&gt;&gt;&gt; ip4
Proto(&quot;ip4&quot;)
&gt;&gt;&gt; str(ip4)
'/ip4'
&gt;&gt;&gt; ip4.codec
Multicodec(name='ip4', tag='multiaddr', code='0x04',
           status='permanent', description='')
</code></pre>
<p>Slash notation is used to attach address values to protocols:</p>
<pre><code class="language-py">&gt;&gt;&gt; a = ip4/&quot;192.168.1.1&quot;
&gt;&gt;&gt; a
Addr('ip4', '192.168.1.1')
&gt;&gt;&gt; str(a)
'/ip4/192.168.1.1'
&gt;&gt;&gt; bytes(a)
b'\x04\xc0\xa8\x01\x01'
</code></pre>
<p>Address values can be specified as strings, integers, or <code>bytes</code>-like objects:</p>
<pre><code class="language-py">&gt;&gt;&gt; ip4/&quot;192.168.1.1&quot;
Addr('ip4', '192.168.1.1')
&gt;&gt;&gt; ip4/b'\xc0\xa8\x01\x01' # ip4/bytes([192, 168, 1, 1])
Addr('ip4', '192.168.1.1')
&gt;&gt;&gt; udp = Proto(&quot;udp&quot;)
&gt;&gt;&gt; udp/9090 # udp/&quot;9090&quot;
Addr('udp', '9090')
</code></pre>
<p>Slash notation is also used to encapsulate multiple protocol/address segments into a <a href="https://multiformats.io/multiaddr/">multiaddr</a>:</p>
<pre><code class="language-py">&gt;&gt;&gt; quic = Proto(&quot;quic&quot;)
&gt;&gt;&gt; ma = ip4/&quot;127.0.0.1&quot;/udp/9090/quic
&gt;&gt;&gt; ma
Multiaddr(Addr('ip4', '127.0.0.1'), Addr('udp', '9090'), Proto('quic'))
&gt;&gt;&gt; str(ma)
'/ip4/127.0.0.1/udp/9090/quic'
</code></pre>
<p>Bytes for multiaddrs are computed according to the <a href="https://multiformats.io/multiaddr/"><code>(TLV)+</code> multiaddr encoding</a>:</p>
<pre><code class="language-py">&gt;&gt;&gt; bytes(ip4/&quot;127.0.0.1&quot;).hex()
'047f000001'
&gt;&gt;&gt; bytes(udp/9090).hex()
          '91022382'
&gt;&gt;&gt; bytes(quic).hex()
                  'cc03'
&gt;&gt;&gt; bytes(ma).hex()
'047f00000191022382cc03'
</code></pre>
<p>The <code><a title="multiformats.multiaddr.parse" href="#multiformats.multiaddr.parse">parse()</a></code> and <code><a title="multiformats.multiaddr.decode" href="#multiformats.multiaddr.decode">decode()</a></code> functions create multiaddrs from their human-readable strings and encoded bytes respectively:</p>
<pre><code class="language-py">    &gt;&gt;&gt; from multiformats import multiaddr
    &gt;&gt;&gt; s = '/ip4/127.0.0.1/udp/9090/quic'
    &gt;&gt;&gt; multiaddr.parse(s)
    Multiaddr(Addr('ip4', '127.0.0.1'), Addr('udp', '9090'), Proto('quic'))
    &gt;&gt;&gt; b = bytes.fromhex('047f00000191022382cc03')
    &gt;&gt;&gt; multiaddr.decode(b)
    Multiaddr(Addr('ip4', '127.0.0.1'), Addr('udp', '9090'), Proto('quic'))
</code></pre>
<p>For uniformity of API, the same functionality as the <code><a title="multiformats.multiaddr.Proto" href="#multiformats.multiaddr.Proto">Proto</a></code> class is provided by the <code><a title="multiformats.multiaddr.proto" href="#multiformats.multiaddr.proto">proto()</a></code> function:</p>
<pre><code class="language-py">&gt;&gt;&gt; from multiformats import multiaddr
&gt;&gt;&gt; ip4 = multiaddr.proto(&quot;ip4&quot;)
&gt;&gt;&gt; ip4
Proto(&quot;ip4&quot;)
</code></pre>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
    Implementation of the [multiaddr spec](https://github.com/multiformats/multiaddr).

    Core functionality is provided by the `Proto` class:

    ```py
    &gt;&gt;&gt; from multiformats import Proto
    &gt;&gt;&gt; ip4 = Proto(&#34;ip4&#34;)
    &gt;&gt;&gt; ip4
    Proto(&#34;ip4&#34;)
    &gt;&gt;&gt; str(ip4)
    &#39;/ip4&#39;
    &gt;&gt;&gt; ip4.codec
    Multicodec(name=&#39;ip4&#39;, tag=&#39;multiaddr&#39;, code=&#39;0x04&#39;,
               status=&#39;permanent&#39;, description=&#39;&#39;)
    ```

    Slash notation is used to attach address values to protocols:

    ```py
    &gt;&gt;&gt; a = ip4/&#34;192.168.1.1&#34;
    &gt;&gt;&gt; a
    Addr(&#39;ip4&#39;, &#39;192.168.1.1&#39;)
    &gt;&gt;&gt; str(a)
    &#39;/ip4/192.168.1.1&#39;
    &gt;&gt;&gt; bytes(a)
    b&#39;\\x04\\xc0\\xa8\\x01\\x01&#39;
    ```

    Address values can be specified as strings, integers, or `bytes`-like objects:

    ```py
    &gt;&gt;&gt; ip4/&#34;192.168.1.1&#34;
    Addr(&#39;ip4&#39;, &#39;192.168.1.1&#39;)
    &gt;&gt;&gt; ip4/b&#39;\\xc0\\xa8\\x01\\x01&#39; # ip4/bytes([192, 168, 1, 1])
    Addr(&#39;ip4&#39;, &#39;192.168.1.1&#39;)
    &gt;&gt;&gt; udp = Proto(&#34;udp&#34;)
    &gt;&gt;&gt; udp/9090 # udp/&#34;9090&#34;
    Addr(&#39;udp&#39;, &#39;9090&#39;)
    ```

    Slash notation is also used to encapsulate multiple protocol/address segments into a [multiaddr](https://multiformats.io/multiaddr/):

    ```py
    &gt;&gt;&gt; quic = Proto(&#34;quic&#34;)
    &gt;&gt;&gt; ma = ip4/&#34;127.0.0.1&#34;/udp/9090/quic
    &gt;&gt;&gt; ma
    Multiaddr(Addr(&#39;ip4&#39;, &#39;127.0.0.1&#39;), Addr(&#39;udp&#39;, &#39;9090&#39;), Proto(&#39;quic&#39;))
    &gt;&gt;&gt; str(ma)
    &#39;/ip4/127.0.0.1/udp/9090/quic&#39;
    ```

    Bytes for multiaddrs are computed according to the [`(TLV)+` multiaddr encoding](https://multiformats.io/multiaddr/):

    ```py
    &gt;&gt;&gt; bytes(ip4/&#34;127.0.0.1&#34;).hex()
    &#39;047f000001&#39;
    &gt;&gt;&gt; bytes(udp/9090).hex()
              &#39;91022382&#39;
    &gt;&gt;&gt; bytes(quic).hex()
                      &#39;cc03&#39;
    &gt;&gt;&gt; bytes(ma).hex()
    &#39;047f00000191022382cc03&#39;
    ```

    The `parse` and `decode` functions create multiaddrs from their human-readable strings and encoded bytes respectively:

    ```py
        &gt;&gt;&gt; from multiformats import multiaddr
        &gt;&gt;&gt; s = &#39;/ip4/127.0.0.1/udp/9090/quic&#39;
        &gt;&gt;&gt; multiaddr.parse(s)
        Multiaddr(Addr(&#39;ip4&#39;, &#39;127.0.0.1&#39;), Addr(&#39;udp&#39;, &#39;9090&#39;), Proto(&#39;quic&#39;))
        &gt;&gt;&gt; b = bytes.fromhex(&#39;047f00000191022382cc03&#39;)
        &gt;&gt;&gt; multiaddr.decode(b)
        Multiaddr(Addr(&#39;ip4&#39;, &#39;127.0.0.1&#39;), Addr(&#39;udp&#39;, &#39;9090&#39;), Proto(&#39;quic&#39;))
    ```

    For uniformity of API, the same functionality as the `Proto` class is provided by the `proto` function:

    ```py
    &gt;&gt;&gt; from multiformats import multiaddr
    &gt;&gt;&gt; ip4 = multiaddr.proto(&#34;ip4&#34;)
    &gt;&gt;&gt; ip4
    Proto(&#34;ip4&#34;)
    ```

&#34;&#34;&#34;

from itertools import islice, chain
from typing import Any, cast, ClassVar, Dict, Iterator, List, Optional, overload, Sequence, Tuple, Type, Union
from weakref import WeakValueDictionary
import sys
from typing_validation import validate

from multiformats import varint, multicodec
from multiformats.multicodec import Multicodec
from multiformats.varint import BytesLike, byteslike

from . import raw, err
from .raw import RawEncoder, RawDecoder, ProtoImpl, _validate_size

class Proto:
    &#34;&#34;&#34;
        Container class for a single protocol segment of a [multiaddr](https://multiformats.io/multiaddr/).

        ```py
        &gt;&gt;&gt; ip4 = Proto(&#34;ip4&#34;)
        &gt;&gt;&gt; ip4
        Proto(&#34;ip4&#34;)
        &gt;&gt;&gt; str(ip4)
        &#39;/ip4&#39;
        ```

        For protocols that don&#39;t require an address value, bytes are computed as the varint encoding of protocl code:

        ```py
        &gt;&gt;&gt; quic = Proto(&#39;quic&#39;)
        &gt;&gt;&gt; quic.code
        460
        &gt;&gt;&gt; varint.encode(quic.code).hex()
        &#39;cc03&#39;
        &gt;&gt;&gt; bytes(quic).hex()
        &#39;cc03&#39;
        ```
    &#34;&#34;&#34;

    # WeakValueDictionary[str, &#34;Proto&#34;]
    _cache: ClassVar[WeakValueDictionary] = WeakValueDictionary() # type: ignore

    _codec: Multicodec
    _implementation: ProtoImpl

    __slots__ = (&#34;__weakref__&#34;, &#34;_codec&#34;, &#34;_implementation&#34;)

    def __new__(cls, codec: Union[str, int, Multicodec]) -&gt; &#34;Proto&#34;:
        # check that the codec exists:
        if isinstance(codec, str):
            codec = multicodec.get(codec)
        elif isinstance(codec, int):
            codec = multicodec.get(code=codec)
        else:
            validate(codec, Multicodec)
            existing_codec = multicodec.get(codec.name)
            if existing_codec != codec:
                raise err.ValueError(f&#34;Multicodec named {repr(codec.name)} exists, but is not the one given.&#34;)
            codec = existing_codec
        # check that the codec is a multiaddr multicodec:
        if codec.tag != &#34;multiaddr&#34;:
            raise err.ValueError(f&#34;Multicodec named {repr(codec.name)} exists, but is not a multiaddr.&#34;)
        implementation: ProtoImpl = raw.get(codec.name)
        _cache = Proto._cache
        if codec.name in _cache:
            # if a proto instance with this name is already registered
            instance: Proto = _cache[codec.name]
            if instance._codec == codec and instance._implementation == implementation:
                # nothing changed, can use the existing instance
                return instance
            # otherwise remove the existing instance
            del _cache[codec.name]
        # create a fresh instance, register it and return it
        instance = super().__new__(cls)
        instance._codec = codec
        instance._implementation = implementation
        _cache[codec.name] = instance
        return instance

    @property
    def name(self) -&gt; str:
        &#34;&#34;&#34;
            Protocol name.

            Example usage:

            ```py
            &gt;&gt;&gt; ip4.name
            &#39;ip4&#39;
            ```
        &#34;&#34;&#34;
        return self.codec.name

    @property
    def code(self) -&gt; int:
        &#34;&#34;&#34;
            Protocol code.

            Example usage:

            ```py
            &gt;&gt;&gt; ip4.code
            4
            # 4 = 0x04
            ```
        &#34;&#34;&#34;
        return self.codec.code

    @property
    def codec(self) -&gt; Multicodec:
        &#34;&#34;&#34;
            The multicodec for this protocol.

            Example usage:

            ```py
            &gt;&gt;&gt; ip4.codec
            Multicodec(name=&#39;ip4&#39;, tag=&#39;multiaddr&#39;, code=&#39;0x04&#39;,
                       status=&#39;permanent&#39;, description=&#39;&#39;)
            ```
        &#34;&#34;&#34;
        return self._codec

    @property
    def implementation(self) -&gt; ProtoImpl:
        &#34;&#34;&#34;
            The implementation for this protocol, as a triple of
            raw encoder, raw decoder and address size.

            Example usage:

            ```py
            &gt;&gt;&gt; ip4.implementation
            (
             &lt;function ip4_encoder at 0x000002B4C9956310&gt;,
             &lt;function ip4_decoder at 0x000002B4C99563A0&gt;,
             4
            )
            ```
        &#34;&#34;&#34;
        return self._implementation

    @property
    def raw_encoder(self) -&gt; Optional[RawEncoder]:
        &#34;&#34;&#34;
            The raw encoder for this protocol.

            Example usage:

            ```py
            &gt;&gt;&gt; ip4.raw_encoder
            &lt;function ip4_encoder at 0x000002B4C9956310&gt;
            ```
        &#34;&#34;&#34;
        return self.implementation[0]

    @property
    def raw_decoder(self) -&gt; Optional[RawDecoder]:
        &#34;&#34;&#34;
            The raw decoder for this protocol.

            Example usage:

            ```py
            &gt;&gt;&gt; ip4.raw_decoder
            &lt;function ip4_decoder at 0x000002B4C99563A0&gt;
            ```
        &#34;&#34;&#34;
        return self.implementation[1]

    @property
    def addr_size(self) -&gt; Optional[int]:
        &#34;&#34;&#34;
            The address size (in bytes) for this protocol:

            - for protocols with no address, `addr_size` is 0
            - for protocols with addresses of variable binary size, `addr_size` is `None`
            - for all other protocols, size is a positive `int`

            Example usage:

            ```py
            &gt;&gt;&gt; ip4.addr_size
            4
            ```
        &#34;&#34;&#34;
        return self.implementation[2]

    @property
    def admits_addr(self) -&gt; bool:
        &#34;&#34;&#34;
            Whether this protocol admits an address.

            ```py
            &gt;&gt;&gt; ip4.admits_addr
            True
            ```
        &#34;&#34;&#34;
        return self.addr_size != 0

    def is_addr_valid(self, addr_value: Union[str, BytesLike]) -&gt; bool:
        &#34;&#34;&#34;
            Validates an address value.

            Example usage:

            ```py
            &gt;&gt;&gt; ip4.is_addr_valid(&#34;192.168.1.1&#34;)
            True
            &gt;&gt;&gt; ip4.is_addr_valid(bytes([192, 168, 1, 1]))
            True
            ```

            The same result can be obtained with container syntax:

            ```py
            &gt;&gt;&gt; &#34;192.168.1.1&#34; in ip4
            True
            &gt;&gt;&gt; bytes([192, 168, 1, 1]) in ip4
            True
            ```
        &#34;&#34;&#34;
        try:
            self.validate(addr_value)
            return True
        except err.ValueError:
            return False

    def validate(self, addr_value: Union[str, BytesLike]) -&gt; Tuple[str, bytes]:
        &#34;&#34;&#34;
            Raises `err.ValueError` if `not self.is_valid(addr_value)`.
            If successful, returns a pair of the string and bytes representations of the address value.

            Example usage:

            ```py
            &gt;&gt;&gt; ip4.validate(&#34;192.168.1.1&#34;)
            (&#39;192.168.1.1&#39;, b&#39;\\xc0\\xa8\\x01\\x01&#39;)
            &gt;&gt;&gt; ip4.validate(&#34;192.168&#34;)
            err.ValueError: Expected 4 octets in &#39;192.168&#39;
            ```
        &#34;&#34;&#34;
        raw_encoder, raw_decoder, addr_size = self.implementation
        if addr_size == 0:
            raise err.ValueError(f&#34;Protocol admits no address value, but {repr(addr_value)} was passed.&#34;)
        if isinstance(addr_value, byteslike):
            assert raw_decoder is not None
            addr_value_str = raw_decoder(addr_value) # raises err.ValueError if addr_value is invalid
            if not isinstance(addr_value, bytes):
                addr_value = bytes(addr_value)
            return addr_value_str, addr_value
        validate(addr_value, str)
        assert raw_encoder is not None
        addr_value_bytes = raw_encoder(addr_value) # raises err.ValueError if addr_value is invalid
        return addr_value, addr_value_bytes

    def addr(self, value: Union[str, BytesLike]) -&gt; &#34;Addr&#34;:
        &#34;&#34;&#34;
            Returns an address for this protocol.

            Example usage:

            ```py
            &gt;&gt;&gt; ip4.addr(&#34;192.168.1.1&#34;)
            Addr(&#39;ip4&#39;, &#39;192.168.1.1&#39;)
            &gt;&gt;&gt; ip4.addr(bytes([192, 168, 1, 1]))
            Addr(&#39;ip4&#39;, &#39;192.168.1.1&#39;)
            ```

            The same address can be obtained with slash syntax:

            ```py
            &gt;&gt;&gt; ip4/&#34;192.168.1.256&#34;
            Addr(&#39;ip4&#39;, &#39;192.168.1.256&#39;)
            &gt;&gt;&gt; ip4/b&#39;\\xc0\\xa8\\x01\\x01&#39;
            Addr(&#39;ip4&#39;, &#39;192.168.1.1&#39;)
            ```
        &#34;&#34;&#34;
        return Addr(self, value)

    def __contains__(self, value: Union[str, BytesLike]) -&gt; bool:
        return self.is_addr_valid(value)

    @overload
    def __truediv__(self, value: Union[&#34;Proto&#34;, &#34;Addr&#34;, &#34;Multiaddr&#34;]) -&gt; &#34;Multiaddr&#34;:
        ...

    @overload
    def __truediv__(self, value: Union[int, str, BytesLike]) -&gt; &#34;Addr&#34;:
        ...

    def __truediv__(self, value: Union[int, str, BytesLike, &#34;Proto&#34;, &#34;Addr&#34;, &#34;Multiaddr&#34;]) -&gt; Union[&#34;Addr&#34;, &#34;Multiaddr&#34;]:
        if isinstance(value, int):
            value = str(value)
        if isinstance(value, (str,)+byteslike):
            return self.addr(value)
        if isinstance(value, (Addr, Proto)):
            return Multiaddr(self, value)
        if isinstance(value, Multiaddr):
            return Multiaddr(self, *value)
        return NotImplemented

    def __str__(self) -&gt; str:
        return f&#34;/{self.name}&#34;

    def __bytes__(self) -&gt; bytes:
        if self.addr_size != 0:
            raise err.ValueError(&#34;Missing address value for protocol, cannot compute bytes.&#34;)
        return varint.encode(self.code)

    def __repr__(self) -&gt; str:
        return f&#34;Proto({repr(self.name)})&#34;

    @property
    def _as_tuple(self) -&gt; Tuple[Type[&#34;Proto&#34;], Multicodec]:
        return (Proto, self.codec)

    def __hash__(self) -&gt; int:
        return hash(self._as_tuple)

    def __eq__(self, other: Any) -&gt; bool:
        if self is other:
            return True
        if not isinstance(other, Proto):
            return NotImplemented
        return self._as_tuple == other._as_tuple

class Addr:
    &#34;&#34;&#34;
        Container class for a single protocol address in a [multiaddr](https://multiformats.io/multiaddr/).

        ```py
        &gt;&gt;&gt; a = Addr(&#39;ip4&#39;, &#39;192.168.1.1&#39;)
        &gt;&gt;&gt; a
        Addr(&#39;ip4&#39;, &#39;192.168.1.1&#39;)
        &gt;&gt;&gt; str(a)
        &#39;/ip4/192.168.1.1&#39;
        ```

        The slash notation provides a more literate way to construct protocol addresses:

        ```py
        &gt;&gt;&gt; a = ip4/&#34;192.168.1.1&#34;
        &gt;&gt;&gt; a
        Addr(&#39;ip4&#39;, &#39;192.168.1.1&#39;)
        ```

        Bytes for protocol addresses are computed according to the TLV [multiaddr format](https://multiformats.io/multiaddr/):

        ```py
        &gt;&gt;&gt; bytes(ip4/&#34;127.0.0.1&#34;).hex()
        &#39;047f000001&#39;
        &gt;&gt;&gt; varint.encode(ip4.code).hex()
        &#39;04&#39;
        &gt;&gt;&gt; bytes([127, 0, 0, 1]).hex()
          &#39;7f000001&#39;
        ```
    &#34;&#34;&#34;

    _proto: Proto
    _value: str
    _value_bytes: bytes

    __slots__ = (&#34;__weakref__&#34;, &#34;_proto&#34;, &#34;_value&#34;, &#34;_value_bytes&#34;)

    def __new__(cls, proto: Union[str, int, Multicodec, Proto], value: Union[str, BytesLike]) -&gt; &#34;Addr&#34;:
        if not isinstance(proto, Proto):
            proto = Proto(proto)
        value, value_bytes = proto.validate(value)
        instance: Addr = super().__new__(cls)
        instance._proto = proto
        instance._value = value
        instance._value_bytes = value_bytes
        return instance

    @property
    def proto(self) -&gt; Proto:
        &#34;&#34;&#34;
            The address protocol.

            Example usage:

            ```py
            &gt;&gt;&gt; a = Addr(&#39;ip4&#39;, &#39;192.168.1.1&#39;)
            &gt;&gt;&gt; a.proto
            Proto(&#39;ip4&#39;)
            ```
        &#34;&#34;&#34;
        return self._proto

    @property
    def value(self) -&gt; str:
        &#34;&#34;&#34;
            The address value, as a string.

            Example usage:

            ```py
            &gt;&gt;&gt; a = Addr(&#39;ip4&#39;, &#39;192.168.1.1&#39;)
            &gt;&gt;&gt; a.value
            &#39;192.168.1.1&#39;
            ```
        &#34;&#34;&#34;
        return self._value

    @property
    def value_bytes(self) -&gt; bytes:
        &#34;&#34;&#34;
            The address value, as bytes.

            Example usage:

            ```py
            &gt;&gt;&gt; a = Addr(&#39;ip4&#39;, &#39;192.168.1.1&#39;)
            &gt;&gt;&gt; a.value_bytes
            b&#39;\\xc0\\xa8\\x01\\x01&#39;
            &gt;&gt;&gt; list(a.value_bytes)
            [192, 168, 1, 1]
            ```
        &#34;&#34;&#34;
        return self._value_bytes

    def __truediv__(self, other: Union[Proto, &#34;Addr&#34;, &#34;Multiaddr&#34;]) -&gt; &#34;Multiaddr&#34;:
        if isinstance(other, (Addr, Proto)):
            return Multiaddr(self, other)
        if isinstance(other, Multiaddr):
            return Multiaddr(self, *other)
        return NotImplemented

    def __str__(self) -&gt; str:
        return f&#34;{str(self.proto)}/{self.value}&#34;

    def __bytes__(self) -&gt; bytes:
        proto = self.proto
        value_bytes = self.value_bytes
        if proto.addr_size is None:
            assert value_bytes is not None
            l = varint.encode(len(value_bytes))
            return proto.codec.wrap(l+value_bytes)
        return proto.codec.wrap(value_bytes)

    def __repr__(self) -&gt; str:
        return f&#34;Addr({repr(self.proto.name)}, {repr(self.value)})&#34;

    @property
    def _as_tuple(self) -&gt; Tuple[Type[&#34;Addr&#34;], Proto, Optional[str]]:
        return (Addr, self.proto, self.value)

    def __hash__(self) -&gt; int:
        return hash(self._as_tuple)

    def __eq__(self, other: Any) -&gt; bool:
        if self is other:
            return True
        if not isinstance(other, Addr):
            return NotImplemented
        return self._as_tuple == other._as_tuple


class Multiaddr(Sequence[Union[Addr, Proto]]):
    &#34;&#34;&#34;
        Container class for a [multiaddr](https://multiformats.io/multiaddr/).

        Example usage:

        ```py
        &gt;&gt;&gt; ip4 = Proto(&#34;ip4&#34;)
        &gt;&gt;&gt; udp = Proto(&#34;udp&#34;)
        &gt;&gt;&gt; quic = Proto(&#34;quic&#34;)
        &gt;&gt;&gt; ma = ip4/&#34;127.0.0.1&#34;/udp/9090/quic
        &gt;&gt;&gt; ma
        Multiaddr(Addr(&#39;ip4&#39;, &#39;127.0.0.1&#39;), Addr(&#39;udp&#39;, &#39;9090&#39;), Proto(&#39;quic&#39;))
        &gt;&gt;&gt; str(ma)
        &#39;/ip4/127.0.0.1/udp/9090/quic&#39;
        ```

        Bytes for multiaddrs are computed according to the (TLV)+ [multiaddr format](https://multiformats.io/multiaddr/):

        ```py
        &gt;&gt;&gt; bytes(ip4/&#34;127.0.0.1&#34;).hex()
        &#39;047f000001&#39;
        &gt;&gt;&gt; bytes(udp/9090).hex()
                  &#39;91022382&#39;
        &gt;&gt;&gt; bytes(quic).hex()
                          &#39;cc03&#39;
        &gt;&gt;&gt; bytes(ma).hex()
        &#39;047f00000191022382cc03&#39;
        ```
    &#34;&#34;&#34;

    _addrs: Tuple[Union[Addr, Proto], ...]
    _proto_map: Dict[Proto, int]
    _is_incomplete: bool

    __slots__ = (&#34;__weakref__&#34;, &#34;_addrs&#34;, &#34;_proto_map&#34;, &#34;_is_incomplete&#34;)

    def __new__(cls, *addrs: Union[Addr, Proto]) -&gt; &#34;Multiaddr&#34;:
        l = len(addrs)
        is_incomplete = False
        proto_map: Dict[Proto, int] = {}
        for idx, addr in enumerate(addrs):
            if isinstance(addr, Proto):
                proto = addr
                if proto.addr_size != 0:
                    if idx == l-1:
                        is_incomplete = True
                    else:
                        raise err.ValueError(f&#34;Protocol {repr(proto.name)} expects an address, but is followed by another protocol instead.&#34;)
            else:
                validate(addr, Addr)
                proto = addr.proto
            if proto in proto_map:
                raise err.ValueError(f&#34;Protocol {repr(proto.name)} appears twice in multiaddr.&#34;)
            proto_map[proto] = idx
        instance: Multiaddr = super().__new__(cls)
        instance._addrs = addrs
        instance._proto_map = proto_map
        instance._is_incomplete = is_incomplete
        return instance

    @property
    def is_incomplete(self) -&gt; bool:
        &#34;&#34;&#34;
            Whether this multiaddress is incomplete, i.e. it still requires an address for
            the last protocol in the sequence.

            ```py
            &gt;&gt;&gt; ma = ip4/&#34;127.0.0.1&#34;/udp
            &gt;&gt;&gt; ma.is_incomplete
            True
            &gt;&gt;&gt; str(ma)
            &#39;/ip4/127.0.0.1/udp&#39;
            &gt;&gt;&gt; ma2 = ma/9090
            &gt;&gt;&gt; str(ma2)
            &#39;/ip4/127.0.0.1/udp/9090&#39;
            &gt;&gt;&gt; ma2.is_incomplete
            False
            ```

            Incomplete multiaddrs don&#39;t admit a byte representation:

            ```py
            &gt;&gt;&gt; bytes(ma)
            err.ValueError: Missing address value for last protocol, cannot compute bytes.
            &gt;&gt;&gt; bytes(ma2).hex()
            &#39;047f00000191022382&#39;
            ```
        &#34;&#34;&#34;
        return self._is_incomplete

    def index(self, value: Union[Addr, Proto], start: int = 0, stop: Optional[int] = None) -&gt; int:
        &#34;&#34;&#34;
            Returns the unique index at which a protocol/address appears in the multiaddress:

            ```py
            &gt;&gt;&gt; ma = ip4/&#34;127.0.0.1&#34;/udp/9090/quic
            &gt;&gt;&gt; str(ma)
            &#39;/ip4/127.0.0.1/udp/9090/quic&#39;
            &gt;&gt;&gt; udp in ma
            True
            &gt;&gt;&gt; ma.index(udp)
            1
            &gt;&gt;&gt; ma[ma.index(udp)]
            Addr(&#39;udp&#39;, &#39;9090&#39;)
            &gt;&gt;&gt; ip4/&#34;127.0.0.1&#34; in ma
            True
            &gt;&gt;&gt; ma.index(ip4/&#34;127.0.0.1&#34; in ma)
            0
            ```

            This method raises `err.ValueError` if the protocol/address does not appear:

            ```py
            &gt;&gt;&gt; ip6 = Proto(&#34;ip6&#34;)
            &gt;&gt;&gt; ip6 in ma
            False
            &gt;&gt;&gt; ma.index(ip6)
            err.ValueError: Protocol &#39;ip6&#39; does not appear in multiaddr /ip4/127.0.0.1/udp/9090/quic
            &gt;&gt;&gt; ip4/&#34;127.0.0.2&#34; in ma
            False
            &gt;&gt;&gt; ma.index(ip4/&#34;127.0.0.2&#34;)
            err.ValueError: Address Addr(&#39;ip4&#39;, &#39;127.0.0.2&#39;) does not appear in multiaddr /ip4/127.0.0.1/udp/9090/quic
            ```

            The optional `start` and `stop` arguments can be used to specify a range of indices
            within which to search for the protocol/address.

            ```py
            &gt;&gt;&gt; ip4/&#34;127.0.0.1&#34; in ma
            True
            &gt;&gt;&gt; ma.index(ip4/&#34;127.0.0.1&#34;)
            0
            &gt;&gt;&gt; ma.index(ip4/&#34;127.0.0.1&#34;, start=1)
            err.ValueError: Address Addr(&#39;ip4&#39;, &#39;127.0.0.1&#39;) does not appear in sub-multiaddr /udp/9090/quic of multiaddr /ip4/127.0.0.1/udp/9090/quic
            ```
        &#34;&#34;&#34;
        validate(start, int)
        if stop is None:
            stop = len(self)
        validate(stop, int)
        if isinstance(value, Proto):
            proto = value
        else:
            validate(value, Addr)
            proto = value.proto
        if proto not in self._proto_map:
            raise err.ValueError(f&#34;Protocol {repr(proto.name)} does not appear in multiaddr {str(self)}&#34;)
        idx = self._proto_map[proto]
        if isinstance(value, Addr):
            if self[idx] != value:
                raise err.ValueError(f&#34;Address {repr(value)} does not appear in multiaddr {str(self)}&#34;)
            if not start &lt;= idx &lt; stop:
                raise err.ValueError(f&#34;Address {repr(value)} does not appear in sub-multiaddr {str(self[start:stop])} &#34;
                                 f&#34;of multiaddr {str(self)}&#34;)
        return idx

    def __contains__(self, value: Any) -&gt; bool:
        if isinstance(value, (Addr, Proto)):
            try:
                self.index(value)
                return True
            except err.ValueError:
                return False
        return False

    def __len__(self) -&gt; int:
        return len(self._addrs)

    def __iter__(self) -&gt; Iterator[Union[Addr, Proto]]:
        return iter(self._addrs)

    @overload
    def __getitem__(self, idx: int) -&gt; Union[Addr, Proto]:
        ...

    @overload
    def __getitem__(self, idx: slice) -&gt; &#34;Multiaddr&#34;:
        ...

    def __getitem__(self, idx: Union[int, slice]) -&gt; Union[Addr, Proto, &#34;Multiaddr&#34;]:
        if isinstance(idx, int):
            return self._addrs[idx]
        validate(idx, slice)
        return Multiaddr(*self._addrs[idx])

    def __truediv__(self, other: Union[int, str, BytesLike, Addr, Proto, &#34;Multiaddr&#34;]) -&gt; &#34;Multiaddr&#34;:
        if isinstance(other, (int, str,)+byteslike):
            if not self.is_incomplete:
                raise err.ValueError(&#34;Unexpected address value. Expected Proto, Addr or Multiaddr.&#34;)
            addrs = list(self)
            tail_proto = addrs[-1]
            assert isinstance(tail_proto, Proto)
            return Multiaddr(*islice(addrs, 0, len(addrs)-1), tail_proto/other)
        if isinstance(other, (Addr, Proto)):
            if self.is_incomplete:
                raise err.ValueError(&#34;Expected address value (string or binary).&#34;)
            return Multiaddr(*self, other)
        if isinstance(other, Multiaddr):
            if self.is_incomplete:
                raise err.ValueError(&#34;Expected address value (string or binary).&#34;)
            return Multiaddr(*self, *other)
        return NotImplemented

    def __str__(self) -&gt; str:
        return &#34;&#34;.join(str(a) for a in self)

    def __bytes__(self) -&gt; bytes:
        if self.is_incomplete:
            raise err.ValueError(&#34;Missing address value for last protocol, cannot compute bytes.&#34;)
        return bytes(chain.from_iterable(bytes(addr) for addr in self))

    def __repr__(self) -&gt; str:
        return f&#34;Multiaddr({&#39;, &#39;.join(repr(a) for a in self)})&#34;

    @property
    def _as_tuple(self) -&gt; Tuple[Type[&#34;Multiaddr&#34;], Tuple[Union[Addr, Proto], ...]]:
        return (Multiaddr, self._addrs)

    def __hash__(self) -&gt; int:
        return hash(self._as_tuple)

    def __eq__(self, other: Any) -&gt; bool:
        if self is other:
            return True
        if not isinstance(other, Multiaddr):
            return NotImplemented
        return self._as_tuple == other._as_tuple


def proto(codec: Union[str, int, Multicodec]) -&gt; Proto:
    &#34;&#34;&#34;
        Convenience function to construct a `Proto` instance.

        Example usage:

        ```py
        &gt;&gt;&gt; ip4 = multiaddr.proto(&#34;ip4&#34;)
        &gt;&gt;&gt; ip4
        Proto(&#34;ip4&#34;)
        ```
    &#34;&#34;&#34;
    return Proto(codec)

def parse(multiaddr_str: str, allow_incomplete: bool = False) -&gt; Multiaddr:
    &#34;&#34;&#34;
        Parses a multiaddr from its human-readable string representation.

        Example usage:

        ```py
        &gt;&gt;&gt; s = &#39;/ip4/127.0.0.1/udp/9090/quic&#39;
        &gt;&gt;&gt; multiaddr.parse(s)
        Multiaddr(Addr(&#39;ip4&#39;, &#39;127.0.0.1&#39;), Addr(&#39;udp&#39;, &#39;9090&#39;), Proto(&#39;quic&#39;))
        ```

        Example usage with incomplete multiaddr:

        ```py
        &gt;&gt;&gt; s = &#39;/ip4/127.0.0.1/udp&#39;
        &gt;&gt;&gt; multiaddr.parse(s)
        err.ValueError: Decoded multiaddr is incomplete: /ip4/127.0.0.1/udp
        &gt;&gt;&gt; multiaddr.parse(s, allow_incomplete=True)
        Multiaddr(Addr(&#39;ip4&#39;, &#39;127.0.0.1&#39;), Proto(&#39;udp&#39;))
        ```
    &#34;&#34;&#34;
    validate(multiaddr_str, str)
    validate(allow_incomplete, bool)
    tokens = multiaddr_str.split(&#34;/&#34;)
    protocol: Optional[Proto] = None
    segments: List[Union[Addr, Proto]] = []
    for token in islice(tokens, 1, None):
        if protocol is None:
            protocol = Proto(token)
            if not protocol.admits_addr:
                segments.append(protocol)
                protocol = None
        else:
            segments.append(protocol/token)
            protocol = None
    if protocol is not None:
        segments.append(protocol)
    ma = Multiaddr(*segments)
    if ma.is_incomplete and not allow_incomplete:
        raise err.ValueError(f&#34;Decoded multiaddr is incomplete: {str(ma)}&#34;)
    return ma


def decode(multiaddr_bytes: BytesLike) -&gt; Multiaddr:
    &#34;&#34;&#34;
        Decodes a multiaddr from its `(TLV)+` binary encoding.

        Example usage:

        ```py
        &gt;&gt;&gt; b = bytes.fromhex(&#39;047f00000191022382cc03&#39;)
        &gt;&gt;&gt; multiaddr.decode(b)
        Multiaddr(Addr(&#39;ip4&#39;, &#39;127.0.0.1&#39;), Addr(&#39;udp&#39;, &#39;9090&#39;), Proto(&#39;quic&#39;))
        ```
    &#34;&#34;&#34;
    validate(multiaddr_bytes, BytesLike)
    b = memoryview(multiaddr_bytes)
    segments: List[Union[Addr, Proto]] = []
    while len(b) &gt; 0:
        code, _, b = multicodec.unwrap_raw(b)
        protocol = Proto(code)
        if protocol.admits_addr:
            addr_size = protocol.addr_size
            if addr_size is None:
                addr_size, _, b = varint.decode_raw(b)
            addr_value_bytes = bytes(b[:addr_size])
            b = b[addr_size:]
            segments.append(protocol/addr_value_bytes)
        else:
            segments.append(protocol)
    ma = Multiaddr(*segments)
    assert not ma.is_incomplete
    return ma</code></pre>
</details>
</section>
<section>
<h2 class="section-title" id="header-submodules">Sub-modules</h2>
<dl>
<dt><code class="name"><a title="multiformats.multiaddr.err" href="err.html">multiformats.multiaddr.err</a></code></dt>
<dd>
<div class="desc"><p>Errors for the <code><a title="multiformats.multiaddr" href="#multiformats.multiaddr">multiformats.multiaddr</a></code> module.</p></div>
</dd>
<dt><code class="name"><a title="multiformats.multiaddr.raw" href="raw.html">multiformats.multiaddr.raw</a></code></dt>
<dd>
<div class="desc"><p>Implementation of raw encodings used by multiaddr protocols â€¦</p></div>
</dd>
</dl>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="multiformats.multiaddr.decode"><code class="name flex">
<span>def <span class="ident">decode</span></span>(<span>multiaddr_bytes:Â Union[bytes,Â bytearray,Â memoryview]) â€‘>Â <a title="multiformats.multiaddr.Multiaddr" href="#multiformats.multiaddr.Multiaddr">Multiaddr</a></span>
</code></dt>
<dd>
<div class="desc"><p>Decodes a multiaddr from its <code>(TLV)+</code> binary encoding.</p>
<p>Example usage:</p>
<pre><code class="language-py">&gt;&gt;&gt; b = bytes.fromhex('047f00000191022382cc03')
&gt;&gt;&gt; multiaddr.decode(b)
Multiaddr(Addr('ip4', '127.0.0.1'), Addr('udp', '9090'), Proto('quic'))
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def decode(multiaddr_bytes: BytesLike) -&gt; Multiaddr:
    &#34;&#34;&#34;
        Decodes a multiaddr from its `(TLV)+` binary encoding.

        Example usage:

        ```py
        &gt;&gt;&gt; b = bytes.fromhex(&#39;047f00000191022382cc03&#39;)
        &gt;&gt;&gt; multiaddr.decode(b)
        Multiaddr(Addr(&#39;ip4&#39;, &#39;127.0.0.1&#39;), Addr(&#39;udp&#39;, &#39;9090&#39;), Proto(&#39;quic&#39;))
        ```
    &#34;&#34;&#34;
    validate(multiaddr_bytes, BytesLike)
    b = memoryview(multiaddr_bytes)
    segments: List[Union[Addr, Proto]] = []
    while len(b) &gt; 0:
        code, _, b = multicodec.unwrap_raw(b)
        protocol = Proto(code)
        if protocol.admits_addr:
            addr_size = protocol.addr_size
            if addr_size is None:
                addr_size, _, b = varint.decode_raw(b)
            addr_value_bytes = bytes(b[:addr_size])
            b = b[addr_size:]
            segments.append(protocol/addr_value_bytes)
        else:
            segments.append(protocol)
    ma = Multiaddr(*segments)
    assert not ma.is_incomplete
    return ma</code></pre>
</details>
</dd>
<dt id="multiformats.multiaddr.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>multiaddr_str:Â str, allow_incomplete:Â boolÂ =Â False) â€‘>Â <a title="multiformats.multiaddr.Multiaddr" href="#multiformats.multiaddr.Multiaddr">Multiaddr</a></span>
</code></dt>
<dd>
<div class="desc"><p>Parses a multiaddr from its human-readable string representation.</p>
<p>Example usage:</p>
<pre><code class="language-py">&gt;&gt;&gt; s = '/ip4/127.0.0.1/udp/9090/quic'
&gt;&gt;&gt; multiaddr.parse(s)
Multiaddr(Addr('ip4', '127.0.0.1'), Addr('udp', '9090'), Proto('quic'))
</code></pre>
<p>Example usage with incomplete multiaddr:</p>
<pre><code class="language-py">&gt;&gt;&gt; s = '/ip4/127.0.0.1/udp'
&gt;&gt;&gt; multiaddr.parse(s)
err.ValueError: Decoded multiaddr is incomplete: /ip4/127.0.0.1/udp
&gt;&gt;&gt; multiaddr.parse(s, allow_incomplete=True)
Multiaddr(Addr('ip4', '127.0.0.1'), Proto('udp'))
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def parse(multiaddr_str: str, allow_incomplete: bool = False) -&gt; Multiaddr:
    &#34;&#34;&#34;
        Parses a multiaddr from its human-readable string representation.

        Example usage:

        ```py
        &gt;&gt;&gt; s = &#39;/ip4/127.0.0.1/udp/9090/quic&#39;
        &gt;&gt;&gt; multiaddr.parse(s)
        Multiaddr(Addr(&#39;ip4&#39;, &#39;127.0.0.1&#39;), Addr(&#39;udp&#39;, &#39;9090&#39;), Proto(&#39;quic&#39;))
        ```

        Example usage with incomplete multiaddr:

        ```py
        &gt;&gt;&gt; s = &#39;/ip4/127.0.0.1/udp&#39;
        &gt;&gt;&gt; multiaddr.parse(s)
        err.ValueError: Decoded multiaddr is incomplete: /ip4/127.0.0.1/udp
        &gt;&gt;&gt; multiaddr.parse(s, allow_incomplete=True)
        Multiaddr(Addr(&#39;ip4&#39;, &#39;127.0.0.1&#39;), Proto(&#39;udp&#39;))
        ```
    &#34;&#34;&#34;
    validate(multiaddr_str, str)
    validate(allow_incomplete, bool)
    tokens = multiaddr_str.split(&#34;/&#34;)
    protocol: Optional[Proto] = None
    segments: List[Union[Addr, Proto]] = []
    for token in islice(tokens, 1, None):
        if protocol is None:
            protocol = Proto(token)
            if not protocol.admits_addr:
                segments.append(protocol)
                protocol = None
        else:
            segments.append(protocol/token)
            protocol = None
    if protocol is not None:
        segments.append(protocol)
    ma = Multiaddr(*segments)
    if ma.is_incomplete and not allow_incomplete:
        raise err.ValueError(f&#34;Decoded multiaddr is incomplete: {str(ma)}&#34;)
    return ma</code></pre>
</details>
</dd>
<dt id="multiformats.multiaddr.proto"><code class="name flex">
<span>def <span class="ident">proto</span></span>(<span>codec:Â Union[str,Â int,Â <a title="multiformats.multicodec.Multicodec" href="../multicodec/index.html#multiformats.multicodec.Multicodec">Multicodec</a>]) â€‘>Â <a title="multiformats.multiaddr.Proto" href="#multiformats.multiaddr.Proto">Proto</a></span>
</code></dt>
<dd>
<div class="desc"><p>Convenience function to construct a <code><a title="multiformats.multiaddr.Proto" href="#multiformats.multiaddr.Proto">Proto</a></code> instance.</p>
<p>Example usage:</p>
<pre><code class="language-py">&gt;&gt;&gt; ip4 = multiaddr.proto(&quot;ip4&quot;)
&gt;&gt;&gt; ip4
Proto(&quot;ip4&quot;)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def proto(codec: Union[str, int, Multicodec]) -&gt; Proto:
    &#34;&#34;&#34;
        Convenience function to construct a `Proto` instance.

        Example usage:

        ```py
        &gt;&gt;&gt; ip4 = multiaddr.proto(&#34;ip4&#34;)
        &gt;&gt;&gt; ip4
        Proto(&#34;ip4&#34;)
        ```
    &#34;&#34;&#34;
    return Proto(codec)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="multiformats.multiaddr.Addr"><code class="flex name class">
<span>class <span class="ident">Addr</span></span>
<span>(</span><span>proto:Â Union[str,Â int,Â <a title="multiformats.multicodec.Multicodec" href="../multicodec/index.html#multiformats.multicodec.Multicodec">Multicodec</a>,Â <a title="multiformats.multiaddr.Proto" href="#multiformats.multiaddr.Proto">Proto</a>], value:Â Union[str,Â bytes,Â bytearray,Â memoryview])</span>
</code></dt>
<dd>
<div class="desc"><p>Container class for a single protocol address in a <a href="https://multiformats.io/multiaddr/">multiaddr</a>.</p>
<pre><code class="language-py">&gt;&gt;&gt; a = Addr('ip4', '192.168.1.1')
&gt;&gt;&gt; a
Addr('ip4', '192.168.1.1')
&gt;&gt;&gt; str(a)
'/ip4/192.168.1.1'
</code></pre>
<p>The slash notation provides a more literate way to construct protocol addresses:</p>
<pre><code class="language-py">&gt;&gt;&gt; a = ip4/&quot;192.168.1.1&quot;
&gt;&gt;&gt; a
Addr('ip4', '192.168.1.1')
</code></pre>
<p>Bytes for protocol addresses are computed according to the TLV <a href="https://multiformats.io/multiaddr/">multiaddr format</a>:</p>
<pre><code class="language-py">&gt;&gt;&gt; bytes(ip4/&quot;127.0.0.1&quot;).hex()
'047f000001'
&gt;&gt;&gt; varint.encode(ip4.code).hex()
'04'
&gt;&gt;&gt; bytes([127, 0, 0, 1]).hex()
  '7f000001'
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Addr:
    &#34;&#34;&#34;
        Container class for a single protocol address in a [multiaddr](https://multiformats.io/multiaddr/).

        ```py
        &gt;&gt;&gt; a = Addr(&#39;ip4&#39;, &#39;192.168.1.1&#39;)
        &gt;&gt;&gt; a
        Addr(&#39;ip4&#39;, &#39;192.168.1.1&#39;)
        &gt;&gt;&gt; str(a)
        &#39;/ip4/192.168.1.1&#39;
        ```

        The slash notation provides a more literate way to construct protocol addresses:

        ```py
        &gt;&gt;&gt; a = ip4/&#34;192.168.1.1&#34;
        &gt;&gt;&gt; a
        Addr(&#39;ip4&#39;, &#39;192.168.1.1&#39;)
        ```

        Bytes for protocol addresses are computed according to the TLV [multiaddr format](https://multiformats.io/multiaddr/):

        ```py
        &gt;&gt;&gt; bytes(ip4/&#34;127.0.0.1&#34;).hex()
        &#39;047f000001&#39;
        &gt;&gt;&gt; varint.encode(ip4.code).hex()
        &#39;04&#39;
        &gt;&gt;&gt; bytes([127, 0, 0, 1]).hex()
          &#39;7f000001&#39;
        ```
    &#34;&#34;&#34;

    _proto: Proto
    _value: str
    _value_bytes: bytes

    __slots__ = (&#34;__weakref__&#34;, &#34;_proto&#34;, &#34;_value&#34;, &#34;_value_bytes&#34;)

    def __new__(cls, proto: Union[str, int, Multicodec, Proto], value: Union[str, BytesLike]) -&gt; &#34;Addr&#34;:
        if not isinstance(proto, Proto):
            proto = Proto(proto)
        value, value_bytes = proto.validate(value)
        instance: Addr = super().__new__(cls)
        instance._proto = proto
        instance._value = value
        instance._value_bytes = value_bytes
        return instance

    @property
    def proto(self) -&gt; Proto:
        &#34;&#34;&#34;
            The address protocol.

            Example usage:

            ```py
            &gt;&gt;&gt; a = Addr(&#39;ip4&#39;, &#39;192.168.1.1&#39;)
            &gt;&gt;&gt; a.proto
            Proto(&#39;ip4&#39;)
            ```
        &#34;&#34;&#34;
        return self._proto

    @property
    def value(self) -&gt; str:
        &#34;&#34;&#34;
            The address value, as a string.

            Example usage:

            ```py
            &gt;&gt;&gt; a = Addr(&#39;ip4&#39;, &#39;192.168.1.1&#39;)
            &gt;&gt;&gt; a.value
            &#39;192.168.1.1&#39;
            ```
        &#34;&#34;&#34;
        return self._value

    @property
    def value_bytes(self) -&gt; bytes:
        &#34;&#34;&#34;
            The address value, as bytes.

            Example usage:

            ```py
            &gt;&gt;&gt; a = Addr(&#39;ip4&#39;, &#39;192.168.1.1&#39;)
            &gt;&gt;&gt; a.value_bytes
            b&#39;\\xc0\\xa8\\x01\\x01&#39;
            &gt;&gt;&gt; list(a.value_bytes)
            [192, 168, 1, 1]
            ```
        &#34;&#34;&#34;
        return self._value_bytes

    def __truediv__(self, other: Union[Proto, &#34;Addr&#34;, &#34;Multiaddr&#34;]) -&gt; &#34;Multiaddr&#34;:
        if isinstance(other, (Addr, Proto)):
            return Multiaddr(self, other)
        if isinstance(other, Multiaddr):
            return Multiaddr(self, *other)
        return NotImplemented

    def __str__(self) -&gt; str:
        return f&#34;{str(self.proto)}/{self.value}&#34;

    def __bytes__(self) -&gt; bytes:
        proto = self.proto
        value_bytes = self.value_bytes
        if proto.addr_size is None:
            assert value_bytes is not None
            l = varint.encode(len(value_bytes))
            return proto.codec.wrap(l+value_bytes)
        return proto.codec.wrap(value_bytes)

    def __repr__(self) -&gt; str:
        return f&#34;Addr({repr(self.proto.name)}, {repr(self.value)})&#34;

    @property
    def _as_tuple(self) -&gt; Tuple[Type[&#34;Addr&#34;], Proto, Optional[str]]:
        return (Addr, self.proto, self.value)

    def __hash__(self) -&gt; int:
        return hash(self._as_tuple)

    def __eq__(self, other: Any) -&gt; bool:
        if self is other:
            return True
        if not isinstance(other, Addr):
            return NotImplemented
        return self._as_tuple == other._as_tuple</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="multiformats.multiaddr.Addr.proto"><code class="name">var <span class="ident">proto</span> :Â <a title="multiformats.multiaddr.Proto" href="#multiformats.multiaddr.Proto">Proto</a></code></dt>
<dd>
<div class="desc"><p>The address protocol.</p>
<p>Example usage:</p>
<pre><code class="language-py">&gt;&gt;&gt; a = Addr('ip4', '192.168.1.1')
&gt;&gt;&gt; a.proto
Proto('ip4')
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def proto(self) -&gt; Proto:
    &#34;&#34;&#34;
        The address protocol.

        Example usage:

        ```py
        &gt;&gt;&gt; a = Addr(&#39;ip4&#39;, &#39;192.168.1.1&#39;)
        &gt;&gt;&gt; a.proto
        Proto(&#39;ip4&#39;)
        ```
    &#34;&#34;&#34;
    return self._proto</code></pre>
</details>
</dd>
<dt id="multiformats.multiaddr.Addr.value"><code class="name">var <span class="ident">value</span> :Â str</code></dt>
<dd>
<div class="desc"><p>The address value, as a string.</p>
<p>Example usage:</p>
<pre><code class="language-py">&gt;&gt;&gt; a = Addr('ip4', '192.168.1.1')
&gt;&gt;&gt; a.value
'192.168.1.1'
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def value(self) -&gt; str:
    &#34;&#34;&#34;
        The address value, as a string.

        Example usage:

        ```py
        &gt;&gt;&gt; a = Addr(&#39;ip4&#39;, &#39;192.168.1.1&#39;)
        &gt;&gt;&gt; a.value
        &#39;192.168.1.1&#39;
        ```
    &#34;&#34;&#34;
    return self._value</code></pre>
</details>
</dd>
<dt id="multiformats.multiaddr.Addr.value_bytes"><code class="name">var <span class="ident">value_bytes</span> :Â bytes</code></dt>
<dd>
<div class="desc"><p>The address value, as bytes.</p>
<p>Example usage:</p>
<pre><code class="language-py">&gt;&gt;&gt; a = Addr('ip4', '192.168.1.1')
&gt;&gt;&gt; a.value_bytes
b'\xc0\xa8\x01\x01'
&gt;&gt;&gt; list(a.value_bytes)
[192, 168, 1, 1]
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def value_bytes(self) -&gt; bytes:
    &#34;&#34;&#34;
        The address value, as bytes.

        Example usage:

        ```py
        &gt;&gt;&gt; a = Addr(&#39;ip4&#39;, &#39;192.168.1.1&#39;)
        &gt;&gt;&gt; a.value_bytes
        b&#39;\\xc0\\xa8\\x01\\x01&#39;
        &gt;&gt;&gt; list(a.value_bytes)
        [192, 168, 1, 1]
        ```
    &#34;&#34;&#34;
    return self._value_bytes</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="multiformats.multiaddr.Multiaddr"><code class="flex name class">
<span>class <span class="ident">Multiaddr</span></span>
<span>(</span><span>*addrs:Â Union[<a title="multiformats.multiaddr.Addr" href="#multiformats.multiaddr.Addr">Addr</a>,Â <a title="multiformats.multiaddr.Proto" href="#multiformats.multiaddr.Proto">Proto</a>])</span>
</code></dt>
<dd>
<div class="desc"><p>Container class for a <a href="https://multiformats.io/multiaddr/">multiaddr</a>.</p>
<p>Example usage:</p>
<pre><code class="language-py">&gt;&gt;&gt; ip4 = Proto(&quot;ip4&quot;)
&gt;&gt;&gt; udp = Proto(&quot;udp&quot;)
&gt;&gt;&gt; quic = Proto(&quot;quic&quot;)
&gt;&gt;&gt; ma = ip4/&quot;127.0.0.1&quot;/udp/9090/quic
&gt;&gt;&gt; ma
Multiaddr(Addr('ip4', '127.0.0.1'), Addr('udp', '9090'), Proto('quic'))
&gt;&gt;&gt; str(ma)
'/ip4/127.0.0.1/udp/9090/quic'
</code></pre>
<p>Bytes for multiaddrs are computed according to the (TLV)+ <a href="https://multiformats.io/multiaddr/">multiaddr format</a>:</p>
<pre><code class="language-py">&gt;&gt;&gt; bytes(ip4/&quot;127.0.0.1&quot;).hex()
'047f000001'
&gt;&gt;&gt; bytes(udp/9090).hex()
          '91022382'
&gt;&gt;&gt; bytes(quic).hex()
                  'cc03'
&gt;&gt;&gt; bytes(ma).hex()
'047f00000191022382cc03'
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Multiaddr(Sequence[Union[Addr, Proto]]):
    &#34;&#34;&#34;
        Container class for a [multiaddr](https://multiformats.io/multiaddr/).

        Example usage:

        ```py
        &gt;&gt;&gt; ip4 = Proto(&#34;ip4&#34;)
        &gt;&gt;&gt; udp = Proto(&#34;udp&#34;)
        &gt;&gt;&gt; quic = Proto(&#34;quic&#34;)
        &gt;&gt;&gt; ma = ip4/&#34;127.0.0.1&#34;/udp/9090/quic
        &gt;&gt;&gt; ma
        Multiaddr(Addr(&#39;ip4&#39;, &#39;127.0.0.1&#39;), Addr(&#39;udp&#39;, &#39;9090&#39;), Proto(&#39;quic&#39;))
        &gt;&gt;&gt; str(ma)
        &#39;/ip4/127.0.0.1/udp/9090/quic&#39;
        ```

        Bytes for multiaddrs are computed according to the (TLV)+ [multiaddr format](https://multiformats.io/multiaddr/):

        ```py
        &gt;&gt;&gt; bytes(ip4/&#34;127.0.0.1&#34;).hex()
        &#39;047f000001&#39;
        &gt;&gt;&gt; bytes(udp/9090).hex()
                  &#39;91022382&#39;
        &gt;&gt;&gt; bytes(quic).hex()
                          &#39;cc03&#39;
        &gt;&gt;&gt; bytes(ma).hex()
        &#39;047f00000191022382cc03&#39;
        ```
    &#34;&#34;&#34;

    _addrs: Tuple[Union[Addr, Proto], ...]
    _proto_map: Dict[Proto, int]
    _is_incomplete: bool

    __slots__ = (&#34;__weakref__&#34;, &#34;_addrs&#34;, &#34;_proto_map&#34;, &#34;_is_incomplete&#34;)

    def __new__(cls, *addrs: Union[Addr, Proto]) -&gt; &#34;Multiaddr&#34;:
        l = len(addrs)
        is_incomplete = False
        proto_map: Dict[Proto, int] = {}
        for idx, addr in enumerate(addrs):
            if isinstance(addr, Proto):
                proto = addr
                if proto.addr_size != 0:
                    if idx == l-1:
                        is_incomplete = True
                    else:
                        raise err.ValueError(f&#34;Protocol {repr(proto.name)} expects an address, but is followed by another protocol instead.&#34;)
            else:
                validate(addr, Addr)
                proto = addr.proto
            if proto in proto_map:
                raise err.ValueError(f&#34;Protocol {repr(proto.name)} appears twice in multiaddr.&#34;)
            proto_map[proto] = idx
        instance: Multiaddr = super().__new__(cls)
        instance._addrs = addrs
        instance._proto_map = proto_map
        instance._is_incomplete = is_incomplete
        return instance

    @property
    def is_incomplete(self) -&gt; bool:
        &#34;&#34;&#34;
            Whether this multiaddress is incomplete, i.e. it still requires an address for
            the last protocol in the sequence.

            ```py
            &gt;&gt;&gt; ma = ip4/&#34;127.0.0.1&#34;/udp
            &gt;&gt;&gt; ma.is_incomplete
            True
            &gt;&gt;&gt; str(ma)
            &#39;/ip4/127.0.0.1/udp&#39;
            &gt;&gt;&gt; ma2 = ma/9090
            &gt;&gt;&gt; str(ma2)
            &#39;/ip4/127.0.0.1/udp/9090&#39;
            &gt;&gt;&gt; ma2.is_incomplete
            False
            ```

            Incomplete multiaddrs don&#39;t admit a byte representation:

            ```py
            &gt;&gt;&gt; bytes(ma)
            err.ValueError: Missing address value for last protocol, cannot compute bytes.
            &gt;&gt;&gt; bytes(ma2).hex()
            &#39;047f00000191022382&#39;
            ```
        &#34;&#34;&#34;
        return self._is_incomplete

    def index(self, value: Union[Addr, Proto], start: int = 0, stop: Optional[int] = None) -&gt; int:
        &#34;&#34;&#34;
            Returns the unique index at which a protocol/address appears in the multiaddress:

            ```py
            &gt;&gt;&gt; ma = ip4/&#34;127.0.0.1&#34;/udp/9090/quic
            &gt;&gt;&gt; str(ma)
            &#39;/ip4/127.0.0.1/udp/9090/quic&#39;
            &gt;&gt;&gt; udp in ma
            True
            &gt;&gt;&gt; ma.index(udp)
            1
            &gt;&gt;&gt; ma[ma.index(udp)]
            Addr(&#39;udp&#39;, &#39;9090&#39;)
            &gt;&gt;&gt; ip4/&#34;127.0.0.1&#34; in ma
            True
            &gt;&gt;&gt; ma.index(ip4/&#34;127.0.0.1&#34; in ma)
            0
            ```

            This method raises `err.ValueError` if the protocol/address does not appear:

            ```py
            &gt;&gt;&gt; ip6 = Proto(&#34;ip6&#34;)
            &gt;&gt;&gt; ip6 in ma
            False
            &gt;&gt;&gt; ma.index(ip6)
            err.ValueError: Protocol &#39;ip6&#39; does not appear in multiaddr /ip4/127.0.0.1/udp/9090/quic
            &gt;&gt;&gt; ip4/&#34;127.0.0.2&#34; in ma
            False
            &gt;&gt;&gt; ma.index(ip4/&#34;127.0.0.2&#34;)
            err.ValueError: Address Addr(&#39;ip4&#39;, &#39;127.0.0.2&#39;) does not appear in multiaddr /ip4/127.0.0.1/udp/9090/quic
            ```

            The optional `start` and `stop` arguments can be used to specify a range of indices
            within which to search for the protocol/address.

            ```py
            &gt;&gt;&gt; ip4/&#34;127.0.0.1&#34; in ma
            True
            &gt;&gt;&gt; ma.index(ip4/&#34;127.0.0.1&#34;)
            0
            &gt;&gt;&gt; ma.index(ip4/&#34;127.0.0.1&#34;, start=1)
            err.ValueError: Address Addr(&#39;ip4&#39;, &#39;127.0.0.1&#39;) does not appear in sub-multiaddr /udp/9090/quic of multiaddr /ip4/127.0.0.1/udp/9090/quic
            ```
        &#34;&#34;&#34;
        validate(start, int)
        if stop is None:
            stop = len(self)
        validate(stop, int)
        if isinstance(value, Proto):
            proto = value
        else:
            validate(value, Addr)
            proto = value.proto
        if proto not in self._proto_map:
            raise err.ValueError(f&#34;Protocol {repr(proto.name)} does not appear in multiaddr {str(self)}&#34;)
        idx = self._proto_map[proto]
        if isinstance(value, Addr):
            if self[idx] != value:
                raise err.ValueError(f&#34;Address {repr(value)} does not appear in multiaddr {str(self)}&#34;)
            if not start &lt;= idx &lt; stop:
                raise err.ValueError(f&#34;Address {repr(value)} does not appear in sub-multiaddr {str(self[start:stop])} &#34;
                                 f&#34;of multiaddr {str(self)}&#34;)
        return idx

    def __contains__(self, value: Any) -&gt; bool:
        if isinstance(value, (Addr, Proto)):
            try:
                self.index(value)
                return True
            except err.ValueError:
                return False
        return False

    def __len__(self) -&gt; int:
        return len(self._addrs)

    def __iter__(self) -&gt; Iterator[Union[Addr, Proto]]:
        return iter(self._addrs)

    @overload
    def __getitem__(self, idx: int) -&gt; Union[Addr, Proto]:
        ...

    @overload
    def __getitem__(self, idx: slice) -&gt; &#34;Multiaddr&#34;:
        ...

    def __getitem__(self, idx: Union[int, slice]) -&gt; Union[Addr, Proto, &#34;Multiaddr&#34;]:
        if isinstance(idx, int):
            return self._addrs[idx]
        validate(idx, slice)
        return Multiaddr(*self._addrs[idx])

    def __truediv__(self, other: Union[int, str, BytesLike, Addr, Proto, &#34;Multiaddr&#34;]) -&gt; &#34;Multiaddr&#34;:
        if isinstance(other, (int, str,)+byteslike):
            if not self.is_incomplete:
                raise err.ValueError(&#34;Unexpected address value. Expected Proto, Addr or Multiaddr.&#34;)
            addrs = list(self)
            tail_proto = addrs[-1]
            assert isinstance(tail_proto, Proto)
            return Multiaddr(*islice(addrs, 0, len(addrs)-1), tail_proto/other)
        if isinstance(other, (Addr, Proto)):
            if self.is_incomplete:
                raise err.ValueError(&#34;Expected address value (string or binary).&#34;)
            return Multiaddr(*self, other)
        if isinstance(other, Multiaddr):
            if self.is_incomplete:
                raise err.ValueError(&#34;Expected address value (string or binary).&#34;)
            return Multiaddr(*self, *other)
        return NotImplemented

    def __str__(self) -&gt; str:
        return &#34;&#34;.join(str(a) for a in self)

    def __bytes__(self) -&gt; bytes:
        if self.is_incomplete:
            raise err.ValueError(&#34;Missing address value for last protocol, cannot compute bytes.&#34;)
        return bytes(chain.from_iterable(bytes(addr) for addr in self))

    def __repr__(self) -&gt; str:
        return f&#34;Multiaddr({&#39;, &#39;.join(repr(a) for a in self)})&#34;

    @property
    def _as_tuple(self) -&gt; Tuple[Type[&#34;Multiaddr&#34;], Tuple[Union[Addr, Proto], ...]]:
        return (Multiaddr, self._addrs)

    def __hash__(self) -&gt; int:
        return hash(self._as_tuple)

    def __eq__(self, other: Any) -&gt; bool:
        if self is other:
            return True
        if not isinstance(other, Multiaddr):
            return NotImplemented
        return self._as_tuple == other._as_tuple</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>collections.abc.Sequence</li>
<li>collections.abc.Reversible</li>
<li>collections.abc.Collection</li>
<li>collections.abc.Sized</li>
<li>collections.abc.Iterable</li>
<li>collections.abc.Container</li>
<li>typing.Generic</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="multiformats.multiaddr.Multiaddr.is_incomplete"><code class="name">var <span class="ident">is_incomplete</span> :Â bool</code></dt>
<dd>
<div class="desc"><p>Whether this multiaddress is incomplete, i.e. it still requires an address for
the last protocol in the sequence.</p>
<pre><code class="language-py">&gt;&gt;&gt; ma = ip4/&quot;127.0.0.1&quot;/udp
&gt;&gt;&gt; ma.is_incomplete
True
&gt;&gt;&gt; str(ma)
'/ip4/127.0.0.1/udp'
&gt;&gt;&gt; ma2 = ma/9090
&gt;&gt;&gt; str(ma2)
'/ip4/127.0.0.1/udp/9090'
&gt;&gt;&gt; ma2.is_incomplete
False
</code></pre>
<p>Incomplete multiaddrs don't admit a byte representation:</p>
<pre><code class="language-py">&gt;&gt;&gt; bytes(ma)
err.ValueError: Missing address value for last protocol, cannot compute bytes.
&gt;&gt;&gt; bytes(ma2).hex()
'047f00000191022382'
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def is_incomplete(self) -&gt; bool:
    &#34;&#34;&#34;
        Whether this multiaddress is incomplete, i.e. it still requires an address for
        the last protocol in the sequence.

        ```py
        &gt;&gt;&gt; ma = ip4/&#34;127.0.0.1&#34;/udp
        &gt;&gt;&gt; ma.is_incomplete
        True
        &gt;&gt;&gt; str(ma)
        &#39;/ip4/127.0.0.1/udp&#39;
        &gt;&gt;&gt; ma2 = ma/9090
        &gt;&gt;&gt; str(ma2)
        &#39;/ip4/127.0.0.1/udp/9090&#39;
        &gt;&gt;&gt; ma2.is_incomplete
        False
        ```

        Incomplete multiaddrs don&#39;t admit a byte representation:

        ```py
        &gt;&gt;&gt; bytes(ma)
        err.ValueError: Missing address value for last protocol, cannot compute bytes.
        &gt;&gt;&gt; bytes(ma2).hex()
        &#39;047f00000191022382&#39;
        ```
    &#34;&#34;&#34;
    return self._is_incomplete</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="multiformats.multiaddr.Multiaddr.index"><code class="name flex">
<span>def <span class="ident">index</span></span>(<span>self, value:Â Union[<a title="multiformats.multiaddr.Addr" href="#multiformats.multiaddr.Addr">Addr</a>,Â <a title="multiformats.multiaddr.Proto" href="#multiformats.multiaddr.Proto">Proto</a>], start:Â intÂ =Â 0, stop:Â Optional[None]Â =Â None) â€‘>Â int</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the unique index at which a protocol/address appears in the multiaddress:</p>
<pre><code class="language-py">&gt;&gt;&gt; ma = ip4/&quot;127.0.0.1&quot;/udp/9090/quic
&gt;&gt;&gt; str(ma)
'/ip4/127.0.0.1/udp/9090/quic'
&gt;&gt;&gt; udp in ma
True
&gt;&gt;&gt; ma.index(udp)
1
&gt;&gt;&gt; ma[ma.index(udp)]
Addr('udp', '9090')
&gt;&gt;&gt; ip4/&quot;127.0.0.1&quot; in ma
True
&gt;&gt;&gt; ma.index(ip4/&quot;127.0.0.1&quot; in ma)
0
</code></pre>
<p>This method raises <code><a title="multiformats.multiaddr.err.ValueError" href="err.html#multiformats.multiaddr.err.ValueError">ValueError</a></code> if the protocol/address does not appear:</p>
<pre><code class="language-py">&gt;&gt;&gt; ip6 = Proto(&quot;ip6&quot;)
&gt;&gt;&gt; ip6 in ma
False
&gt;&gt;&gt; ma.index(ip6)
err.ValueError: Protocol 'ip6' does not appear in multiaddr /ip4/127.0.0.1/udp/9090/quic
&gt;&gt;&gt; ip4/&quot;127.0.0.2&quot; in ma
False
&gt;&gt;&gt; ma.index(ip4/&quot;127.0.0.2&quot;)
err.ValueError: Address Addr('ip4', '127.0.0.2') does not appear in multiaddr /ip4/127.0.0.1/udp/9090/quic
</code></pre>
<p>The optional <code>start</code> and <code>stop</code> arguments can be used to specify a range of indices
within which to search for the protocol/address.</p>
<pre><code class="language-py">&gt;&gt;&gt; ip4/&quot;127.0.0.1&quot; in ma
True
&gt;&gt;&gt; ma.index(ip4/&quot;127.0.0.1&quot;)
0
&gt;&gt;&gt; ma.index(ip4/&quot;127.0.0.1&quot;, start=1)
err.ValueError: Address Addr('ip4', '127.0.0.1') does not appear in sub-multiaddr /udp/9090/quic of multiaddr /ip4/127.0.0.1/udp/9090/quic
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def index(self, value: Union[Addr, Proto], start: int = 0, stop: Optional[int] = None) -&gt; int:
    &#34;&#34;&#34;
        Returns the unique index at which a protocol/address appears in the multiaddress:

        ```py
        &gt;&gt;&gt; ma = ip4/&#34;127.0.0.1&#34;/udp/9090/quic
        &gt;&gt;&gt; str(ma)
        &#39;/ip4/127.0.0.1/udp/9090/quic&#39;
        &gt;&gt;&gt; udp in ma
        True
        &gt;&gt;&gt; ma.index(udp)
        1
        &gt;&gt;&gt; ma[ma.index(udp)]
        Addr(&#39;udp&#39;, &#39;9090&#39;)
        &gt;&gt;&gt; ip4/&#34;127.0.0.1&#34; in ma
        True
        &gt;&gt;&gt; ma.index(ip4/&#34;127.0.0.1&#34; in ma)
        0
        ```

        This method raises `err.ValueError` if the protocol/address does not appear:

        ```py
        &gt;&gt;&gt; ip6 = Proto(&#34;ip6&#34;)
        &gt;&gt;&gt; ip6 in ma
        False
        &gt;&gt;&gt; ma.index(ip6)
        err.ValueError: Protocol &#39;ip6&#39; does not appear in multiaddr /ip4/127.0.0.1/udp/9090/quic
        &gt;&gt;&gt; ip4/&#34;127.0.0.2&#34; in ma
        False
        &gt;&gt;&gt; ma.index(ip4/&#34;127.0.0.2&#34;)
        err.ValueError: Address Addr(&#39;ip4&#39;, &#39;127.0.0.2&#39;) does not appear in multiaddr /ip4/127.0.0.1/udp/9090/quic
        ```

        The optional `start` and `stop` arguments can be used to specify a range of indices
        within which to search for the protocol/address.

        ```py
        &gt;&gt;&gt; ip4/&#34;127.0.0.1&#34; in ma
        True
        &gt;&gt;&gt; ma.index(ip4/&#34;127.0.0.1&#34;)
        0
        &gt;&gt;&gt; ma.index(ip4/&#34;127.0.0.1&#34;, start=1)
        err.ValueError: Address Addr(&#39;ip4&#39;, &#39;127.0.0.1&#39;) does not appear in sub-multiaddr /udp/9090/quic of multiaddr /ip4/127.0.0.1/udp/9090/quic
        ```
    &#34;&#34;&#34;
    validate(start, int)
    if stop is None:
        stop = len(self)
    validate(stop, int)
    if isinstance(value, Proto):
        proto = value
    else:
        validate(value, Addr)
        proto = value.proto
    if proto not in self._proto_map:
        raise err.ValueError(f&#34;Protocol {repr(proto.name)} does not appear in multiaddr {str(self)}&#34;)
    idx = self._proto_map[proto]
    if isinstance(value, Addr):
        if self[idx] != value:
            raise err.ValueError(f&#34;Address {repr(value)} does not appear in multiaddr {str(self)}&#34;)
        if not start &lt;= idx &lt; stop:
            raise err.ValueError(f&#34;Address {repr(value)} does not appear in sub-multiaddr {str(self[start:stop])} &#34;
                             f&#34;of multiaddr {str(self)}&#34;)
    return idx</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="multiformats.multiaddr.Proto"><code class="flex name class">
<span>class <span class="ident">Proto</span></span>
<span>(</span><span>codec:Â Union[str,Â int,Â <a title="multiformats.multicodec.Multicodec" href="../multicodec/index.html#multiformats.multicodec.Multicodec">Multicodec</a>])</span>
</code></dt>
<dd>
<div class="desc"><p>Container class for a single protocol segment of a <a href="https://multiformats.io/multiaddr/">multiaddr</a>.</p>
<pre><code class="language-py">&gt;&gt;&gt; ip4 = Proto(&quot;ip4&quot;)
&gt;&gt;&gt; ip4
Proto(&quot;ip4&quot;)
&gt;&gt;&gt; str(ip4)
'/ip4'
</code></pre>
<p>For protocols that don't require an address value, bytes are computed as the varint encoding of protocl code:</p>
<pre><code class="language-py">&gt;&gt;&gt; quic = Proto('quic')
&gt;&gt;&gt; quic.code
460
&gt;&gt;&gt; varint.encode(quic.code).hex()
'cc03'
&gt;&gt;&gt; bytes(quic).hex()
'cc03'
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Proto:
    &#34;&#34;&#34;
        Container class for a single protocol segment of a [multiaddr](https://multiformats.io/multiaddr/).

        ```py
        &gt;&gt;&gt; ip4 = Proto(&#34;ip4&#34;)
        &gt;&gt;&gt; ip4
        Proto(&#34;ip4&#34;)
        &gt;&gt;&gt; str(ip4)
        &#39;/ip4&#39;
        ```

        For protocols that don&#39;t require an address value, bytes are computed as the varint encoding of protocl code:

        ```py
        &gt;&gt;&gt; quic = Proto(&#39;quic&#39;)
        &gt;&gt;&gt; quic.code
        460
        &gt;&gt;&gt; varint.encode(quic.code).hex()
        &#39;cc03&#39;
        &gt;&gt;&gt; bytes(quic).hex()
        &#39;cc03&#39;
        ```
    &#34;&#34;&#34;

    # WeakValueDictionary[str, &#34;Proto&#34;]
    _cache: ClassVar[WeakValueDictionary] = WeakValueDictionary() # type: ignore

    _codec: Multicodec
    _implementation: ProtoImpl

    __slots__ = (&#34;__weakref__&#34;, &#34;_codec&#34;, &#34;_implementation&#34;)

    def __new__(cls, codec: Union[str, int, Multicodec]) -&gt; &#34;Proto&#34;:
        # check that the codec exists:
        if isinstance(codec, str):
            codec = multicodec.get(codec)
        elif isinstance(codec, int):
            codec = multicodec.get(code=codec)
        else:
            validate(codec, Multicodec)
            existing_codec = multicodec.get(codec.name)
            if existing_codec != codec:
                raise err.ValueError(f&#34;Multicodec named {repr(codec.name)} exists, but is not the one given.&#34;)
            codec = existing_codec
        # check that the codec is a multiaddr multicodec:
        if codec.tag != &#34;multiaddr&#34;:
            raise err.ValueError(f&#34;Multicodec named {repr(codec.name)} exists, but is not a multiaddr.&#34;)
        implementation: ProtoImpl = raw.get(codec.name)
        _cache = Proto._cache
        if codec.name in _cache:
            # if a proto instance with this name is already registered
            instance: Proto = _cache[codec.name]
            if instance._codec == codec and instance._implementation == implementation:
                # nothing changed, can use the existing instance
                return instance
            # otherwise remove the existing instance
            del _cache[codec.name]
        # create a fresh instance, register it and return it
        instance = super().__new__(cls)
        instance._codec = codec
        instance._implementation = implementation
        _cache[codec.name] = instance
        return instance

    @property
    def name(self) -&gt; str:
        &#34;&#34;&#34;
            Protocol name.

            Example usage:

            ```py
            &gt;&gt;&gt; ip4.name
            &#39;ip4&#39;
            ```
        &#34;&#34;&#34;
        return self.codec.name

    @property
    def code(self) -&gt; int:
        &#34;&#34;&#34;
            Protocol code.

            Example usage:

            ```py
            &gt;&gt;&gt; ip4.code
            4
            # 4 = 0x04
            ```
        &#34;&#34;&#34;
        return self.codec.code

    @property
    def codec(self) -&gt; Multicodec:
        &#34;&#34;&#34;
            The multicodec for this protocol.

            Example usage:

            ```py
            &gt;&gt;&gt; ip4.codec
            Multicodec(name=&#39;ip4&#39;, tag=&#39;multiaddr&#39;, code=&#39;0x04&#39;,
                       status=&#39;permanent&#39;, description=&#39;&#39;)
            ```
        &#34;&#34;&#34;
        return self._codec

    @property
    def implementation(self) -&gt; ProtoImpl:
        &#34;&#34;&#34;
            The implementation for this protocol, as a triple of
            raw encoder, raw decoder and address size.

            Example usage:

            ```py
            &gt;&gt;&gt; ip4.implementation
            (
             &lt;function ip4_encoder at 0x000002B4C9956310&gt;,
             &lt;function ip4_decoder at 0x000002B4C99563A0&gt;,
             4
            )
            ```
        &#34;&#34;&#34;
        return self._implementation

    @property
    def raw_encoder(self) -&gt; Optional[RawEncoder]:
        &#34;&#34;&#34;
            The raw encoder for this protocol.

            Example usage:

            ```py
            &gt;&gt;&gt; ip4.raw_encoder
            &lt;function ip4_encoder at 0x000002B4C9956310&gt;
            ```
        &#34;&#34;&#34;
        return self.implementation[0]

    @property
    def raw_decoder(self) -&gt; Optional[RawDecoder]:
        &#34;&#34;&#34;
            The raw decoder for this protocol.

            Example usage:

            ```py
            &gt;&gt;&gt; ip4.raw_decoder
            &lt;function ip4_decoder at 0x000002B4C99563A0&gt;
            ```
        &#34;&#34;&#34;
        return self.implementation[1]

    @property
    def addr_size(self) -&gt; Optional[int]:
        &#34;&#34;&#34;
            The address size (in bytes) for this protocol:

            - for protocols with no address, `addr_size` is 0
            - for protocols with addresses of variable binary size, `addr_size` is `None`
            - for all other protocols, size is a positive `int`

            Example usage:

            ```py
            &gt;&gt;&gt; ip4.addr_size
            4
            ```
        &#34;&#34;&#34;
        return self.implementation[2]

    @property
    def admits_addr(self) -&gt; bool:
        &#34;&#34;&#34;
            Whether this protocol admits an address.

            ```py
            &gt;&gt;&gt; ip4.admits_addr
            True
            ```
        &#34;&#34;&#34;
        return self.addr_size != 0

    def is_addr_valid(self, addr_value: Union[str, BytesLike]) -&gt; bool:
        &#34;&#34;&#34;
            Validates an address value.

            Example usage:

            ```py
            &gt;&gt;&gt; ip4.is_addr_valid(&#34;192.168.1.1&#34;)
            True
            &gt;&gt;&gt; ip4.is_addr_valid(bytes([192, 168, 1, 1]))
            True
            ```

            The same result can be obtained with container syntax:

            ```py
            &gt;&gt;&gt; &#34;192.168.1.1&#34; in ip4
            True
            &gt;&gt;&gt; bytes([192, 168, 1, 1]) in ip4
            True
            ```
        &#34;&#34;&#34;
        try:
            self.validate(addr_value)
            return True
        except err.ValueError:
            return False

    def validate(self, addr_value: Union[str, BytesLike]) -&gt; Tuple[str, bytes]:
        &#34;&#34;&#34;
            Raises `err.ValueError` if `not self.is_valid(addr_value)`.
            If successful, returns a pair of the string and bytes representations of the address value.

            Example usage:

            ```py
            &gt;&gt;&gt; ip4.validate(&#34;192.168.1.1&#34;)
            (&#39;192.168.1.1&#39;, b&#39;\\xc0\\xa8\\x01\\x01&#39;)
            &gt;&gt;&gt; ip4.validate(&#34;192.168&#34;)
            err.ValueError: Expected 4 octets in &#39;192.168&#39;
            ```
        &#34;&#34;&#34;
        raw_encoder, raw_decoder, addr_size = self.implementation
        if addr_size == 0:
            raise err.ValueError(f&#34;Protocol admits no address value, but {repr(addr_value)} was passed.&#34;)
        if isinstance(addr_value, byteslike):
            assert raw_decoder is not None
            addr_value_str = raw_decoder(addr_value) # raises err.ValueError if addr_value is invalid
            if not isinstance(addr_value, bytes):
                addr_value = bytes(addr_value)
            return addr_value_str, addr_value
        validate(addr_value, str)
        assert raw_encoder is not None
        addr_value_bytes = raw_encoder(addr_value) # raises err.ValueError if addr_value is invalid
        return addr_value, addr_value_bytes

    def addr(self, value: Union[str, BytesLike]) -&gt; &#34;Addr&#34;:
        &#34;&#34;&#34;
            Returns an address for this protocol.

            Example usage:

            ```py
            &gt;&gt;&gt; ip4.addr(&#34;192.168.1.1&#34;)
            Addr(&#39;ip4&#39;, &#39;192.168.1.1&#39;)
            &gt;&gt;&gt; ip4.addr(bytes([192, 168, 1, 1]))
            Addr(&#39;ip4&#39;, &#39;192.168.1.1&#39;)
            ```

            The same address can be obtained with slash syntax:

            ```py
            &gt;&gt;&gt; ip4/&#34;192.168.1.256&#34;
            Addr(&#39;ip4&#39;, &#39;192.168.1.256&#39;)
            &gt;&gt;&gt; ip4/b&#39;\\xc0\\xa8\\x01\\x01&#39;
            Addr(&#39;ip4&#39;, &#39;192.168.1.1&#39;)
            ```
        &#34;&#34;&#34;
        return Addr(self, value)

    def __contains__(self, value: Union[str, BytesLike]) -&gt; bool:
        return self.is_addr_valid(value)

    @overload
    def __truediv__(self, value: Union[&#34;Proto&#34;, &#34;Addr&#34;, &#34;Multiaddr&#34;]) -&gt; &#34;Multiaddr&#34;:
        ...

    @overload
    def __truediv__(self, value: Union[int, str, BytesLike]) -&gt; &#34;Addr&#34;:
        ...

    def __truediv__(self, value: Union[int, str, BytesLike, &#34;Proto&#34;, &#34;Addr&#34;, &#34;Multiaddr&#34;]) -&gt; Union[&#34;Addr&#34;, &#34;Multiaddr&#34;]:
        if isinstance(value, int):
            value = str(value)
        if isinstance(value, (str,)+byteslike):
            return self.addr(value)
        if isinstance(value, (Addr, Proto)):
            return Multiaddr(self, value)
        if isinstance(value, Multiaddr):
            return Multiaddr(self, *value)
        return NotImplemented

    def __str__(self) -&gt; str:
        return f&#34;/{self.name}&#34;

    def __bytes__(self) -&gt; bytes:
        if self.addr_size != 0:
            raise err.ValueError(&#34;Missing address value for protocol, cannot compute bytes.&#34;)
        return varint.encode(self.code)

    def __repr__(self) -&gt; str:
        return f&#34;Proto({repr(self.name)})&#34;

    @property
    def _as_tuple(self) -&gt; Tuple[Type[&#34;Proto&#34;], Multicodec]:
        return (Proto, self.codec)

    def __hash__(self) -&gt; int:
        return hash(self._as_tuple)

    def __eq__(self, other: Any) -&gt; bool:
        if self is other:
            return True
        if not isinstance(other, Proto):
            return NotImplemented
        return self._as_tuple == other._as_tuple</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="multiformats.multiaddr.Proto.addr_size"><code class="name">var <span class="ident">addr_size</span> :Â Optional[None]</code></dt>
<dd>
<div class="desc"><p>The address size (in bytes) for this protocol:</p>
<ul>
<li>for protocols with no address, <code>addr_size</code> is 0</li>
<li>for protocols with addresses of variable binary size, <code>addr_size</code> is <code>None</code></li>
<li>for all other protocols, size is a positive <code>int</code></li>
</ul>
<p>Example usage:</p>
<pre><code class="language-py">&gt;&gt;&gt; ip4.addr_size
4
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def addr_size(self) -&gt; Optional[int]:
    &#34;&#34;&#34;
        The address size (in bytes) for this protocol:

        - for protocols with no address, `addr_size` is 0
        - for protocols with addresses of variable binary size, `addr_size` is `None`
        - for all other protocols, size is a positive `int`

        Example usage:

        ```py
        &gt;&gt;&gt; ip4.addr_size
        4
        ```
    &#34;&#34;&#34;
    return self.implementation[2]</code></pre>
</details>
</dd>
<dt id="multiformats.multiaddr.Proto.admits_addr"><code class="name">var <span class="ident">admits_addr</span> :Â bool</code></dt>
<dd>
<div class="desc"><p>Whether this protocol admits an address.</p>
<pre><code class="language-py">&gt;&gt;&gt; ip4.admits_addr
True
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def admits_addr(self) -&gt; bool:
    &#34;&#34;&#34;
        Whether this protocol admits an address.

        ```py
        &gt;&gt;&gt; ip4.admits_addr
        True
        ```
    &#34;&#34;&#34;
    return self.addr_size != 0</code></pre>
</details>
</dd>
<dt id="multiformats.multiaddr.Proto.code"><code class="name">var <span class="ident">code</span> :Â int</code></dt>
<dd>
<div class="desc"><p>Protocol code.</p>
<p>Example usage:</p>
<pre><code class="language-py">&gt;&gt;&gt; ip4.code
4
# 4 = 0x04
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def code(self) -&gt; int:
    &#34;&#34;&#34;
        Protocol code.

        Example usage:

        ```py
        &gt;&gt;&gt; ip4.code
        4
        # 4 = 0x04
        ```
    &#34;&#34;&#34;
    return self.codec.code</code></pre>
</details>
</dd>
<dt id="multiformats.multiaddr.Proto.codec"><code class="name">var <span class="ident">codec</span> :Â <a title="multiformats.multicodec.Multicodec" href="../multicodec/index.html#multiformats.multicodec.Multicodec">Multicodec</a></code></dt>
<dd>
<div class="desc"><p>The multicodec for this protocol.</p>
<p>Example usage:</p>
<pre><code class="language-py">&gt;&gt;&gt; ip4.codec
Multicodec(name='ip4', tag='multiaddr', code='0x04',
           status='permanent', description='')
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def codec(self) -&gt; Multicodec:
    &#34;&#34;&#34;
        The multicodec for this protocol.

        Example usage:

        ```py
        &gt;&gt;&gt; ip4.codec
        Multicodec(name=&#39;ip4&#39;, tag=&#39;multiaddr&#39;, code=&#39;0x04&#39;,
                   status=&#39;permanent&#39;, description=&#39;&#39;)
        ```
    &#34;&#34;&#34;
    return self._codec</code></pre>
</details>
</dd>
<dt id="multiformats.multiaddr.Proto.implementation"><code class="name">var <span class="ident">implementation</span> :Â Tuple[Optional[Callable[[str],Â bytes]],Â Optional[Callable[[Union[bytes,Â bytearray,Â memoryview]],Â str]],Â Optional[int]]</code></dt>
<dd>
<div class="desc"><p>The implementation for this protocol, as a triple of
raw encoder, raw decoder and address size.</p>
<p>Example usage:</p>
<pre><code class="language-py">&gt;&gt;&gt; ip4.implementation
(
 &lt;function ip4_encoder at 0x000002B4C9956310&gt;,
 &lt;function ip4_decoder at 0x000002B4C99563A0&gt;,
 4
)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def implementation(self) -&gt; ProtoImpl:
    &#34;&#34;&#34;
        The implementation for this protocol, as a triple of
        raw encoder, raw decoder and address size.

        Example usage:

        ```py
        &gt;&gt;&gt; ip4.implementation
        (
         &lt;function ip4_encoder at 0x000002B4C9956310&gt;,
         &lt;function ip4_decoder at 0x000002B4C99563A0&gt;,
         4
        )
        ```
    &#34;&#34;&#34;
    return self._implementation</code></pre>
</details>
</dd>
<dt id="multiformats.multiaddr.Proto.name"><code class="name">var <span class="ident">name</span> :Â str</code></dt>
<dd>
<div class="desc"><p>Protocol name.</p>
<p>Example usage:</p>
<pre><code class="language-py">&gt;&gt;&gt; ip4.name
'ip4'
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def name(self) -&gt; str:
    &#34;&#34;&#34;
        Protocol name.

        Example usage:

        ```py
        &gt;&gt;&gt; ip4.name
        &#39;ip4&#39;
        ```
    &#34;&#34;&#34;
    return self.codec.name</code></pre>
</details>
</dd>
<dt id="multiformats.multiaddr.Proto.raw_decoder"><code class="name">var <span class="ident">raw_decoder</span> :Â Optional[Callable[[Union[bytes,Â bytearray,Â memoryview]],Â str]]</code></dt>
<dd>
<div class="desc"><p>The raw decoder for this protocol.</p>
<p>Example usage:</p>
<pre><code class="language-py">&gt;&gt;&gt; ip4.raw_decoder
&lt;function ip4_decoder at 0x000002B4C99563A0&gt;
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def raw_decoder(self) -&gt; Optional[RawDecoder]:
    &#34;&#34;&#34;
        The raw decoder for this protocol.

        Example usage:

        ```py
        &gt;&gt;&gt; ip4.raw_decoder
        &lt;function ip4_decoder at 0x000002B4C99563A0&gt;
        ```
    &#34;&#34;&#34;
    return self.implementation[1]</code></pre>
</details>
</dd>
<dt id="multiformats.multiaddr.Proto.raw_encoder"><code class="name">var <span class="ident">raw_encoder</span> :Â Optional[Callable[[str],Â bytes]]</code></dt>
<dd>
<div class="desc"><p>The raw encoder for this protocol.</p>
<p>Example usage:</p>
<pre><code class="language-py">&gt;&gt;&gt; ip4.raw_encoder
&lt;function ip4_encoder at 0x000002B4C9956310&gt;
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def raw_encoder(self) -&gt; Optional[RawEncoder]:
    &#34;&#34;&#34;
        The raw encoder for this protocol.

        Example usage:

        ```py
        &gt;&gt;&gt; ip4.raw_encoder
        &lt;function ip4_encoder at 0x000002B4C9956310&gt;
        ```
    &#34;&#34;&#34;
    return self.implementation[0]</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="multiformats.multiaddr.Proto.addr"><code class="name flex">
<span>def <span class="ident">addr</span></span>(<span>self, value:Â Union[str,Â bytes,Â bytearray,Â memoryview]) â€‘>Â <a title="multiformats.multiaddr.Addr" href="#multiformats.multiaddr.Addr">Addr</a></span>
</code></dt>
<dd>
<div class="desc"><p>Returns an address for this protocol.</p>
<p>Example usage:</p>
<pre><code class="language-py">&gt;&gt;&gt; ip4.addr(&quot;192.168.1.1&quot;)
Addr('ip4', '192.168.1.1')
&gt;&gt;&gt; ip4.addr(bytes([192, 168, 1, 1]))
Addr('ip4', '192.168.1.1')
</code></pre>
<p>The same address can be obtained with slash syntax:</p>
<pre><code class="language-py">&gt;&gt;&gt; ip4/&quot;192.168.1.256&quot;
Addr('ip4', '192.168.1.256')
&gt;&gt;&gt; ip4/b'\xc0\xa8\x01\x01'
Addr('ip4', '192.168.1.1')
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def addr(self, value: Union[str, BytesLike]) -&gt; &#34;Addr&#34;:
    &#34;&#34;&#34;
        Returns an address for this protocol.

        Example usage:

        ```py
        &gt;&gt;&gt; ip4.addr(&#34;192.168.1.1&#34;)
        Addr(&#39;ip4&#39;, &#39;192.168.1.1&#39;)
        &gt;&gt;&gt; ip4.addr(bytes([192, 168, 1, 1]))
        Addr(&#39;ip4&#39;, &#39;192.168.1.1&#39;)
        ```

        The same address can be obtained with slash syntax:

        ```py
        &gt;&gt;&gt; ip4/&#34;192.168.1.256&#34;
        Addr(&#39;ip4&#39;, &#39;192.168.1.256&#39;)
        &gt;&gt;&gt; ip4/b&#39;\\xc0\\xa8\\x01\\x01&#39;
        Addr(&#39;ip4&#39;, &#39;192.168.1.1&#39;)
        ```
    &#34;&#34;&#34;
    return Addr(self, value)</code></pre>
</details>
</dd>
<dt id="multiformats.multiaddr.Proto.is_addr_valid"><code class="name flex">
<span>def <span class="ident">is_addr_valid</span></span>(<span>self, addr_value:Â Union[str,Â bytes,Â bytearray,Â memoryview]) â€‘>Â bool</span>
</code></dt>
<dd>
<div class="desc"><p>Validates an address value.</p>
<p>Example usage:</p>
<pre><code class="language-py">&gt;&gt;&gt; ip4.is_addr_valid(&quot;192.168.1.1&quot;)
True
&gt;&gt;&gt; ip4.is_addr_valid(bytes([192, 168, 1, 1]))
True
</code></pre>
<p>The same result can be obtained with container syntax:</p>
<pre><code class="language-py">&gt;&gt;&gt; &quot;192.168.1.1&quot; in ip4
True
&gt;&gt;&gt; bytes([192, 168, 1, 1]) in ip4
True
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_addr_valid(self, addr_value: Union[str, BytesLike]) -&gt; bool:
    &#34;&#34;&#34;
        Validates an address value.

        Example usage:

        ```py
        &gt;&gt;&gt; ip4.is_addr_valid(&#34;192.168.1.1&#34;)
        True
        &gt;&gt;&gt; ip4.is_addr_valid(bytes([192, 168, 1, 1]))
        True
        ```

        The same result can be obtained with container syntax:

        ```py
        &gt;&gt;&gt; &#34;192.168.1.1&#34; in ip4
        True
        &gt;&gt;&gt; bytes([192, 168, 1, 1]) in ip4
        True
        ```
    &#34;&#34;&#34;
    try:
        self.validate(addr_value)
        return True
    except err.ValueError:
        return False</code></pre>
</details>
</dd>
<dt id="multiformats.multiaddr.Proto.validate"><code class="name flex">
<span>def <span class="ident">validate</span></span>(<span>self, addr_value:Â Union[str,Â bytes,Â bytearray,Â memoryview]) â€‘>Â Tuple[str,Â bytes]</span>
</code></dt>
<dd>
<div class="desc"><p>Raises <code><a title="multiformats.multiaddr.err.ValueError" href="err.html#multiformats.multiaddr.err.ValueError">ValueError</a></code> if <code>not self.is_valid(addr_value)</code>.
If successful, returns a pair of the string and bytes representations of the address value.</p>
<p>Example usage:</p>
<pre><code class="language-py">&gt;&gt;&gt; ip4.validate(&quot;192.168.1.1&quot;)
('192.168.1.1', b'\xc0\xa8\x01\x01')
&gt;&gt;&gt; ip4.validate(&quot;192.168&quot;)
err.ValueError: Expected 4 octets in '192.168'
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def validate(self, addr_value: Union[str, BytesLike]) -&gt; Tuple[str, bytes]:
    &#34;&#34;&#34;
        Raises `err.ValueError` if `not self.is_valid(addr_value)`.
        If successful, returns a pair of the string and bytes representations of the address value.

        Example usage:

        ```py
        &gt;&gt;&gt; ip4.validate(&#34;192.168.1.1&#34;)
        (&#39;192.168.1.1&#39;, b&#39;\\xc0\\xa8\\x01\\x01&#39;)
        &gt;&gt;&gt; ip4.validate(&#34;192.168&#34;)
        err.ValueError: Expected 4 octets in &#39;192.168&#39;
        ```
    &#34;&#34;&#34;
    raw_encoder, raw_decoder, addr_size = self.implementation
    if addr_size == 0:
        raise err.ValueError(f&#34;Protocol admits no address value, but {repr(addr_value)} was passed.&#34;)
    if isinstance(addr_value, byteslike):
        assert raw_decoder is not None
        addr_value_str = raw_decoder(addr_value) # raises err.ValueError if addr_value is invalid
        if not isinstance(addr_value, bytes):
            addr_value = bytes(addr_value)
        return addr_value_str, addr_value
    validate(addr_value, str)
    assert raw_encoder is not None
    addr_value_bytes = raw_encoder(addr_value) # raises err.ValueError if addr_value is invalid
    return addr_value, addr_value_bytes</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="multiformats" href="../index.html">multiformats</a></code></li>
</ul>
</li>
<li><h3><a href="#header-submodules">Sub-modules</a></h3>
<ul>
<li><code><a title="multiformats.multiaddr.err" href="err.html">multiformats.multiaddr.err</a></code></li>
<li><code><a title="multiformats.multiaddr.raw" href="raw.html">multiformats.multiaddr.raw</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="multiformats.multiaddr.decode" href="#multiformats.multiaddr.decode">decode</a></code></li>
<li><code><a title="multiformats.multiaddr.parse" href="#multiformats.multiaddr.parse">parse</a></code></li>
<li><code><a title="multiformats.multiaddr.proto" href="#multiformats.multiaddr.proto">proto</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="multiformats.multiaddr.Addr" href="#multiformats.multiaddr.Addr">Addr</a></code></h4>
<ul class="">
<li><code><a title="multiformats.multiaddr.Addr.proto" href="#multiformats.multiaddr.Addr.proto">proto</a></code></li>
<li><code><a title="multiformats.multiaddr.Addr.value" href="#multiformats.multiaddr.Addr.value">value</a></code></li>
<li><code><a title="multiformats.multiaddr.Addr.value_bytes" href="#multiformats.multiaddr.Addr.value_bytes">value_bytes</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="multiformats.multiaddr.Multiaddr" href="#multiformats.multiaddr.Multiaddr">Multiaddr</a></code></h4>
<ul class="">
<li><code><a title="multiformats.multiaddr.Multiaddr.index" href="#multiformats.multiaddr.Multiaddr.index">index</a></code></li>
<li><code><a title="multiformats.multiaddr.Multiaddr.is_incomplete" href="#multiformats.multiaddr.Multiaddr.is_incomplete">is_incomplete</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="multiformats.multiaddr.Proto" href="#multiformats.multiaddr.Proto">Proto</a></code></h4>
<ul class="two-column">
<li><code><a title="multiformats.multiaddr.Proto.addr" href="#multiformats.multiaddr.Proto.addr">addr</a></code></li>
<li><code><a title="multiformats.multiaddr.Proto.addr_size" href="#multiformats.multiaddr.Proto.addr_size">addr_size</a></code></li>
<li><code><a title="multiformats.multiaddr.Proto.admits_addr" href="#multiformats.multiaddr.Proto.admits_addr">admits_addr</a></code></li>
<li><code><a title="multiformats.multiaddr.Proto.code" href="#multiformats.multiaddr.Proto.code">code</a></code></li>
<li><code><a title="multiformats.multiaddr.Proto.codec" href="#multiformats.multiaddr.Proto.codec">codec</a></code></li>
<li><code><a title="multiformats.multiaddr.Proto.implementation" href="#multiformats.multiaddr.Proto.implementation">implementation</a></code></li>
<li><code><a title="multiformats.multiaddr.Proto.is_addr_valid" href="#multiformats.multiaddr.Proto.is_addr_valid">is_addr_valid</a></code></li>
<li><code><a title="multiformats.multiaddr.Proto.name" href="#multiformats.multiaddr.Proto.name">name</a></code></li>
<li><code><a title="multiformats.multiaddr.Proto.raw_decoder" href="#multiformats.multiaddr.Proto.raw_decoder">raw_decoder</a></code></li>
<li><code><a title="multiformats.multiaddr.Proto.raw_encoder" href="#multiformats.multiaddr.Proto.raw_encoder">raw_encoder</a></code></li>
<li><code><a title="multiformats.multiaddr.Proto.validate" href="#multiformats.multiaddr.Proto.validate">validate</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>