<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>multiformats.multicodec API documentation</title>
<meta name="description" content="Implementation of the [multicodec spec](https://github.com/multiformats/multicodec) â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}.hljs-meta{user-select:none;-moz-user-select:none;-webkit-user-select:none;-ms-user-select:none;pointer-events:none}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>multiformats.multicodec</code></h1>
</header>
<section id="section-intro">
<p>Implementation of the <a href="https://github.com/multiformats/multicodec">multicodec spec</a>.</p>
<p>The <code><a title="multiformats.multicodec.Multicodec" href="#multiformats.multicodec.Multicodec">Multicodec</a></code> class provides a container for multicodec data:</p>
<pre><code class="language-py">&gt;&gt;&gt; from multiformats import multicodec
&gt;&gt;&gt; from multiformats.multicodec import Multicodec
&gt;&gt;&gt; Multicodec(&quot;identity&quot;, &quot;multihash&quot;, 0x00, &quot;permanent&quot;, &quot;raw binary&quot;)
Multicodec(name='identity', tag='multihash', code=0,
           status='permanent', description='raw binary')
</code></pre>
<p>Core functionality is provided by the <code><a title="multiformats.multicodec.get" href="#multiformats.multicodec.get">get()</a></code>, <code><a title="multiformats.multicodec.exists" href="#multiformats.multicodec.exists">exists()</a></code>, <code><a title="multiformats.multicodec.wrap" href="#multiformats.multicodec.wrap">wrap()</a></code> and <code><a title="multiformats.multicodec.unwrap" href="#multiformats.multicodec.unwrap">unwrap()</a></code> functions.
The <code><a title="multiformats.multicodec.get" href="#multiformats.multicodec.get">get()</a></code> and <code><a title="multiformats.multicodec.exists" href="#multiformats.multicodec.exists">exists()</a></code> functions can be used to check whether a multicodec with given name or code is known,
and if so to get the corresponding object:</p>
<pre><code class="language-py">&gt;&gt;&gt; multicodec.exists(&quot;identity&quot;)
True
&gt;&gt;&gt; multicodec.exists(code=0x01)
True
&gt;&gt;&gt; multicodec.get(&quot;identity&quot;)
Multicodec(name='identity', tag='multihash', code=0,
           status='permanent', description='raw binary')
&gt;&gt;&gt; multicodec.get(code=0x01)
Multicodec(name='cidv1', tag='cid', code=1,
           status='permanent', description='CIDv1')
</code></pre>
<p>The <code><a title="multiformats.multicodec.wrap" href="#multiformats.multicodec.wrap">wrap()</a></code> and <code><a title="multiformats.multicodec.unwrap" href="#multiformats.multicodec.unwrap">unwrap()</a></code> functions can be use to wrap raw binary data into multicodec data
(prepending the varint-encoded multicodec code) and to unwrap multicodec data into a pair
of multicodec and raw binary data:</p>
<pre><code class="language-py">&gt;&gt;&gt; raw_data = bytes([192, 168, 0, 254])
&gt;&gt;&gt; multicodec_data = wrap(&quot;ip4&quot;, raw_data)
&gt;&gt;&gt; raw_data.hex()
  'c0a800fe'
&gt;&gt;&gt; multicodec_data.hex()
'04c0a800fe'
&gt;&gt;&gt; varint.encode(0x04).hex()
'04' #       0x04 ^^^^ is the multicodec code for 'ip4'
&gt;&gt;&gt; codec, raw_data = unwrap(multicodec_data)
&gt;&gt;&gt; raw_data.hex()
  'c0a800fe'
&gt;&gt;&gt; codec
Multicodec(name='ip4', tag='multiaddr', code='0x04', status='permanent', description='')
</code></pre>
<p>The <code><a title="multiformats.multicodec.Multicodec.wrap" href="#multiformats.multicodec.Multicodec.wrap">Multicodec.wrap()</a></code> and <code><a title="multiformats.multicodec.Multicodec.unwrap" href="#multiformats.multicodec.Multicodec.unwrap">Multicodec.unwrap()</a></code> methods perform analogous functionality
with an object-oriented API, additionally enforcing that the multicodec is being used to
unwrap the data is the multicodec that the data itself specifies:</p>
<pre><code class="language-py">&gt;&gt;&gt; ip4 = multicodec.get(&quot;ip4&quot;)
&gt;&gt;&gt; ip4
Multicodec(name='ip4', tag='multiaddr', code='0x04', status='permanent', description='')
&gt;&gt;&gt; raw_data = bytes([192, 168, 0, 254])
&gt;&gt;&gt; multicodec_data = ip4.wrap(raw_data)
&gt;&gt;&gt; raw_data.hex()
  'c0a800fe'
&gt;&gt;&gt; multicodec_data.hex()
'04c0a800fe'
&gt;&gt;&gt; varint.encode(0x04).hex()
'04' #       0x04 ^^^^ is the multicodec code for 'ip4'
&gt;&gt;&gt; ip4.unwrap(multicodec_data).hex()
  'c0a800fe'
&gt;&gt;&gt; ip4.unwrap(bytes.fromhex('00c0a800fe')) # 'identity' multicodec data
multiformats.multicodec.err.ValueError: Found code 0x00 when unwrapping data, expected code 0x04.
</code></pre>
<p>The <code><a title="multiformats.multicodec.table" href="#multiformats.multicodec.table">table()</a></code> function can be used to iterate through known multicodecs, optionally restricting
to one or more tags and/or statuses:</p>
<pre><code class="language-py">&gt;&gt;&gt; len(list(multicodec.table())) # multicodec.table() returns an iterator
482
&gt;&gt;&gt; selected = multicodec.table(tag=[&quot;cid&quot;, &quot;ipld&quot;, &quot;multiaddr&quot;], status=&quot;permanent&quot;)
&gt;&gt;&gt; [m.code for m in selected]
[1, 4, 6, 41, 53, 54, 55, 56, 81, 85, 112, 113, 114, 120,
 144, 145, 146, 147, 148, 149, 150, 151, 152, 176, 177,
 178, 192, 193, 290, 297, 400, 421, 460, 477, 478, 479, 512]
</code></pre>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
    Implementation of the [multicodec spec](https://github.com/multiformats/multicodec).

    The `Multicodec` class provides a container for multicodec data:

    ```py
    &gt;&gt;&gt; from multiformats import multicodec
    &gt;&gt;&gt; from multiformats.multicodec import Multicodec
    &gt;&gt;&gt; Multicodec(&#34;identity&#34;, &#34;multihash&#34;, 0x00, &#34;permanent&#34;, &#34;raw binary&#34;)
    Multicodec(name=&#39;identity&#39;, tag=&#39;multihash&#39;, code=0,
               status=&#39;permanent&#39;, description=&#39;raw binary&#39;)
    ```

    Core functionality is provided by the `get`, `exists`, `wrap` and `unwrap` functions.
    The `get` and `exists` functions can be used to check whether a multicodec with given name or code is known,
    and if so to get the corresponding object:

    ```py
    &gt;&gt;&gt; multicodec.exists(&#34;identity&#34;)
    True
    &gt;&gt;&gt; multicodec.exists(code=0x01)
    True
    &gt;&gt;&gt; multicodec.get(&#34;identity&#34;)
    Multicodec(name=&#39;identity&#39;, tag=&#39;multihash&#39;, code=0,
               status=&#39;permanent&#39;, description=&#39;raw binary&#39;)
    &gt;&gt;&gt; multicodec.get(code=0x01)
    Multicodec(name=&#39;cidv1&#39;, tag=&#39;cid&#39;, code=1,
               status=&#39;permanent&#39;, description=&#39;CIDv1&#39;)
    ```

    The `wrap` and `unwrap` functions can be use to wrap raw binary data into multicodec data
    (prepending the varint-encoded multicodec code) and to unwrap multicodec data into a pair
    of multicodec and raw binary data:

    ```py
    &gt;&gt;&gt; raw_data = bytes([192, 168, 0, 254])
    &gt;&gt;&gt; multicodec_data = wrap(&#34;ip4&#34;, raw_data)
    &gt;&gt;&gt; raw_data.hex()
      &#39;c0a800fe&#39;
    &gt;&gt;&gt; multicodec_data.hex()
    &#39;04c0a800fe&#39;
    &gt;&gt;&gt; varint.encode(0x04).hex()
    &#39;04&#39; #       0x04 ^^^^ is the multicodec code for &#39;ip4&#39;
    &gt;&gt;&gt; codec, raw_data = unwrap(multicodec_data)
    &gt;&gt;&gt; raw_data.hex()
      &#39;c0a800fe&#39;
    &gt;&gt;&gt; codec
    Multicodec(name=&#39;ip4&#39;, tag=&#39;multiaddr&#39;, code=&#39;0x04&#39;, status=&#39;permanent&#39;, description=&#39;&#39;)
    ```

    The `Multicodec.wrap` and `Multicodec.unwrap` methods perform analogous functionality
    with an object-oriented API, additionally enforcing that the multicodec is being used to
    unwrap the data is the multicodec that the data itself specifies:

    ```py
    &gt;&gt;&gt; ip4 = multicodec.get(&#34;ip4&#34;)
    &gt;&gt;&gt; ip4
    Multicodec(name=&#39;ip4&#39;, tag=&#39;multiaddr&#39;, code=&#39;0x04&#39;, status=&#39;permanent&#39;, description=&#39;&#39;)
    &gt;&gt;&gt; raw_data = bytes([192, 168, 0, 254])
    &gt;&gt;&gt; multicodec_data = ip4.wrap(raw_data)
    &gt;&gt;&gt; raw_data.hex()
      &#39;c0a800fe&#39;
    &gt;&gt;&gt; multicodec_data.hex()
    &#39;04c0a800fe&#39;
    &gt;&gt;&gt; varint.encode(0x04).hex()
    &#39;04&#39; #       0x04 ^^^^ is the multicodec code for &#39;ip4&#39;
    &gt;&gt;&gt; ip4.unwrap(multicodec_data).hex()
      &#39;c0a800fe&#39;
    &gt;&gt;&gt; ip4.unwrap(bytes.fromhex(&#39;00c0a800fe&#39;)) # &#39;identity&#39; multicodec data
    multiformats.multicodec.err.ValueError: Found code 0x00 when unwrapping data, expected code 0x04.
    ```

    The `table` function can be used to iterate through known multicodecs, optionally restricting
    to one or more tags and/or statuses:

    ```py
    &gt;&gt;&gt; len(list(multicodec.table())) # multicodec.table() returns an iterator
    482
    &gt;&gt;&gt; selected = multicodec.table(tag=[&#34;cid&#34;, &#34;ipld&#34;, &#34;multiaddr&#34;], status=&#34;permanent&#34;)
    &gt;&gt;&gt; [m.code for m in selected]
    [1, 4, 6, 41, 53, 54, 55, 56, 81, 85, 112, 113, 114, 120,
     144, 145, 146, 147, 148, 149, 150, 151, 152, 176, 177,
     178, 192, 193, 290, 297, 400, 421, 460, 477, 478, 479, 512]
    ```

&#34;&#34;&#34;

import importlib.resources as importlib_resources
from io import BufferedIOBase
import json
import re
import sys
from typing import AbstractSet, Any, cast, Dict, Iterable, Iterator, Mapping, Optional, overload, Set, Sequence, Tuple, Type, TypeVar, Union
from typing_extensions import Literal
from typing_validation import validate

from multiformats import varint
from multiformats.varint import BytesLike
from . import err

def _hexcode(code: int) -&gt; str:
    hexcode = hex(code)
    if len(hexcode) % 2 != 0:
        hexcode = &#34;0x0&#34;+hexcode[2:]
    return hexcode

class Multicodec:
    &#34;&#34;&#34;
        Container class for a multicodec.

        Example usage:

        ```py
            &gt;&gt;&gt; Multicodec(**{
            ...     &#39;name&#39;: &#39;cidv1&#39;, &#39;tag&#39;: &#39;cid&#39;, &#39;code&#39;: &#39;0x01&#39;,
            ...     &#39;status&#39;: &#39;permanent&#39;, &#39;description&#39;: &#39;CIDv1&#39;})
            Multicodec(name=&#39;cidv1&#39;, tag=&#39;cid&#39;, code=1,
                       status=&#39;permanent&#39;, description=&#39;CIDv1&#39;)
        ```

    &#34;&#34;&#34;

    _name: str
    _tag: str
    _code: int
    _status: Literal[&#34;draft&#34;, &#34;permanent&#34;]
    _description: str

    __slots__ = (&#34;__weakref__&#34;, &#34;_name&#34;, &#34;_tag&#34;, &#34;_code&#34;, &#34;_status&#34;, &#34;_description&#34;)

    def __init__(self, *,
                 name: str,
                 tag: str,
                 code: Union[int, str],
                 status: str = &#34;draft&#34;,
                 description: str = &#34;&#34;
                ):
        for arg in (name, tag, status, description):
            validate(arg, str)
        validate(code, Union[int, str])
        name = Multicodec._validate_name(name)
        code = Multicodec.validate_code(code)
        status = Multicodec._validate_status(status)
        self._name = name
        self._tag = tag
        self._code = code
        self._status = status
        self._description = description

    @staticmethod
    def _validate_name(name: str) -&gt; str:
        if not re.match(r&#34;^[a-z][a-z0-9_-]+$&#34;, name):
            raise err.ValueError(f&#34;Invalid multicodec name {repr(name)}&#34;)
        return name

    @staticmethod
    def validate_code(code: Union[int, str]) -&gt; int:
        &#34;&#34;&#34;
            Validates a multibase code and transforms it to unsigned integer format (if in hex format).
        &#34;&#34;&#34;
        if isinstance(code, str):
            if code.startswith(&#34;0x&#34;):
                code = code[2:]
            code = int(code, base=16)
        if code &lt; 0:
            raise err.ValueError(f&#34;Invalid multicodec code {repr(code)}.&#34;)
        return code

    @staticmethod
    def _validate_status(status: str) -&gt; Literal[&#34;draft&#34;, &#34;permanent&#34;]:
        if status not in (&#34;draft&#34;, &#34;permanent&#34;):
            raise err.ValueError(f&#34;Invalid multicodec status {repr(status)}.&#34;)
        return cast(Literal[&#34;draft&#34;, &#34;permanent&#34;], status)

    @property
    def name(self) -&gt; str:
        &#34;&#34;&#34;
            Multicodec name. Must satisfy the following:

            ```py
            re.match(r&#34;^[a-z][a-z0-9_-]+$&#34;, name)
            ```
        &#34;&#34;&#34;
        return self._name

    @property
    def tag(self) -&gt; str:
        &#34;&#34;&#34; Multicodec tag. &#34;&#34;&#34;
        return self._tag

    @property
    def code(self) -&gt; int:
        &#34;&#34;&#34; Multicodec code. Must be a non-negative integer. &#34;&#34;&#34;
        return self._code

    @property
    def hexcode(self) -&gt; str:
        &#34;&#34;&#34;
            Multicodec code as a hex string (with hex digits zero-padded to even length):

            Example usage:

            ```py
            &gt;&gt;&gt; m = multicodec.get(1)
            &gt;&gt;&gt; m.code
            1
            &gt;&gt;&gt; m.hexcode
            &#39;0x01&#39;
            ```
        &#34;&#34;&#34;
        return _hexcode(self._code)

    @property
    def status(self) -&gt; Literal[&#34;draft&#34;, &#34;permanent&#34;]:
        &#34;&#34;&#34; Multicodec status. &#34;&#34;&#34;
        return self._status

    @property
    def description(self) -&gt; str:
        &#34;&#34;&#34; Multicodec description. &#34;&#34;&#34;
        return self._description

    @property
    def is_private_use(self) -&gt; bool:
        &#34;&#34;&#34;
            Whether this multicodec code is reserved for private use,
            i.e. whether it is in `range(0x300000, 0x400000)`.
        &#34;&#34;&#34;
        return self.code in range(0x300000, 0x400000)

    def wrap(self, raw_data: BytesLike) -&gt; bytes:
        &#34;&#34;&#34;
            Wraps raw binary data into multicodec data:

            ```
            &lt;raw data&gt; -&gt; &lt;code&gt;&lt;raw data&gt;
            ```

            Example usage:

            ```py
            &gt;&gt;&gt; ip4 = multicodec.get(&#34;ip4&#34;)
            &gt;&gt;&gt; ip4
            Multicodec(name=&#39;ip4&#39;, tag=&#39;multiaddr&#39;, code=&#39;0x04&#39;, status=&#39;permanent&#39;, description=&#39;&#39;)
            &gt;&gt;&gt; raw_data = bytes([192, 168, 0, 254])
            &gt;&gt;&gt; multicodec_data = ip4.wrap(raw_data)
            &gt;&gt;&gt; raw_data.hex()
              &#39;c0a800fe&#39;
            &gt;&gt;&gt; multicodec_data.hex()
            &#39;04c0a800fe&#39;
            &gt;&gt;&gt; varint.encode(0x04).hex()
            &#39;04&#39; #       0x04 ^^^^ is the multicodec code for &#39;ip4&#39;
            ```
        &#34;&#34;&#34;
        return varint.encode(self.code)+raw_data

    def unwrap(self, multicodec_data: BytesLike) -&gt; bytes:
        &#34;&#34;&#34;
            Unwraps multicodec binary data to raw data:

            ```
            &lt;code&gt;&lt;raw data&gt; -&gt; &lt;raw data&gt;
            ```

            Additionally checks that the code listed by the data
            matches the code of this multicodec.

            Example usage:

            ```py
            &gt;&gt;&gt; multicodec_data = bytes.fromhex(&#34;c0a800fe&#34;)
            &gt;&gt;&gt; raw_data = ip4.unwrap(multicodec_data)
            &gt;&gt;&gt; multicodec_data.hex()
            &#39;04c0a800fe&#39;
            &gt;&gt;&gt; raw_data.hex()
              &#39;c0a800fe&#39;
            &gt;&gt;&gt; varint.encode(0x04).hex()
            &#39;04&#39; #       0x04 ^^^^ is the multicodec code for &#39;ip4&#39;
            ```
        &#34;&#34;&#34;
        code, _, raw_data = unwrap_raw(multicodec_data)
        # code, _, raw_data = varint.decode_raw(multicodec_data)
        if code != self.code:
            hexcode = _hexcode(code)
            raise err.ValueError(f&#34;Found code {hexcode} when unwrapping data, expected code {self.hexcode}.&#34;)
        return bytes(raw_data)

    def to_json(self) -&gt; Mapping[str, str]:
        &#34;&#34;&#34;
            Returns a JSON dictionary representation of this multicodec object.

            Example usage:

            ```py
            &gt;&gt;&gt; m = multicodec.get(1)
            &gt;&gt;&gt; m.to_json()
            {&#39;name&#39;: &#39;cidv1&#39;, &#39;tag&#39;: &#39;cid&#39;, &#39;code&#39;: &#39;0x01&#39;,
             &#39;status&#39;: &#39;permanent&#39;, &#39;description&#39;: &#39;CIDv1&#39;}
            ```
        &#34;&#34;&#34;
        return {
            &#34;name&#34;: self.name,
            &#34;tag&#34;: self.tag,
            &#34;code&#34;: self.hexcode,
            &#34;status&#34;: self.status,
            &#34;description&#34;: self.description
        }

    def __str__(self) -&gt; str:
        if exists(self.name) and get(self.name) == self:
            return f&#34;multicodec({repr(self.name)}, tag={repr(self.tag)})&#34;
        return repr(self)

    def __repr__(self) -&gt; str:
        return f&#34;Multicodec({&#39;, &#39;.join(f&#39;{k}={repr(v)}&#39; for k, v in self.to_json().items())})&#34;

    @property
    def _as_tuple(self) -&gt; Tuple[Type[&#34;Multicodec&#34;], str, str, int, Literal[&#34;draft&#34;, &#34;permanent&#34;]]:
        return (Multicodec, self.name, self.tag, self.code, self.status)

    def __hash__(self) -&gt; int:
        return hash(self._as_tuple)

    def __eq__(self, other: Any) -&gt; bool:
        if self is other:
            return True
        if not isinstance(other, Multicodec):
            return NotImplemented
        return self._as_tuple == other._as_tuple


def get(name: Optional[str] = None, *, code: Optional[int] = None) -&gt; Multicodec:
    &#34;&#34;&#34;
        Gets the multicodec with given name or code.
        Raises `err.KeyError` if no such multicodec exists.
        Exactly one of `name` and `code` must be specified.

        Example usage:

        ```py
        &gt;&gt;&gt; multicodec.get(&#34;identity&#34;)
        Multicodec(name=&#39;identity&#39;, tag=&#39;multihash&#39;, code=0,
                   status=&#39;permanent&#39;, description=&#39;raw binary&#39;)
        &gt;&gt;&gt; multicodec.get(code=0x01)
        Multicodec(name=&#39;cidv1&#39;, tag=&#39;ipld&#39;, code=1,
                   status=&#39;permanent&#39;, description=&#39;CIDv1&#39;)
        ```
    &#34;&#34;&#34;
    validate(name, Optional[str])
    validate(code, Optional[int])
    if (name is None) == (code is None):
        raise err.ValueError(&#34;Must specify exactly one between &#39;name&#39; and &#39;code&#39;.&#34;)
    if name is not None:
        if name not in _name_table:
            raise err.KeyError(f&#34;No multicodec named {repr(name)}.&#34;)
        return _name_table[name]
    if code not in _code_table:
        raise err.KeyError(f&#34;No multicodec with code {repr(code)}.&#34;)
    return _code_table[code]


def multicodec(name: str, *, tag: Optional[str] = None) -&gt; Multicodec:
    &#34;&#34;&#34;
        An alias for `get`, for use with multicodec name only.
        If a tag is passed, ensures that the multicodec tag matches the one given.

        Example usage:

        ```py
        &gt;&gt;&gt; from multiformats.multicodec import multicodec
        &gt;&gt;&gt; multicodec(&#34;identity&#34;)
        Multicodec(name=&#39;identity&#39;, tag=&#39;multihash&#39;, code=0,
                   status=&#39;permanent&#39;, description=&#39;raw binary&#39;)
        ```
    &#34;&#34;&#34;
    codec = get(name)
    if tag is not None and codec.tag != tag:
        raise err.KeyError(f&#34;Multicodec {repr(name)} exists, but its tag is not {repr(tag)}.&#34;)
    return codec


def exists(name: Union[None, str, Multicodec] = None, *, code: Optional[int] = None) -&gt; bool:
    &#34;&#34;&#34;
        Checks whether there is a multicodec with the given name or code.
        Exactly one of `name` and `code` must be specified.

        Example usage:

        ```py
        &gt;&gt;&gt; multicodec.exists(&#34;identity&#34;)
        True
        &gt;&gt;&gt; multicodec.exists(code=0x01)
        True
        ```
    &#34;&#34;&#34;
    validate(name, Optional[str])
    validate(code, Optional[int])
    if (name is None) == (code is None):
        raise err.ValueError(&#34;Must specify exactly one between &#39;name&#39; and &#39;code&#39;.&#34;)
    if name is not None:
        return name in _name_table
    return code in _code_table


def wrap(codec: Union[str, int, Multicodec], raw_data: BytesLike) -&gt; bytes:
    &#34;&#34;&#34;
        Wraps raw binary data into multicodec data:

        ```
        &lt;raw data&gt; -&gt; &lt;code&gt;&lt;raw data&gt;
        ```

            Example usage:

        ```py
        &gt;&gt;&gt; raw_data = bytes([192, 168, 0, 254])
        &gt;&gt;&gt; multicodec_data = multicodec.wrap(&#34;ip4&#34;, raw_data)
        &gt;&gt;&gt; raw_data.hex()
          &#39;c0a800fe&#39;
        &gt;&gt;&gt; multicodec_data.hex()
        &#39;04c0a800fe&#39;
        &gt;&gt;&gt; varint.encode(0x04).hex()
        &#39;04&#39; #       0x04 ^^^^ is the multicodec code for &#39;ip4&#39;
        ```
    &#34;&#34;&#34;
    if isinstance(codec, str):
        codec = get(codec)
    elif isinstance(codec, int):
        codec = get(code=codec)
    else:
        validate(codec, Multicodec)
    return codec.wrap(raw_data)

def unwrap(multicodec_data: BytesLike) -&gt; Tuple[Multicodec, bytes]:
    &#34;&#34;&#34;
        Unwraps multicodec binary data to multicodec and raw data:

        Example usage:

        ```py
        &gt;&gt;&gt; multicodec_data = bytes.fromhex(&#34;c0a800fe&#34;)
        &gt;&gt;&gt; codec, raw_data = multicodec.unwrap(multicodec_data)
        &gt;&gt;&gt; multicodec_data.hex()
        &#39;04c0a800fe&#39;
        &gt;&gt;&gt; raw_data.hex()
          &#39;c0a800fe&#39;
        &gt;&gt;&gt; codec
        Multicodec(name=&#39;ip4&#39;, tag=&#39;multiaddr&#39;, code=&#39;0x04&#39;, status=&#39;permanent&#39;, description=&#39;&#39;)
        ```
    &#34;&#34;&#34;
    code, _, raw_data = unwrap_raw(multicodec_data)
    return get(code=code), bytes(raw_data)


_BufferedIOT = TypeVar(&#34;_BufferedIOT&#34;, bound=BufferedIOBase)

@overload
def unwrap_raw(multicodec_data: BytesLike) -&gt; Tuple[int, int, memoryview]:
    ...

@overload
def unwrap_raw(multicodec_data: _BufferedIOT) -&gt; Tuple[int, int, _BufferedIOT]:
    ...

def unwrap_raw(multicodec_data: Union[BytesLike, BufferedIOBase]) -&gt; Tuple[int, int, Union[memoryview, BufferedIOBase]]:
    &#34;&#34;&#34;
        An alias for `multiformats.varint.decode_raw`, returning a triple of multicodec code, bytes read and remaining bytes.
        The multicodec code is validated, and `err.KeyError` is raised if not multicodec with such code exists.
    &#34;&#34;&#34;
    code, n, raw_data = varint.decode_raw(multicodec_data)
    if not exists(code=code):
        raise err.KeyError(f&#34;No multicodec is known with unwrapped code {_hexcode(code)}.&#34;)
    return code, n, raw_data


def validate_multicodec(multicodec: Multicodec) -&gt; None:
    &#34;&#34;&#34;
        Validates a multicodec:

        - raises `err.KeyError` if no multicodec with the given name is registered
        - raises `err.ValueError` if a multicodec with the given name is registered, but is different from the one given
        - raises no error if the given multicodec is registered
    &#34;&#34;&#34;
    validate(multicodec, Multicodec)
    mc = get(multicodec.name)
    if mc != multicodec:
        raise err.ValueError(f&#34;Multicodec named {multicodec.name} exists, but is not the one given.&#34;)

def register(m: Multicodec, *, overwrite: bool = False) -&gt; None:
    &#34;&#34;&#34;
        Registers a given multicodec. The optional keyword argument `overwrite` (default: `False`)
        can be used to overwrite a multicodec with existing code.

        When `overwrite` is `False`, raises `err.ValueError` if a multicodec with the same name or code already exists.
        When `overwrite` is `True`, raises `err.ValueError` if a multicodec with the same name but different code already exists.

        Example usage:

        ```py
            &gt;&gt;&gt; m = Multicodec(&#34;my-multicodec&#34;, &#34;my-tag&#34;, 0x300001, &#34;draft&#34;, &#34;...&#34;)
            &gt;&gt;&gt; multicodec.register(m)
            &gt;&gt;&gt; multicodec.exists(code=0x300001)
            True
            &gt;&gt;&gt; multicodec.get(code=0x300001).name
            &#39;my-multicodec&#39;
            &gt;&gt;&gt; multicodec.get(code=0x300001).is_private_use
            True
        ```
    &#34;&#34;&#34;
    validate(m, Multicodec)
    validate(overwrite, bool)
    if not overwrite and m.code in _code_table:
        raise err.ValueError(f&#34;Multicodec with code {repr(m.code)} already exists: {_code_table[m.code]}&#34;)
    if m.name in _name_table and _name_table[m.name].code != m.code:
        raise err.ValueError(f&#34;Multicodec with name {repr(m.name)} already exists: {_name_table[m.name]}&#34;)
    _code_table[m.code] = m
    _name_table[m.name] = m


def unregister(name: Optional[str] = None, *, code: Optional[int] = None) -&gt; None:
    &#34;&#34;&#34;
        Unregisters the multicodec with given name or code.
        Raises `err.KeyError` if no such multicodec exists.

        Example usage:

        ```py
        &gt;&gt;&gt; multicodec.unregister(code=0x01) # cidv1
        &gt;&gt;&gt; multicodec.unregister(code=0x01)
        False
        ```
    &#34;&#34;&#34;
    m = get(name, code=code)
    del _code_table[m.code]
    del _name_table[m.name]



def table(*,
          tag: Union[None, str, AbstractSet[str], Sequence[str]] = None,
          status: Union[None, str, AbstractSet[str], Sequence[str]] = None) -&gt; Iterator[Multicodec]:
    &#34;&#34;&#34;
        Iterates through the registered multicodecs, in order of ascending code.
        The optional keyword arguments `tag` and `status` can be used to restrict the iterator
        to multicodecs with a given `tag` or `status` respectively.

        Example usage:


        ```py
        &gt;&gt;&gt; len(list(multicodec.table())) # multicodec.table() returns an iterator
        482
        &gt;&gt;&gt; selected = multicodec.table(tag=[&#34;cid&#34;, &#34;cid&#34;, &#34;multiaddr&#34;], status=&#34;permanent&#34;)
        &gt;&gt;&gt; [m.code for m in selected]
        [1, 4, 6, 41, 53, 54, 55, 56, 81, 85, 112, 113, 114, 120,
         144, 145, 146, 147, 148, 149, 150, 151, 152, 176, 177,
         178, 192, 193, 290, 297, 400, 421, 460, 477, 478, 479, 512]
        ```
    &#34;&#34;&#34;
    validate(tag, Union[None, str, AbstractSet[str], Sequence[str]])
    validate(status, Union[None, str, AbstractSet[str], Sequence[str]])
    tags: Union[None, AbstractSet[str], Sequence[str]]
    if tag is None:
        tags = None
    elif isinstance(tag, str):
        tags = [tag]
    else:
        tags = tag
    statuses: Union[None, AbstractSet[str], Sequence[str]]
    if status is None:
        statuses = None
    elif isinstance(status, str):
        statuses = [status]
    else:
        statuses = status
    for code in sorted(_code_table.keys()):
        m = _code_table[code]
        if tags is not None and m.tag not in tags:
            continue
        if statuses is not None and m.status not in statuses:
            continue
        yield m


def build_multicodec_tables(multicodecs: Iterable[Multicodec], *,
                            allow_private_use: bool = False) -&gt; Tuple[Dict[int, Multicodec], Dict[str, Multicodec]]:
    &#34;&#34;&#34;
        Creates code-&gt;multicodec and name-&gt;multicodec mappings from a finite iterable of multicodecs,
        returning the mappings.
        The keyword argument `allow_private_use` (default: `False`) can be used to allow multicodec entries
        with private use codes in `range(0x300000, 0x400000)`: if set to `False`, a `err.ValueError` is raised
        if one such private use code is encountered.

        Raises `err.ValueError` if the same multicodec code is encountered multiple times, unless exactly one
        of the multicodecs has permanent status (in which case that codec is the one inserted in the table).
        Raises `err.ValueError` if the same name is encountered multiple times.

        Example usage:

        ```py
            code_table, name_table = build_multicodec_tables(multicodecs)
        ```
    &#34;&#34;&#34;
    # validate(multicodecs, Iterable[Multicodec]) # TODO: not yet properly supported by typing-validation
    validate(allow_private_use, bool)
    code_table: Dict[int, Multicodec] = {}
    name_table: Dict[str, Multicodec] = {}
    overwritten_draft_codes: Set[int] = set()
    for m in multicodecs:
        if not allow_private_use and m.is_private_use:
            raise err.ValueError(f&#34;Private use multicodec not allowed: {m}&#34;)
        if m.code in code_table:
            if code_table[m.code].status == &#34;permanent&#34;:
                if m.status == &#34;draft&#34;:
                    # this draft code has been superseded by a permanent one, skip it
                    continue
                raise err.ValueError(f&#34;Multicodec code {m.hexcode} appears multiple times in table.&#34;)
            if m.status != &#34;permanent&#34;:
                # overwriting draft code with another draft code: dodgy, need to check at the end
                overwritten_draft_codes.add(m.code)
        code_table[m.code] = m
        if m.name in name_table:
            raise err.ValueError(f&#34;Multicodec name {m.name} appears multiple times in table.&#34;)
        name_table[m.name] = m
    for code in overwritten_draft_codes:
        m = code_table[code]
        if m.status != &#34;permanent&#34;:
            raise err.ValueError(f&#34;Code {m.code} appears multiple times in table, &#34;
                              &#34;but none of the associated multicodecs is permanent.&#34;)
    return code_table, name_table

# Create the global code-&gt;multicodec and name-&gt;multicodec mappings.
_code_table: Dict[int, Multicodec]
_name_table: Dict[str, Multicodec]
with importlib_resources.open_text(&#34;multiformats.multicodec&#34;, &#34;multicodec-table.json&#34;) as table_f:
    table_json = json.load(table_f)
    _code_table, _name_table = build_multicodec_tables(Multicodec(**row) for row in table_json)


# additional docs info
__pdoc__ = {
    &#34;build_multicodec_tables&#34;: False # exclude from docs
}</code></pre>
</details>
</section>
<section>
<h2 class="section-title" id="header-submodules">Sub-modules</h2>
<dl>
<dt><code class="name"><a title="multiformats.multicodec.err" href="err.html">multiformats.multicodec.err</a></code></dt>
<dd>
<div class="desc"><p>Errors for the <code><a title="multiformats.multicodec" href="#multiformats.multicodec">multiformats.multicodec</a></code> module.</p></div>
</dd>
</dl>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="multiformats.multicodec.exists"><code class="name flex">
<span>def <span class="ident">exists</span></span>(<span>name:Â Union[ForwardRef(None),Â str,Â <a title="multiformats.multicodec.Multicodec" href="#multiformats.multicodec.Multicodec">Multicodec</a>]Â =Â None, *, code:Â Optional[None]Â =Â None) â€‘>Â bool</span>
</code></dt>
<dd>
<div class="desc"><p>Checks whether there is a multicodec with the given name or code.
Exactly one of <code>name</code> and <code>code</code> must be specified.</p>
<p>Example usage:</p>
<pre><code class="language-py">&gt;&gt;&gt; multicodec.exists(&quot;identity&quot;)
True
&gt;&gt;&gt; multicodec.exists(code=0x01)
True
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def exists(name: Union[None, str, Multicodec] = None, *, code: Optional[int] = None) -&gt; bool:
    &#34;&#34;&#34;
        Checks whether there is a multicodec with the given name or code.
        Exactly one of `name` and `code` must be specified.

        Example usage:

        ```py
        &gt;&gt;&gt; multicodec.exists(&#34;identity&#34;)
        True
        &gt;&gt;&gt; multicodec.exists(code=0x01)
        True
        ```
    &#34;&#34;&#34;
    validate(name, Optional[str])
    validate(code, Optional[int])
    if (name is None) == (code is None):
        raise err.ValueError(&#34;Must specify exactly one between &#39;name&#39; and &#39;code&#39;.&#34;)
    if name is not None:
        return name in _name_table
    return code in _code_table</code></pre>
</details>
</dd>
<dt id="multiformats.multicodec.get"><code class="name flex">
<span>def <span class="ident">get</span></span>(<span>name:Â Optional[str]Â =Â None, *, code:Â Optional[None]Â =Â None) â€‘>Â <a title="multiformats.multicodec.Multicodec" href="#multiformats.multicodec.Multicodec">Multicodec</a></span>
</code></dt>
<dd>
<div class="desc"><p>Gets the multicodec with given name or code.
Raises <code><a title="multiformats.multicodec.err.KeyError" href="err.html#multiformats.multicodec.err.KeyError">KeyError</a></code> if no such multicodec exists.
Exactly one of <code>name</code> and <code>code</code> must be specified.</p>
<p>Example usage:</p>
<pre><code class="language-py">&gt;&gt;&gt; multicodec.get(&quot;identity&quot;)
Multicodec(name='identity', tag='multihash', code=0,
           status='permanent', description='raw binary')
&gt;&gt;&gt; multicodec.get(code=0x01)
Multicodec(name='cidv1', tag='ipld', code=1,
           status='permanent', description='CIDv1')
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get(name: Optional[str] = None, *, code: Optional[int] = None) -&gt; Multicodec:
    &#34;&#34;&#34;
        Gets the multicodec with given name or code.
        Raises `err.KeyError` if no such multicodec exists.
        Exactly one of `name` and `code` must be specified.

        Example usage:

        ```py
        &gt;&gt;&gt; multicodec.get(&#34;identity&#34;)
        Multicodec(name=&#39;identity&#39;, tag=&#39;multihash&#39;, code=0,
                   status=&#39;permanent&#39;, description=&#39;raw binary&#39;)
        &gt;&gt;&gt; multicodec.get(code=0x01)
        Multicodec(name=&#39;cidv1&#39;, tag=&#39;ipld&#39;, code=1,
                   status=&#39;permanent&#39;, description=&#39;CIDv1&#39;)
        ```
    &#34;&#34;&#34;
    validate(name, Optional[str])
    validate(code, Optional[int])
    if (name is None) == (code is None):
        raise err.ValueError(&#34;Must specify exactly one between &#39;name&#39; and &#39;code&#39;.&#34;)
    if name is not None:
        if name not in _name_table:
            raise err.KeyError(f&#34;No multicodec named {repr(name)}.&#34;)
        return _name_table[name]
    if code not in _code_table:
        raise err.KeyError(f&#34;No multicodec with code {repr(code)}.&#34;)
    return _code_table[code]</code></pre>
</details>
</dd>
<dt id="multiformats.multicodec.multicodec"><code class="name flex">
<span>def <span class="ident">multicodec</span></span>(<span>name:Â str, *, tag:Â Optional[str]Â =Â None) â€‘>Â <a title="multiformats.multicodec.Multicodec" href="#multiformats.multicodec.Multicodec">Multicodec</a></span>
</code></dt>
<dd>
<div class="desc"><p>An alias for <code><a title="multiformats.multicodec.get" href="#multiformats.multicodec.get">get()</a></code>, for use with multicodec name only.
If a tag is passed, ensures that the multicodec tag matches the one given.</p>
<p>Example usage:</p>
<pre><code class="language-py">&gt;&gt;&gt; from multiformats.multicodec import multicodec
&gt;&gt;&gt; multicodec(&quot;identity&quot;)
Multicodec(name='identity', tag='multihash', code=0,
           status='permanent', description='raw binary')
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def multicodec(name: str, *, tag: Optional[str] = None) -&gt; Multicodec:
    &#34;&#34;&#34;
        An alias for `get`, for use with multicodec name only.
        If a tag is passed, ensures that the multicodec tag matches the one given.

        Example usage:

        ```py
        &gt;&gt;&gt; from multiformats.multicodec import multicodec
        &gt;&gt;&gt; multicodec(&#34;identity&#34;)
        Multicodec(name=&#39;identity&#39;, tag=&#39;multihash&#39;, code=0,
                   status=&#39;permanent&#39;, description=&#39;raw binary&#39;)
        ```
    &#34;&#34;&#34;
    codec = get(name)
    if tag is not None and codec.tag != tag:
        raise err.KeyError(f&#34;Multicodec {repr(name)} exists, but its tag is not {repr(tag)}.&#34;)
    return codec</code></pre>
</details>
</dd>
<dt id="multiformats.multicodec.register"><code class="name flex">
<span>def <span class="ident">register</span></span>(<span>m:Â <a title="multiformats.multicodec.Multicodec" href="#multiformats.multicodec.Multicodec">Multicodec</a>, *, overwrite:Â boolÂ =Â False) â€‘>Â None</span>
</code></dt>
<dd>
<div class="desc"><p>Registers a given multicodec. The optional keyword argument <code>overwrite</code> (default: <code>False</code>)
can be used to overwrite a multicodec with existing code.</p>
<p>When <code>overwrite</code> is <code>False</code>, raises <code><a title="multiformats.multicodec.err.ValueError" href="err.html#multiformats.multicodec.err.ValueError">ValueError</a></code> if a multicodec with the same name or code already exists.
When <code>overwrite</code> is <code>True</code>, raises <code><a title="multiformats.multicodec.err.ValueError" href="err.html#multiformats.multicodec.err.ValueError">ValueError</a></code> if a multicodec with the same name but different code already exists.</p>
<p>Example usage:</p>
<pre><code class="language-py">    &gt;&gt;&gt; m = Multicodec(&quot;my-multicodec&quot;, &quot;my-tag&quot;, 0x300001, &quot;draft&quot;, &quot;...&quot;)
    &gt;&gt;&gt; multicodec.register(m)
    &gt;&gt;&gt; multicodec.exists(code=0x300001)
    True
    &gt;&gt;&gt; multicodec.get(code=0x300001).name
    'my-multicodec'
    &gt;&gt;&gt; multicodec.get(code=0x300001).is_private_use
    True
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def register(m: Multicodec, *, overwrite: bool = False) -&gt; None:
    &#34;&#34;&#34;
        Registers a given multicodec. The optional keyword argument `overwrite` (default: `False`)
        can be used to overwrite a multicodec with existing code.

        When `overwrite` is `False`, raises `err.ValueError` if a multicodec with the same name or code already exists.
        When `overwrite` is `True`, raises `err.ValueError` if a multicodec with the same name but different code already exists.

        Example usage:

        ```py
            &gt;&gt;&gt; m = Multicodec(&#34;my-multicodec&#34;, &#34;my-tag&#34;, 0x300001, &#34;draft&#34;, &#34;...&#34;)
            &gt;&gt;&gt; multicodec.register(m)
            &gt;&gt;&gt; multicodec.exists(code=0x300001)
            True
            &gt;&gt;&gt; multicodec.get(code=0x300001).name
            &#39;my-multicodec&#39;
            &gt;&gt;&gt; multicodec.get(code=0x300001).is_private_use
            True
        ```
    &#34;&#34;&#34;
    validate(m, Multicodec)
    validate(overwrite, bool)
    if not overwrite and m.code in _code_table:
        raise err.ValueError(f&#34;Multicodec with code {repr(m.code)} already exists: {_code_table[m.code]}&#34;)
    if m.name in _name_table and _name_table[m.name].code != m.code:
        raise err.ValueError(f&#34;Multicodec with name {repr(m.name)} already exists: {_name_table[m.name]}&#34;)
    _code_table[m.code] = m
    _name_table[m.name] = m</code></pre>
</details>
</dd>
<dt id="multiformats.multicodec.table"><code class="name flex">
<span>def <span class="ident">table</span></span>(<span>*, tag:Â Union[ForwardRef(None),Â str,Â AbstractSet[str],Â Sequence[str]]Â =Â None, status:Â Union[ForwardRef(None),Â str,Â AbstractSet[str],Â Sequence[str]]Â =Â None) â€‘>Â Iterator[<a title="multiformats.multicodec.Multicodec" href="#multiformats.multicodec.Multicodec">Multicodec</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Iterates through the registered multicodecs, in order of ascending code.
The optional keyword arguments <code>tag</code> and <code>status</code> can be used to restrict the iterator
to multicodecs with a given <code>tag</code> or <code>status</code> respectively.</p>
<p>Example usage:</p>
<pre><code class="language-py">&gt;&gt;&gt; len(list(multicodec.table())) # multicodec.table() returns an iterator
482
&gt;&gt;&gt; selected = multicodec.table(tag=[&quot;cid&quot;, &quot;cid&quot;, &quot;multiaddr&quot;], status=&quot;permanent&quot;)
&gt;&gt;&gt; [m.code for m in selected]
[1, 4, 6, 41, 53, 54, 55, 56, 81, 85, 112, 113, 114, 120,
 144, 145, 146, 147, 148, 149, 150, 151, 152, 176, 177,
 178, 192, 193, 290, 297, 400, 421, 460, 477, 478, 479, 512]
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def table(*,
          tag: Union[None, str, AbstractSet[str], Sequence[str]] = None,
          status: Union[None, str, AbstractSet[str], Sequence[str]] = None) -&gt; Iterator[Multicodec]:
    &#34;&#34;&#34;
        Iterates through the registered multicodecs, in order of ascending code.
        The optional keyword arguments `tag` and `status` can be used to restrict the iterator
        to multicodecs with a given `tag` or `status` respectively.

        Example usage:


        ```py
        &gt;&gt;&gt; len(list(multicodec.table())) # multicodec.table() returns an iterator
        482
        &gt;&gt;&gt; selected = multicodec.table(tag=[&#34;cid&#34;, &#34;cid&#34;, &#34;multiaddr&#34;], status=&#34;permanent&#34;)
        &gt;&gt;&gt; [m.code for m in selected]
        [1, 4, 6, 41, 53, 54, 55, 56, 81, 85, 112, 113, 114, 120,
         144, 145, 146, 147, 148, 149, 150, 151, 152, 176, 177,
         178, 192, 193, 290, 297, 400, 421, 460, 477, 478, 479, 512]
        ```
    &#34;&#34;&#34;
    validate(tag, Union[None, str, AbstractSet[str], Sequence[str]])
    validate(status, Union[None, str, AbstractSet[str], Sequence[str]])
    tags: Union[None, AbstractSet[str], Sequence[str]]
    if tag is None:
        tags = None
    elif isinstance(tag, str):
        tags = [tag]
    else:
        tags = tag
    statuses: Union[None, AbstractSet[str], Sequence[str]]
    if status is None:
        statuses = None
    elif isinstance(status, str):
        statuses = [status]
    else:
        statuses = status
    for code in sorted(_code_table.keys()):
        m = _code_table[code]
        if tags is not None and m.tag not in tags:
            continue
        if statuses is not None and m.status not in statuses:
            continue
        yield m</code></pre>
</details>
</dd>
<dt id="multiformats.multicodec.unregister"><code class="name flex">
<span>def <span class="ident">unregister</span></span>(<span>name:Â Optional[str]Â =Â None, *, code:Â Optional[None]Â =Â None) â€‘>Â None</span>
</code></dt>
<dd>
<div class="desc"><p>Unregisters the multicodec with given name or code.
Raises <code><a title="multiformats.multicodec.err.KeyError" href="err.html#multiformats.multicodec.err.KeyError">KeyError</a></code> if no such multicodec exists.</p>
<p>Example usage:</p>
<pre><code class="language-py">&gt;&gt;&gt; multicodec.unregister(code=0x01) # cidv1
&gt;&gt;&gt; multicodec.unregister(code=0x01)
False
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def unregister(name: Optional[str] = None, *, code: Optional[int] = None) -&gt; None:
    &#34;&#34;&#34;
        Unregisters the multicodec with given name or code.
        Raises `err.KeyError` if no such multicodec exists.

        Example usage:

        ```py
        &gt;&gt;&gt; multicodec.unregister(code=0x01) # cidv1
        &gt;&gt;&gt; multicodec.unregister(code=0x01)
        False
        ```
    &#34;&#34;&#34;
    m = get(name, code=code)
    del _code_table[m.code]
    del _name_table[m.name]</code></pre>
</details>
</dd>
<dt id="multiformats.multicodec.unwrap"><code class="name flex">
<span>def <span class="ident">unwrap</span></span>(<span>multicodec_data:Â Union[bytes,Â bytearray,Â memoryview]) â€‘>Â Tuple[<a title="multiformats.multicodec.Multicodec" href="#multiformats.multicodec.Multicodec">Multicodec</a>,Â bytes]</span>
</code></dt>
<dd>
<div class="desc"><p>Unwraps multicodec binary data to multicodec and raw data:</p>
<p>Example usage:</p>
<pre><code class="language-py">&gt;&gt;&gt; multicodec_data = bytes.fromhex(&quot;c0a800fe&quot;)
&gt;&gt;&gt; codec, raw_data = multicodec.unwrap(multicodec_data)
&gt;&gt;&gt; multicodec_data.hex()
'04c0a800fe'
&gt;&gt;&gt; raw_data.hex()
  'c0a800fe'
&gt;&gt;&gt; codec
Multicodec(name='ip4', tag='multiaddr', code='0x04', status='permanent', description='')
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def unwrap(multicodec_data: BytesLike) -&gt; Tuple[Multicodec, bytes]:
    &#34;&#34;&#34;
        Unwraps multicodec binary data to multicodec and raw data:

        Example usage:

        ```py
        &gt;&gt;&gt; multicodec_data = bytes.fromhex(&#34;c0a800fe&#34;)
        &gt;&gt;&gt; codec, raw_data = multicodec.unwrap(multicodec_data)
        &gt;&gt;&gt; multicodec_data.hex()
        &#39;04c0a800fe&#39;
        &gt;&gt;&gt; raw_data.hex()
          &#39;c0a800fe&#39;
        &gt;&gt;&gt; codec
        Multicodec(name=&#39;ip4&#39;, tag=&#39;multiaddr&#39;, code=&#39;0x04&#39;, status=&#39;permanent&#39;, description=&#39;&#39;)
        ```
    &#34;&#34;&#34;
    code, _, raw_data = unwrap_raw(multicodec_data)
    return get(code=code), bytes(raw_data)</code></pre>
</details>
</dd>
<dt id="multiformats.multicodec.unwrap_raw"><code class="name flex">
<span>def <span class="ident">unwrap_raw</span></span>(<span>multicodec_data:Â Union[bytes,Â bytearray,Â memoryview,Â io.BufferedIOBase]) â€‘>Â Tuple[int,Â int,Â Union[memoryview,Â io.BufferedIOBase]]</span>
</code></dt>
<dd>
<div class="desc"><p>An alias for <code><a title="multiformats.varint.decode_raw" href="../varint.html#multiformats.varint.decode_raw">decode_raw()</a></code>, returning a triple of multicodec code, bytes read and remaining bytes.
The multicodec code is validated, and <code><a title="multiformats.multicodec.err.KeyError" href="err.html#multiformats.multicodec.err.KeyError">KeyError</a></code> is raised if not multicodec with such code exists.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def unwrap_raw(multicodec_data: Union[BytesLike, BufferedIOBase]) -&gt; Tuple[int, int, Union[memoryview, BufferedIOBase]]:
    &#34;&#34;&#34;
        An alias for `multiformats.varint.decode_raw`, returning a triple of multicodec code, bytes read and remaining bytes.
        The multicodec code is validated, and `err.KeyError` is raised if not multicodec with such code exists.
    &#34;&#34;&#34;
    code, n, raw_data = varint.decode_raw(multicodec_data)
    if not exists(code=code):
        raise err.KeyError(f&#34;No multicodec is known with unwrapped code {_hexcode(code)}.&#34;)
    return code, n, raw_data</code></pre>
</details>
</dd>
<dt id="multiformats.multicodec.validate_multicodec"><code class="name flex">
<span>def <span class="ident">validate_multicodec</span></span>(<span>multicodec:Â <a title="multiformats.multicodec.Multicodec" href="#multiformats.multicodec.Multicodec">Multicodec</a>) â€‘>Â None</span>
</code></dt>
<dd>
<div class="desc"><p>Validates a multicodec:</p>
<ul>
<li>raises <code><a title="multiformats.multicodec.err.KeyError" href="err.html#multiformats.multicodec.err.KeyError">KeyError</a></code> if no multicodec with the given name is registered</li>
<li>raises <code><a title="multiformats.multicodec.err.ValueError" href="err.html#multiformats.multicodec.err.ValueError">ValueError</a></code> if a multicodec with the given name is registered, but is different from the one given</li>
<li>raises no error if the given multicodec is registered</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def validate_multicodec(multicodec: Multicodec) -&gt; None:
    &#34;&#34;&#34;
        Validates a multicodec:

        - raises `err.KeyError` if no multicodec with the given name is registered
        - raises `err.ValueError` if a multicodec with the given name is registered, but is different from the one given
        - raises no error if the given multicodec is registered
    &#34;&#34;&#34;
    validate(multicodec, Multicodec)
    mc = get(multicodec.name)
    if mc != multicodec:
        raise err.ValueError(f&#34;Multicodec named {multicodec.name} exists, but is not the one given.&#34;)</code></pre>
</details>
</dd>
<dt id="multiformats.multicodec.wrap"><code class="name flex">
<span>def <span class="ident">wrap</span></span>(<span>codec:Â Union[str,Â int,Â <a title="multiformats.multicodec.Multicodec" href="#multiformats.multicodec.Multicodec">Multicodec</a>], raw_data:Â Union[bytes,Â bytearray,Â memoryview]) â€‘>Â bytes</span>
</code></dt>
<dd>
<div class="desc"><p>Wraps raw binary data into multicodec data:</p>
<pre><code>&lt;raw data&gt; -&gt; &lt;code&gt;&lt;raw data&gt;
</code></pre>
<pre><code>Example usage:
</code></pre>
<pre><code class="language-py">&gt;&gt;&gt; raw_data = bytes([192, 168, 0, 254])
&gt;&gt;&gt; multicodec_data = multicodec.wrap(&quot;ip4&quot;, raw_data)
&gt;&gt;&gt; raw_data.hex()
  'c0a800fe'
&gt;&gt;&gt; multicodec_data.hex()
'04c0a800fe'
&gt;&gt;&gt; varint.encode(0x04).hex()
'04' #       0x04 ^^^^ is the multicodec code for 'ip4'
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def wrap(codec: Union[str, int, Multicodec], raw_data: BytesLike) -&gt; bytes:
    &#34;&#34;&#34;
        Wraps raw binary data into multicodec data:

        ```
        &lt;raw data&gt; -&gt; &lt;code&gt;&lt;raw data&gt;
        ```

            Example usage:

        ```py
        &gt;&gt;&gt; raw_data = bytes([192, 168, 0, 254])
        &gt;&gt;&gt; multicodec_data = multicodec.wrap(&#34;ip4&#34;, raw_data)
        &gt;&gt;&gt; raw_data.hex()
          &#39;c0a800fe&#39;
        &gt;&gt;&gt; multicodec_data.hex()
        &#39;04c0a800fe&#39;
        &gt;&gt;&gt; varint.encode(0x04).hex()
        &#39;04&#39; #       0x04 ^^^^ is the multicodec code for &#39;ip4&#39;
        ```
    &#34;&#34;&#34;
    if isinstance(codec, str):
        codec = get(codec)
    elif isinstance(codec, int):
        codec = get(code=codec)
    else:
        validate(codec, Multicodec)
    return codec.wrap(raw_data)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="multiformats.multicodec.Multicodec"><code class="flex name class">
<span>class <span class="ident">Multicodec</span></span>
<span>(</span><span>*, name:Â str, tag:Â str, code:Â Union[int,Â str], status:Â strÂ =Â 'draft', description:Â strÂ =Â '')</span>
</code></dt>
<dd>
<div class="desc"><p>Container class for a multicodec.</p>
<p>Example usage:</p>
<pre><code class="language-py">    &gt;&gt;&gt; Multicodec(**{
    ...     'name': 'cidv1', 'tag': 'cid', 'code': '0x01',
    ...     'status': 'permanent', 'description': 'CIDv1'})
    Multicodec(name='cidv1', tag='cid', code=1,
               status='permanent', description='CIDv1')
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Multicodec:
    &#34;&#34;&#34;
        Container class for a multicodec.

        Example usage:

        ```py
            &gt;&gt;&gt; Multicodec(**{
            ...     &#39;name&#39;: &#39;cidv1&#39;, &#39;tag&#39;: &#39;cid&#39;, &#39;code&#39;: &#39;0x01&#39;,
            ...     &#39;status&#39;: &#39;permanent&#39;, &#39;description&#39;: &#39;CIDv1&#39;})
            Multicodec(name=&#39;cidv1&#39;, tag=&#39;cid&#39;, code=1,
                       status=&#39;permanent&#39;, description=&#39;CIDv1&#39;)
        ```

    &#34;&#34;&#34;

    _name: str
    _tag: str
    _code: int
    _status: Literal[&#34;draft&#34;, &#34;permanent&#34;]
    _description: str

    __slots__ = (&#34;__weakref__&#34;, &#34;_name&#34;, &#34;_tag&#34;, &#34;_code&#34;, &#34;_status&#34;, &#34;_description&#34;)

    def __init__(self, *,
                 name: str,
                 tag: str,
                 code: Union[int, str],
                 status: str = &#34;draft&#34;,
                 description: str = &#34;&#34;
                ):
        for arg in (name, tag, status, description):
            validate(arg, str)
        validate(code, Union[int, str])
        name = Multicodec._validate_name(name)
        code = Multicodec.validate_code(code)
        status = Multicodec._validate_status(status)
        self._name = name
        self._tag = tag
        self._code = code
        self._status = status
        self._description = description

    @staticmethod
    def _validate_name(name: str) -&gt; str:
        if not re.match(r&#34;^[a-z][a-z0-9_-]+$&#34;, name):
            raise err.ValueError(f&#34;Invalid multicodec name {repr(name)}&#34;)
        return name

    @staticmethod
    def validate_code(code: Union[int, str]) -&gt; int:
        &#34;&#34;&#34;
            Validates a multibase code and transforms it to unsigned integer format (if in hex format).
        &#34;&#34;&#34;
        if isinstance(code, str):
            if code.startswith(&#34;0x&#34;):
                code = code[2:]
            code = int(code, base=16)
        if code &lt; 0:
            raise err.ValueError(f&#34;Invalid multicodec code {repr(code)}.&#34;)
        return code

    @staticmethod
    def _validate_status(status: str) -&gt; Literal[&#34;draft&#34;, &#34;permanent&#34;]:
        if status not in (&#34;draft&#34;, &#34;permanent&#34;):
            raise err.ValueError(f&#34;Invalid multicodec status {repr(status)}.&#34;)
        return cast(Literal[&#34;draft&#34;, &#34;permanent&#34;], status)

    @property
    def name(self) -&gt; str:
        &#34;&#34;&#34;
            Multicodec name. Must satisfy the following:

            ```py
            re.match(r&#34;^[a-z][a-z0-9_-]+$&#34;, name)
            ```
        &#34;&#34;&#34;
        return self._name

    @property
    def tag(self) -&gt; str:
        &#34;&#34;&#34; Multicodec tag. &#34;&#34;&#34;
        return self._tag

    @property
    def code(self) -&gt; int:
        &#34;&#34;&#34; Multicodec code. Must be a non-negative integer. &#34;&#34;&#34;
        return self._code

    @property
    def hexcode(self) -&gt; str:
        &#34;&#34;&#34;
            Multicodec code as a hex string (with hex digits zero-padded to even length):

            Example usage:

            ```py
            &gt;&gt;&gt; m = multicodec.get(1)
            &gt;&gt;&gt; m.code
            1
            &gt;&gt;&gt; m.hexcode
            &#39;0x01&#39;
            ```
        &#34;&#34;&#34;
        return _hexcode(self._code)

    @property
    def status(self) -&gt; Literal[&#34;draft&#34;, &#34;permanent&#34;]:
        &#34;&#34;&#34; Multicodec status. &#34;&#34;&#34;
        return self._status

    @property
    def description(self) -&gt; str:
        &#34;&#34;&#34; Multicodec description. &#34;&#34;&#34;
        return self._description

    @property
    def is_private_use(self) -&gt; bool:
        &#34;&#34;&#34;
            Whether this multicodec code is reserved for private use,
            i.e. whether it is in `range(0x300000, 0x400000)`.
        &#34;&#34;&#34;
        return self.code in range(0x300000, 0x400000)

    def wrap(self, raw_data: BytesLike) -&gt; bytes:
        &#34;&#34;&#34;
            Wraps raw binary data into multicodec data:

            ```
            &lt;raw data&gt; -&gt; &lt;code&gt;&lt;raw data&gt;
            ```

            Example usage:

            ```py
            &gt;&gt;&gt; ip4 = multicodec.get(&#34;ip4&#34;)
            &gt;&gt;&gt; ip4
            Multicodec(name=&#39;ip4&#39;, tag=&#39;multiaddr&#39;, code=&#39;0x04&#39;, status=&#39;permanent&#39;, description=&#39;&#39;)
            &gt;&gt;&gt; raw_data = bytes([192, 168, 0, 254])
            &gt;&gt;&gt; multicodec_data = ip4.wrap(raw_data)
            &gt;&gt;&gt; raw_data.hex()
              &#39;c0a800fe&#39;
            &gt;&gt;&gt; multicodec_data.hex()
            &#39;04c0a800fe&#39;
            &gt;&gt;&gt; varint.encode(0x04).hex()
            &#39;04&#39; #       0x04 ^^^^ is the multicodec code for &#39;ip4&#39;
            ```
        &#34;&#34;&#34;
        return varint.encode(self.code)+raw_data

    def unwrap(self, multicodec_data: BytesLike) -&gt; bytes:
        &#34;&#34;&#34;
            Unwraps multicodec binary data to raw data:

            ```
            &lt;code&gt;&lt;raw data&gt; -&gt; &lt;raw data&gt;
            ```

            Additionally checks that the code listed by the data
            matches the code of this multicodec.

            Example usage:

            ```py
            &gt;&gt;&gt; multicodec_data = bytes.fromhex(&#34;c0a800fe&#34;)
            &gt;&gt;&gt; raw_data = ip4.unwrap(multicodec_data)
            &gt;&gt;&gt; multicodec_data.hex()
            &#39;04c0a800fe&#39;
            &gt;&gt;&gt; raw_data.hex()
              &#39;c0a800fe&#39;
            &gt;&gt;&gt; varint.encode(0x04).hex()
            &#39;04&#39; #       0x04 ^^^^ is the multicodec code for &#39;ip4&#39;
            ```
        &#34;&#34;&#34;
        code, _, raw_data = unwrap_raw(multicodec_data)
        # code, _, raw_data = varint.decode_raw(multicodec_data)
        if code != self.code:
            hexcode = _hexcode(code)
            raise err.ValueError(f&#34;Found code {hexcode} when unwrapping data, expected code {self.hexcode}.&#34;)
        return bytes(raw_data)

    def to_json(self) -&gt; Mapping[str, str]:
        &#34;&#34;&#34;
            Returns a JSON dictionary representation of this multicodec object.

            Example usage:

            ```py
            &gt;&gt;&gt; m = multicodec.get(1)
            &gt;&gt;&gt; m.to_json()
            {&#39;name&#39;: &#39;cidv1&#39;, &#39;tag&#39;: &#39;cid&#39;, &#39;code&#39;: &#39;0x01&#39;,
             &#39;status&#39;: &#39;permanent&#39;, &#39;description&#39;: &#39;CIDv1&#39;}
            ```
        &#34;&#34;&#34;
        return {
            &#34;name&#34;: self.name,
            &#34;tag&#34;: self.tag,
            &#34;code&#34;: self.hexcode,
            &#34;status&#34;: self.status,
            &#34;description&#34;: self.description
        }

    def __str__(self) -&gt; str:
        if exists(self.name) and get(self.name) == self:
            return f&#34;multicodec({repr(self.name)}, tag={repr(self.tag)})&#34;
        return repr(self)

    def __repr__(self) -&gt; str:
        return f&#34;Multicodec({&#39;, &#39;.join(f&#39;{k}={repr(v)}&#39; for k, v in self.to_json().items())})&#34;

    @property
    def _as_tuple(self) -&gt; Tuple[Type[&#34;Multicodec&#34;], str, str, int, Literal[&#34;draft&#34;, &#34;permanent&#34;]]:
        return (Multicodec, self.name, self.tag, self.code, self.status)

    def __hash__(self) -&gt; int:
        return hash(self._as_tuple)

    def __eq__(self, other: Any) -&gt; bool:
        if self is other:
            return True
        if not isinstance(other, Multicodec):
            return NotImplemented
        return self._as_tuple == other._as_tuple</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="multiformats.multicodec.Multicodec.validate_code"><code class="name flex">
<span>def <span class="ident">validate_code</span></span>(<span>code:Â Union[int,Â str]) â€‘>Â int</span>
</code></dt>
<dd>
<div class="desc"><p>Validates a multibase code and transforms it to unsigned integer format (if in hex format).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def validate_code(code: Union[int, str]) -&gt; int:
    &#34;&#34;&#34;
        Validates a multibase code and transforms it to unsigned integer format (if in hex format).
    &#34;&#34;&#34;
    if isinstance(code, str):
        if code.startswith(&#34;0x&#34;):
            code = code[2:]
        code = int(code, base=16)
    if code &lt; 0:
        raise err.ValueError(f&#34;Invalid multicodec code {repr(code)}.&#34;)
    return code</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="multiformats.multicodec.Multicodec.code"><code class="name">var <span class="ident">code</span> :Â int</code></dt>
<dd>
<div class="desc"><p>Multicodec code. Must be a non-negative integer.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def code(self) -&gt; int:
    &#34;&#34;&#34; Multicodec code. Must be a non-negative integer. &#34;&#34;&#34;
    return self._code</code></pre>
</details>
</dd>
<dt id="multiformats.multicodec.Multicodec.description"><code class="name">var <span class="ident">description</span> :Â str</code></dt>
<dd>
<div class="desc"><p>Multicodec description.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def description(self) -&gt; str:
    &#34;&#34;&#34; Multicodec description. &#34;&#34;&#34;
    return self._description</code></pre>
</details>
</dd>
<dt id="multiformats.multicodec.Multicodec.hexcode"><code class="name">var <span class="ident">hexcode</span> :Â str</code></dt>
<dd>
<div class="desc"><p>Multicodec code as a hex string (with hex digits zero-padded to even length):</p>
<p>Example usage:</p>
<pre><code class="language-py">&gt;&gt;&gt; m = multicodec.get(1)
&gt;&gt;&gt; m.code
1
&gt;&gt;&gt; m.hexcode
'0x01'
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def hexcode(self) -&gt; str:
    &#34;&#34;&#34;
        Multicodec code as a hex string (with hex digits zero-padded to even length):

        Example usage:

        ```py
        &gt;&gt;&gt; m = multicodec.get(1)
        &gt;&gt;&gt; m.code
        1
        &gt;&gt;&gt; m.hexcode
        &#39;0x01&#39;
        ```
    &#34;&#34;&#34;
    return _hexcode(self._code)</code></pre>
</details>
</dd>
<dt id="multiformats.multicodec.Multicodec.is_private_use"><code class="name">var <span class="ident">is_private_use</span> :Â bool</code></dt>
<dd>
<div class="desc"><p>Whether this multicodec code is reserved for private use,
i.e. whether it is in <code>range(0x300000, 0x400000)</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def is_private_use(self) -&gt; bool:
    &#34;&#34;&#34;
        Whether this multicodec code is reserved for private use,
        i.e. whether it is in `range(0x300000, 0x400000)`.
    &#34;&#34;&#34;
    return self.code in range(0x300000, 0x400000)</code></pre>
</details>
</dd>
<dt id="multiformats.multicodec.Multicodec.name"><code class="name">var <span class="ident">name</span> :Â str</code></dt>
<dd>
<div class="desc"><p>Multicodec name. Must satisfy the following:</p>
<pre><code class="language-py">re.match(r&quot;^[a-z][a-z0-9_-]+$&quot;, name)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def name(self) -&gt; str:
    &#34;&#34;&#34;
        Multicodec name. Must satisfy the following:

        ```py
        re.match(r&#34;^[a-z][a-z0-9_-]+$&#34;, name)
        ```
    &#34;&#34;&#34;
    return self._name</code></pre>
</details>
</dd>
<dt id="multiformats.multicodec.Multicodec.status"><code class="name">var <span class="ident">status</span> :Â Literal['draft',Â 'permanent']</code></dt>
<dd>
<div class="desc"><p>Multicodec status.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def status(self) -&gt; Literal[&#34;draft&#34;, &#34;permanent&#34;]:
    &#34;&#34;&#34; Multicodec status. &#34;&#34;&#34;
    return self._status</code></pre>
</details>
</dd>
<dt id="multiformats.multicodec.Multicodec.tag"><code class="name">var <span class="ident">tag</span> :Â str</code></dt>
<dd>
<div class="desc"><p>Multicodec tag.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def tag(self) -&gt; str:
    &#34;&#34;&#34; Multicodec tag. &#34;&#34;&#34;
    return self._tag</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="multiformats.multicodec.Multicodec.to_json"><code class="name flex">
<span>def <span class="ident">to_json</span></span>(<span>self) â€‘>Â Mapping[str,Â str]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a JSON dictionary representation of this multicodec object.</p>
<p>Example usage:</p>
<pre><code class="language-py">&gt;&gt;&gt; m = multicodec.get(1)
&gt;&gt;&gt; m.to_json()
{'name': 'cidv1', 'tag': 'cid', 'code': '0x01',
 'status': 'permanent', 'description': 'CIDv1'}
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_json(self) -&gt; Mapping[str, str]:
    &#34;&#34;&#34;
        Returns a JSON dictionary representation of this multicodec object.

        Example usage:

        ```py
        &gt;&gt;&gt; m = multicodec.get(1)
        &gt;&gt;&gt; m.to_json()
        {&#39;name&#39;: &#39;cidv1&#39;, &#39;tag&#39;: &#39;cid&#39;, &#39;code&#39;: &#39;0x01&#39;,
         &#39;status&#39;: &#39;permanent&#39;, &#39;description&#39;: &#39;CIDv1&#39;}
        ```
    &#34;&#34;&#34;
    return {
        &#34;name&#34;: self.name,
        &#34;tag&#34;: self.tag,
        &#34;code&#34;: self.hexcode,
        &#34;status&#34;: self.status,
        &#34;description&#34;: self.description
    }</code></pre>
</details>
</dd>
<dt id="multiformats.multicodec.Multicodec.unwrap"><code class="name flex">
<span>def <span class="ident">unwrap</span></span>(<span>self, multicodec_data:Â Union[bytes,Â bytearray,Â memoryview]) â€‘>Â bytes</span>
</code></dt>
<dd>
<div class="desc"><p>Unwraps multicodec binary data to raw data:</p>
<pre><code>&lt;code&gt;&lt;raw data&gt; -&gt; &lt;raw data&gt;
</code></pre>
<p>Additionally checks that the code listed by the data
matches the code of this multicodec.</p>
<p>Example usage:</p>
<pre><code class="language-py">&gt;&gt;&gt; multicodec_data = bytes.fromhex(&quot;c0a800fe&quot;)
&gt;&gt;&gt; raw_data = ip4.unwrap(multicodec_data)
&gt;&gt;&gt; multicodec_data.hex()
'04c0a800fe'
&gt;&gt;&gt; raw_data.hex()
  'c0a800fe'
&gt;&gt;&gt; varint.encode(0x04).hex()
'04' #       0x04 ^^^^ is the multicodec code for 'ip4'
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def unwrap(self, multicodec_data: BytesLike) -&gt; bytes:
    &#34;&#34;&#34;
        Unwraps multicodec binary data to raw data:

        ```
        &lt;code&gt;&lt;raw data&gt; -&gt; &lt;raw data&gt;
        ```

        Additionally checks that the code listed by the data
        matches the code of this multicodec.

        Example usage:

        ```py
        &gt;&gt;&gt; multicodec_data = bytes.fromhex(&#34;c0a800fe&#34;)
        &gt;&gt;&gt; raw_data = ip4.unwrap(multicodec_data)
        &gt;&gt;&gt; multicodec_data.hex()
        &#39;04c0a800fe&#39;
        &gt;&gt;&gt; raw_data.hex()
          &#39;c0a800fe&#39;
        &gt;&gt;&gt; varint.encode(0x04).hex()
        &#39;04&#39; #       0x04 ^^^^ is the multicodec code for &#39;ip4&#39;
        ```
    &#34;&#34;&#34;
    code, _, raw_data = unwrap_raw(multicodec_data)
    # code, _, raw_data = varint.decode_raw(multicodec_data)
    if code != self.code:
        hexcode = _hexcode(code)
        raise err.ValueError(f&#34;Found code {hexcode} when unwrapping data, expected code {self.hexcode}.&#34;)
    return bytes(raw_data)</code></pre>
</details>
</dd>
<dt id="multiformats.multicodec.Multicodec.wrap"><code class="name flex">
<span>def <span class="ident">wrap</span></span>(<span>self, raw_data:Â Union[bytes,Â bytearray,Â memoryview]) â€‘>Â bytes</span>
</code></dt>
<dd>
<div class="desc"><p>Wraps raw binary data into multicodec data:</p>
<pre><code>&lt;raw data&gt; -&gt; &lt;code&gt;&lt;raw data&gt;
</code></pre>
<p>Example usage:</p>
<pre><code class="language-py">&gt;&gt;&gt; ip4 = multicodec.get(&quot;ip4&quot;)
&gt;&gt;&gt; ip4
Multicodec(name='ip4', tag='multiaddr', code='0x04', status='permanent', description='')
&gt;&gt;&gt; raw_data = bytes([192, 168, 0, 254])
&gt;&gt;&gt; multicodec_data = ip4.wrap(raw_data)
&gt;&gt;&gt; raw_data.hex()
  'c0a800fe'
&gt;&gt;&gt; multicodec_data.hex()
'04c0a800fe'
&gt;&gt;&gt; varint.encode(0x04).hex()
'04' #       0x04 ^^^^ is the multicodec code for 'ip4'
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def wrap(self, raw_data: BytesLike) -&gt; bytes:
    &#34;&#34;&#34;
        Wraps raw binary data into multicodec data:

        ```
        &lt;raw data&gt; -&gt; &lt;code&gt;&lt;raw data&gt;
        ```

        Example usage:

        ```py
        &gt;&gt;&gt; ip4 = multicodec.get(&#34;ip4&#34;)
        &gt;&gt;&gt; ip4
        Multicodec(name=&#39;ip4&#39;, tag=&#39;multiaddr&#39;, code=&#39;0x04&#39;, status=&#39;permanent&#39;, description=&#39;&#39;)
        &gt;&gt;&gt; raw_data = bytes([192, 168, 0, 254])
        &gt;&gt;&gt; multicodec_data = ip4.wrap(raw_data)
        &gt;&gt;&gt; raw_data.hex()
          &#39;c0a800fe&#39;
        &gt;&gt;&gt; multicodec_data.hex()
        &#39;04c0a800fe&#39;
        &gt;&gt;&gt; varint.encode(0x04).hex()
        &#39;04&#39; #       0x04 ^^^^ is the multicodec code for &#39;ip4&#39;
        ```
    &#34;&#34;&#34;
    return varint.encode(self.code)+raw_data</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="multiformats" href="../index.html">multiformats</a></code></li>
</ul>
</li>
<li><h3><a href="#header-submodules">Sub-modules</a></h3>
<ul>
<li><code><a title="multiformats.multicodec.err" href="err.html">multiformats.multicodec.err</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="two-column">
<li><code><a title="multiformats.multicodec.exists" href="#multiformats.multicodec.exists">exists</a></code></li>
<li><code><a title="multiformats.multicodec.get" href="#multiformats.multicodec.get">get</a></code></li>
<li><code><a title="multiformats.multicodec.multicodec" href="#multiformats.multicodec.multicodec">multicodec</a></code></li>
<li><code><a title="multiformats.multicodec.register" href="#multiformats.multicodec.register">register</a></code></li>
<li><code><a title="multiformats.multicodec.table" href="#multiformats.multicodec.table">table</a></code></li>
<li><code><a title="multiformats.multicodec.unregister" href="#multiformats.multicodec.unregister">unregister</a></code></li>
<li><code><a title="multiformats.multicodec.unwrap" href="#multiformats.multicodec.unwrap">unwrap</a></code></li>
<li><code><a title="multiformats.multicodec.unwrap_raw" href="#multiformats.multicodec.unwrap_raw">unwrap_raw</a></code></li>
<li><code><a title="multiformats.multicodec.validate_multicodec" href="#multiformats.multicodec.validate_multicodec">validate_multicodec</a></code></li>
<li><code><a title="multiformats.multicodec.wrap" href="#multiformats.multicodec.wrap">wrap</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="multiformats.multicodec.Multicodec" href="#multiformats.multicodec.Multicodec">Multicodec</a></code></h4>
<ul class="two-column">
<li><code><a title="multiformats.multicodec.Multicodec.code" href="#multiformats.multicodec.Multicodec.code">code</a></code></li>
<li><code><a title="multiformats.multicodec.Multicodec.description" href="#multiformats.multicodec.Multicodec.description">description</a></code></li>
<li><code><a title="multiformats.multicodec.Multicodec.hexcode" href="#multiformats.multicodec.Multicodec.hexcode">hexcode</a></code></li>
<li><code><a title="multiformats.multicodec.Multicodec.is_private_use" href="#multiformats.multicodec.Multicodec.is_private_use">is_private_use</a></code></li>
<li><code><a title="multiformats.multicodec.Multicodec.name" href="#multiformats.multicodec.Multicodec.name">name</a></code></li>
<li><code><a title="multiformats.multicodec.Multicodec.status" href="#multiformats.multicodec.Multicodec.status">status</a></code></li>
<li><code><a title="multiformats.multicodec.Multicodec.tag" href="#multiformats.multicodec.Multicodec.tag">tag</a></code></li>
<li><code><a title="multiformats.multicodec.Multicodec.to_json" href="#multiformats.multicodec.Multicodec.to_json">to_json</a></code></li>
<li><code><a title="multiformats.multicodec.Multicodec.unwrap" href="#multiformats.multicodec.Multicodec.unwrap">unwrap</a></code></li>
<li><code><a title="multiformats.multicodec.Multicodec.validate_code" href="#multiformats.multicodec.Multicodec.validate_code">validate_code</a></code></li>
<li><code><a title="multiformats.multicodec.Multicodec.wrap" href="#multiformats.multicodec.Multicodec.wrap">wrap</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>