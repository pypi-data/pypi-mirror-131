#!/usr/bin/env python3

"""
** Makes the communication medium and its use independent. **
-------------------------------------------------------------

Whether it is tcp sockets, files, mailboxes or a drive like dropbox,
we want to be able to use all these media indifferently...
That's the role of this module.
It allows to add an abstraction layer to unify the communication API.
"""

import abc
import socket

from raisin.serialization import deserialize, serialize
from raisin.serialization.iter_tools import anticipate
from raisin.serialization.core import size2tag, tag2size


class AbstractConn:
    """
    ** Allows for easier communication. **

    It is the basic abstract class that allows to make information
    carriers of very different nature communicate in the same way.
    """

    @abc.abstractmethod
    def send(self, raw, dest=None):
        """
        ** Sends a data stream to the recipient. **

        Must be overwritten.

        Parameters
        ----------
        raw : iterator
            A generator that yields byte strings. The division is arbitrary.
            On reception, the packets received are not necessarily split in the same way.
            This flow can typically be generated by the ``raisin.serialization.serialize`` function.
        dest : str, default=None
            The address of the recipient(s) of the message.
            By default (None), the message is sent to the main recipient.

        Raises
        ------
        KeyError
            If the address does not exist.
        """
        raise NotImplementedError('this abstract method must be overwritten')

    def send_obj(self, obj, dest=None, **kwargs):
        """
        ** Sends an object to the recipient. **

        Can be overwritten.

        Parameters
        ----------
        obj
            It is the serialisable object that is sent to the recipient(s).
        dest : str, default=None
            Same as ``AbstractConn.send``.
        **kwargs : dict
            These are the parameters passed to the ``raisin.serialization.serialize`` function.
        """
        self.send(serialize(obj, **kwargs), dest=dest)

    @abc.abstractmethod
    def recv(self, dest=None):
        """
        ** Recovers the raw data sent by the sender. **

        Must be overwritten.

        Parameters
        ----------
        dest : str, default=None
            The address of the sender of the message.
            By default (None), the message is read to the main connection.

        Yields
        ------
        bytes
            The packets of bytes emitted by the ``AbstractConn.send``
            method of the sender. Packet decoding may differ, but the order is preserved.

        Raises
        ------
        ConnectionError
            If the connection is broken.
        KeyError
            If the address does not exist.
        """
        raise NotImplementedError('this abstract method must be overwritten')

    def recv_obj(self, **kwargs):
        """
        ** Recover and deserialize the sent object. **

        Can be overwritten.

        Parameters
        ----------
        **kwargs : dict
            These are the parameters passed to the ``raisin.serialization.deserialize`` function.

        Returns
        -------
        obj
            The emitted object.
        """
        return deserialize(self.recv(), **kwargs)

    @abc.abstractmethod
    def close(self):
        """
        ** Definitely close the connection. **

        Must be overwritten.
        """
        raise NotImplementedError('this abstract method must be overwritten')

    def __del__(self):
        self.close()


class SocketAbstractConn(AbstractConn):
    """
    ** Adds an abstraction layer to TCP sockets. **

    Attributes
    ----------
    conn : socket.socket
        A socket capable of reading and sending data.
    """

    def __init__(self, conn):
        self.conn = conn
        self._recv_pack = b'' # buffer memory

    def send(self, raw, dest=None):
        """
        ** Implementation of ``AbstactConn.send``. **
        """
        if dest is not None:
            raise KeyError('this connection is linked to a single recipient')
        for is_end, pack in anticipate(raw):
            signed_pack = bytes([is_end]) + size2tag(len(pack)) + pack
            self.conn.sendall(signed_pack)

    def recv(self, dest=None):
        """
        ** Implementation of ``AbstraConn.recv``. **
        """
        def gen():
            while True:
                try:
                    yield self.conn.recv(4096)
                except OSError as err:
                    raise ConnectionError('communication seems to be interrupted') from err
        if dest is not None:
            raise KeyError('this connection is linked to a single recipient')
        iter_pack = iter(gen())
        while True:
            # check for len and last pack
            while not self._recv_pack:
                self._recv_pack += next(iter_pack)
            is_end = bool(self._recv_pack[0])
            self._recv_pack = self._recv_pack[1:]
            size, self._recv_pack, _ = tag2size(pack=self._recv_pack, gen=iter_pack)
            while len(self._recv_pack) < size:
                self._recv_pack += next(iter_pack)
            yield self._recv_pack[:size]
            self._recv_pack = self._recv_pack[size:]
            if is_end:
                break

    def close(self):
        """
        ** Implementation of ``AbstractConn.close``. **
        """
        try:
            self.conn.shutdown(socket.SHUT_RDWR)
        except OSError:
            pass
        self.conn.close()


class BridgeAbstractConn(AbstractConn):
    """
    ** Allows one connection to reach others. **

    Attributes
    ----------
    main_conn : AbstractConn
        The main connection, the one that is intended
        when the target is not specified.
    other_conn : dict
        To each connection name, associate the connection.
    """

    def __init__(self, main_conn, other_conn):
        self.main_conn = main_conn
        self.other_conn = other_conn

    def send(self, raw, dest=None):
        """
        ** Implementation of ``AbstactConn.send``. **
        """
        if dest is None:
            return self.main_conn.send(raw)
        try:
            return self.other_conn[dest].send(raw)
        except KeyError as err:
            raise KeyError(
                f"only the recipients {list(self.other_conn.keys())} exist, not '{dest}'"
            ) from err

    def recv(self, dest=None):
        """
        ** Implementation of ``AbstraConn.recv``. **
        """
        if dest is None:
            yield from self.main_conn.recv()
        elif dest in self.other_conn:
            yield from self.other_conn[dest].recv()
        else:
            raise KeyError(
                f"only the recipients {list(self.other_conn.keys())} exist, not '{dest}'"
            )

    def close(self):
        """
        ** Implementation of ``AbstractConn.close``. **
        """
        self.main_conn.close()
        for conn in self.other_conn.values():
            conn.close()


class ServerAbstractConn(AbstractConn):
    """
    ** Allows you to bridge the gap between clients. **

    The 'server' class inherits from this class.
    Thus, it is possible to make the different clients connected
    to the same server communicate with each other.

    Attributes
    ----------
    clients_conn : dict
        To each client identifier, associates the connection of this client.
    """

    def __init__(self):
        self.clients_conn = {}

    def _conn_expansion(self, abstract_conn):
        """
        ** Memorizes and expands a connection. **

        The server calls this method when the handler is created.
        This is to extend the *abstract_conn* connection so that
        the handler can have access to other clients.

        Parameters
        ----------
        abstract_conn : AbstractConn
            A simple and minimalist connection that
            allows you to get in touch with a single client.

        Returns
        -------
        extended_abstract_conn : AbstractConn
            A connection that allows of course to continue to communicate with the customers.
            That is, it has a similar behavior to the *abstract_conn* argument,
            but it also allows to address the connections of other clients.
        """
        self.clients_conn['id client'] = abstract_conn
        return BridgeAbstractConn(main_conn=abstract_conn, other_conn=self.clients_conn)

    def send(self, raw, dest=None):
        """
        ** Implementation of ``AbstactConn.send``. **
        """
        if dest is None:
            raise KeyError(
                'there is no default receiver, you have to specify: '
                f'{list(self.clients_conn.keys())}'
            )
        try:
            return self.clients_conn[dest].send(raw)
        except KeyError as err:
            raise KeyError(
                f"only the recipients {list(self.clients_conn.keys())} exist, not '{dest}'"
            ) from err

    def recv(self, dest=None):
        """
        ** Implementation of ``AbstraConn.recv``. **
        """
        if dest is None:
            raise KeyError(
                'there is no default receiver, you have to specify: '
                f'{list(self.clients_conn.keys())}'
            )
        if dest not in self.clients_conn:
            raise KeyError(
                f"only the recipients {list(self.clients_conn.keys())} exist, not '{dest}'"
            )
        yield from self.clients_conn[dest].recv()

    def close(self):
        """
        ** Implementation of ``AbstractConn.close``. **
        """
        for conn in self.clients_conn.values():
            conn.close()
