

class PythonTransformer:
    TOP_COMMENT = '"""\n' \
                  '{classname} type definition file generated by TypeBuf\n' \
                  'Note: Any changes made to this file will be overwritten\n' \
                  '      during next compilation\n' \
                  '"""\n\n'
    TYPE_STRS = {
        "string": "str",
        "int": "int",
        "float": "float",
        "boolean": "bool",
    }
    WS = '    '
    OPTIONAL = 'Optional[{type}]'
    FILENAME = '{classnamelower}.py'
    COMMENTCHAR = '#'
    CLASS_DEF = 'class {classname}:\n'
    CLASS_ATTR_WITH_T = '{ws}{attrname}: {typeannotation}\n'

    def __init__(self, typedef: 'TypeDefinition'):
        self.typedef = typedef
        self.output_file: str = ''
        self.output_buf: str = ''
        self.method_order = [
            self.generate_top_comment,
            self.scan_for_required_imports,
            self.generate_class_declaration,
            self.generate_attributes
        ]

    def generate_filename(self):
        self.output_file = self.__class__.FILENAME.format(
            classnamelower=self.typedef.typename.lower()
        )

    def scan_for_required_imports(self) -> str:
        # Figure out a good way to do this
        # Cheat for now
        """
        Wil scan the typedef for any imports we might need to do and return the import str
        :param typedef:
        :return: (str) The actual import str to write to the file or just "\n" if none
        """
        return 'from typing import *\n\n\n'

    def generate_top_comment(self):
        return self.__class__.TOP_COMMENT.format(
            classname=self.typedef.typename.capitalize()
        )

    def generate_class_declaration(self):
        return self.__class__.CLASS_DEF.format(classname=self.typedef.typename)

    def write_buf(self) -> None:
        # This should be in the parent class
        with open(self.output_file, 'w') as f:
            f.write(self.output_buf)

    def generate_attributes(self) -> str:
        output_str = ''
        for attribute in self.typedef.fields:
            attrname = attribute.name
            typeannotation = self.__class__.TYPE_STRS[attribute.type]
            if attribute.optional:
                typeannotation = self.__class__.OPTIONAL.format(type=typeannotation)
            output_str += self.__class__.CLASS_ATTR_WITH_T.format(
                ws=self.__class__.WS, attrname=attrname,
                typeannotation=typeannotation
            )
        return output_str
