# Generated using mypy stubgen, then filling in types and removing internals.

from .type_util import TypeAgent
from types import ModuleType
from typing import Any, Optional, Callable, TypeVar

T_Callable = TypeVar('T_Callable', bound=Callable)
def override(func: T_Callable, auto: bool = ...) -> T_Callable: ...
def typechecked_func(func: T_Callable, force: bool = ..., argType: Optional[Any] = ..., resType: Optional[Any] = ..., prop_getter: bool = ...): ...
def typechecked_class(cls, force: bool = ..., force_recursive: bool = ...): ...
T_Mod = TypeVar('T_Mod', ModuleType, str)
def typechecked_module(md: T_Mod, force_recursive: bool = ...) -> T_Mod: ...

T = TypeVar('T', Callable, property, type, str, ModuleType)
def typechecked(memb: T) -> T: ...
T_Class = TypeVar('T_Class', bound=type)
def auto_override_class(cls: T_Class, force: bool = ..., force_recursive: bool = ...) -> T_Class: ...
def auto_override_module(md: T_Mod, force_recursive: bool = ...) -> T_Mod: ...
def auto_override(memb: T) -> T: ...
def no_type_check(memb: T) -> T: ...
def is_no_type_check(memb: T) -> bool: ...
def check_argument_types(cllable: Optional[Callable] = ..., call_args: Optional[Any] = ..., clss: Optional[type] = ..., caller_level: int = ...) -> Callable: ...
def check_return_type(value: Any, cllable: Optional[Callable] = ..., clss: Optional[type] = ..., caller_level: int = ...) -> Callable: ...

class TypeChecker(TypeAgent):
    def __init__(self, all_threads: bool = ...) -> None: ...
