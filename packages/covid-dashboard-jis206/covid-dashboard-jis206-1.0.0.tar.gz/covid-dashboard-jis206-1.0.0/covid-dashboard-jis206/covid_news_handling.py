"""
Gets the news headlines related to Covid and handles the News API
"""
import sched
import time
import json
import logging
import requests
from flask import Markup
from flask import request
from time_handler import seconds_from_now_to_hhmm

FORMAT='%(levelname)s:%(asctime)s:%(message)s'
logging.basicConfig(format=FORMAT,filename='sys.log', encoding='utf-8', level=logging.INFO)

news_scheduler = sched.scheduler(time.time, time.sleep)
news_scheduler.run(blocking=False)
news_articles = []
blacklist = []
updates = {}



def add_to_blacklist(article: str) -> None:
    """
    Adds the input article to a blacklist so that the article does not appear again
    """
    logging.info("%s added to the blacklist", article)
    blacklist.append(article)

def news_API_request(covid_terms: str ="Covid COVID-19 coronavirus") -> list:
    """
    Access the NewsApi and filter and return all articles with any of the covid_terms in the title
    """

    with open('config.json', 'r', encoding="UTF-8") as file:
        config = json.load(file)
        api_key = config["api-key"]
        country = config["newsCountry"]

    base_url = "https://newsapi.org/v2/top-headlines?"
    articles=[]
    covid_terms_list = covid_terms.split()
    for i in covid_terms_list:
        logging.info("Requesting articles containing the keyword: %s", i)
        complete_url = f"{base_url}q={i}&apiKey={api_key}&country={country}"
        this_response = requests.get(complete_url).json()
        for response in this_response["articles"]:
            if response not in articles:
                articles.append(response)
    return articles

def parse_news_API(articles: list) -> list:
    """
    Takes a list of news articles as generated by news_api_request
    and makes them into a more usuable format. It also filters and
    removes the blacklisted items.

    Format:
    Each article has:
        - A title: The name of the article as a hyperlink to its webpage
        - Content: The brief summary description given about each article by the API
    """

    logging.info("Parsing articles into a more usable format")

    news = []
    for article in articles:
        title = f"{article['title']}"
        content = article["description"]
        url = article["url"]
        story = {
            'title':Markup('<a href='+url+'>'+title+'</a>'),
            "content":content
        }
        if story["title"] not in blacklist:
            news.append(story)
    return news

def update_news(covid_terms: str = "Covid COVID-19 coronavirus") -> dict:
    """
    Executes the entire API request including filtering.

    Bundled into 1 function for the scheduler to execute
    """
    all_articles = news_API_request(covid_terms)
    filtered_articles = parse_news_API(all_articles)
    return filtered_articles

def update(update_interval: int, update_name: str, time_occur: int, repeat: bool = True) -> None:
    """
    Updates the covid data and creates a new update in the same interval if requested

    Executed by the scheduler
    """
    with open('config.json', 'r', encoding="UTF-8") as file:
        config = json.load(file)
        news_terms = config["newsTerms"]
    logging.info("Updating news articles")
    global news_articles
    news_articles = update_news(news_terms)
    updates.pop(update_name)
    if repeat:
        updates[update_name] = [news_scheduler.enter(
            update_interval, 1, update, (update_interval, update_name, time_occur, repeat)),
            repeat, time_occur]
        logging.info("Update %s scheduled for %s", update_name, time_occur)


def schedule_news_update(update_interval: int, update_name: str, repeat: bool = False) -> None:
    """
    Schedules a news update to take place after the interval has elapsed
    """
    time_occur = seconds_from_now_to_hhmm(update_interval)
    repeat = bool(request.args.get("repeat"))
    if updates[update_name]:
        logging.error("Update with that name already exists. Terminating this update attempt")
        return
    updates[update_name] = [news_scheduler.enter(
        update_interval, 1, update, (update_interval, update_name, time_occur, repeat)),
        repeat, time_occur]
    logging.info("Update %s scheduled for %s", update_name, time_occur)


def delete_update(update_name: str) -> None:
    """
    Deletes the update with the assigned name from the scheduler event
    """
    news_scheduler.cancel(updates.pop(update_name))
    logging.info("Update %s removed", update_name)
